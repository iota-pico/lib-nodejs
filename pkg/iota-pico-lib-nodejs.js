module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading wasm modules
/******/ 	var installedWasmModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// object with all compiled WebAssembly.Modules
/******/ 	__webpack_require__.w = {};
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./pkg/bootstrap.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../iota-pico-api/dist/client/apiClient.js":
/*!*************************************************!*\
  !*** ../iota-pico-api/dist/client/apiClient.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ \"../iota-pico-api/node_modules/@babel/runtime/regenerator/index.js\");\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _next(value) { step(\"next\", value); } function _throw(err) { step(\"throw\", err); } _next(); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar arrayHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/arrayHelper */ \"../iota-pico-core/dist/helpers/arrayHelper.js\");\n\nvar numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ \"../iota-pico-core/dist/helpers/numberHelper.js\");\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar stringHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/stringHelper */ \"../iota-pico-core/dist/helpers/stringHelper.js\");\n\nvar nullLogger_1 = __webpack_require__(/*! @iota-pico/core/dist/loggers/nullLogger */ \"../iota-pico-core/dist/loggers/nullLogger.js\");\n\nvar apiError_1 = __webpack_require__(/*! ../error/apiError */ \"../iota-pico-api/dist/error/apiError.js\");\n/**\r\n * Default implementation of an api client.\r\n */\n\n\nvar ApiClient =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * Create an instance of ApiClient.\r\n   * @param networkClient The network client to communicate through.\r\n   * @param apiVersion The API version to send with the requests\r\n   * @param additionalHeaders Extra headers to send with the requests.\r\n   * @param logger Logger to send communication info to.\r\n   */\n  function ApiClient(networkClient) {\n    var apiVersion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"1\";\n    var additionalHeaders = arguments.length > 2 ? arguments[2] : undefined;\n    var logger = arguments.length > 3 ? arguments[3] : undefined;\n\n    _classCallCheck(this, ApiClient);\n\n    if (objectHelper_1.ObjectHelper.isEmpty(networkClient)) {\n      throw new apiError_1.ApiError(\"The networkClient must be defined\");\n    }\n\n    if (stringHelper_1.StringHelper.isEmpty(apiVersion)) {\n      throw new apiError_1.ApiError(\"The apiVersion must not be empty\");\n    }\n\n    this._networkClient = networkClient;\n    this._apiVersion = apiVersion;\n    this._additionalHeaders = additionalHeaders;\n    this._logger = logger || new nullLogger_1.NullLogger();\n  }\n  /**\r\n   * Returns information about your node.\r\n   * @returns Promise which resolves to the getNodeInfo response object or rejects with error.\r\n   */\n\n\n  _createClass(ApiClient, [{\n    key: \"getNodeInfo\",\n    value: function () {\n      var _getNodeInfo = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", this.sendCommand(\"getNodeInfo\", {}));\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      return function getNodeInfo() {\n        return _getNodeInfo.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Returns the set of neighbors you are connected with, as well as their activity count.\r\n     * The activity counter is reset after restarting IRI.\r\n     * @returns Promise which resolves to the getNeighbors response object or rejects with error.\r\n     */\n\n  }, {\n    key: \"getNeighbors\",\n    value: function () {\n      var _getNeighbors = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt(\"return\", this.sendCommand(\"getNeighbors\", {}));\n\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      return function getNeighbors() {\n        return _getNeighbors.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Add a list of neighbors to your node. It should be noted that this is only temporary,\r\n     * and the added neighbors will be removed from your set of neighbors after you relaunch IRI.\r\n     * @returns Promise which resolves to the addNeighbors response object or rejects with error.\r\n     */\n\n  }, {\n    key: \"addNeighbors\",\n    value: function () {\n      var _addNeighbors = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3(request) {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!objectHelper_1.ObjectHelper.isEmpty(request)) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request must be defined\");\n\n              case 2:\n                if (!arrayHelper_1.ArrayHelper.isEmpty(request.uris)) {\n                  _context3.next = 4;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request.uris must not be empty\");\n\n              case 4:\n                return _context3.abrupt(\"return\", this.sendCommand(\"addNeighbors\", request));\n\n              case 5:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      return function addNeighbors(_x) {\n        return _addNeighbors.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Removes a list of neighbors from your node. This is only temporary, and if you have your\r\n     * neighbors added via the command line, they will be retained after you restart your node.\r\n     * @returns Promise which resolves to the removeNeighbors response object or rejects with error.\r\n     */\n\n  }, {\n    key: \"removeNeighbors\",\n    value: function () {\n      var _removeNeighbors = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee4(request) {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!objectHelper_1.ObjectHelper.isEmpty(request)) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request must be defined\");\n\n              case 2:\n                if (!arrayHelper_1.ArrayHelper.isEmpty(request.uris)) {\n                  _context4.next = 4;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request.uris must not be empty\");\n\n              case 4:\n                return _context4.abrupt(\"return\", this.sendCommand(\"removeNeighbors\", request));\n\n              case 5:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      return function removeNeighbors(_x2) {\n        return _removeNeighbors.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Returns the list of tips.\r\n     * @returns Promise which resolves to the getTips response object or rejects with error.\r\n     */\n\n  }, {\n    key: \"getTips\",\n    value: function () {\n      var _getTips = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee5() {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                return _context5.abrupt(\"return\", this.sendCommand(\"getTips\", {}));\n\n              case 1:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      return function getTips() {\n        return _getTips.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Find the transactions which match the specified input and return. All input values are lists,\r\n     * for which a list of return values (transaction hashes), in the same order, is returned for all\r\n     * individual elements. The input fields can either be bundles, addresses, tags or approvees.\r\n     * Using multiple of these input fields returns the intersection of the values.\r\n     * @returns Promise which resolves to the findTransactions response object or rejects with error.\r\n     */\n\n  }, {\n    key: \"findTransactions\",\n    value: function () {\n      var _findTransactions = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee6(request) {\n        var bundlesEmpty, addressesEmpty, tagsEmpty, approveesEmpty;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (!objectHelper_1.ObjectHelper.isEmpty(request)) {\n                  _context6.next = 2;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request must be defined\");\n\n              case 2:\n                bundlesEmpty = arrayHelper_1.ArrayHelper.isEmpty(request.bundles);\n                addressesEmpty = arrayHelper_1.ArrayHelper.isEmpty(request.addresses);\n                tagsEmpty = arrayHelper_1.ArrayHelper.isEmpty(request.tags);\n                approveesEmpty = arrayHelper_1.ArrayHelper.isEmpty(request.approvees);\n\n                if (!(bundlesEmpty && addressesEmpty && tagsEmpty && approveesEmpty)) {\n                  _context6.next = 8;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"One of the bundle, addresses, tags or approvees must not be empty\");\n\n              case 8:\n                return _context6.abrupt(\"return\", this.sendCommand(\"findTransactions\", request));\n\n              case 9:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      return function findTransactions(_x3) {\n        return _findTransactions.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Returns the raw transaction data (trytes) of a specific transaction.\r\n     * These trytes can then be easily converted into the actual transaction object.\r\n     * @returns Promise which resolves to the findTransactions response object or rejects with error.\r\n     */\n\n  }, {\n    key: \"getTrytes\",\n    value: function () {\n      var _getTrytes = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee7(request) {\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (!objectHelper_1.ObjectHelper.isEmpty(request)) {\n                  _context7.next = 2;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request must be defined\");\n\n              case 2:\n                if (!arrayHelper_1.ArrayHelper.isEmpty(request.hashes)) {\n                  _context7.next = 4;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request.hashes must not be empty\");\n\n              case 4:\n                return _context7.abrupt(\"return\", this.sendCommand(\"getTrytes\", request));\n\n              case 5:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      return function getTrytes(_x4) {\n        return _getTrytes.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Get the inclusion states of a set of transactions. This is for determining if a transaction\r\n     * was accepted and confirmed by the network or not. You can search for multiple tips (and thus,\r\n     * milestones) to get past inclusion states of transactions.\r\n     * @returns Promise which resolves to the getInclusionStates response object or rejects with error.\r\n     */\n\n  }, {\n    key: \"getInclusionStates\",\n    value: function () {\n      var _getInclusionStates = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee8(request) {\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                if (!objectHelper_1.ObjectHelper.isEmpty(request)) {\n                  _context8.next = 2;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request must be defined\");\n\n              case 2:\n                if (!arrayHelper_1.ArrayHelper.isEmpty(request.transactions)) {\n                  _context8.next = 4;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request.transactions must not be empty\");\n\n              case 4:\n                if (!arrayHelper_1.ArrayHelper.isEmpty(request.tips)) {\n                  _context8.next = 6;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request.tips must not be empty\");\n\n              case 6:\n                return _context8.abrupt(\"return\", this.sendCommand(\"getInclusionStates\", request));\n\n              case 7:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      return function getInclusionStates(_x5) {\n        return _getInclusionStates.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Returns the confirmed balance which a list of addresses have at the latest confirmed milestone.\r\n     * In addition to the balances, it also returns the milestone as well as the index with which the\r\n     * confirmed balance was determined. The balances is returned as a list in the same order as the\r\n     * addresses were provided as input.\r\n     * @param request The getBalances request object.\r\n     * @returns Promise which resolves to the getBalances response object or rejects with error.\r\n     */\n\n  }, {\n    key: \"getBalances\",\n    value: function () {\n      var _getBalances = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee9(request) {\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                if (!objectHelper_1.ObjectHelper.isEmpty(request)) {\n                  _context9.next = 2;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request must be defined\");\n\n              case 2:\n                if (!arrayHelper_1.ArrayHelper.isEmpty(request.addresses)) {\n                  _context9.next = 4;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request.addresses must not be empty\");\n\n              case 4:\n                if (numberHelper_1.NumberHelper.isInteger(request.threshold)) {\n                  _context9.next = 6;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request.threshold must be a valid number\");\n\n              case 6:\n                return _context9.abrupt(\"return\", this.sendCommand(\"getBalances\", request));\n\n              case 7:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      return function getBalances(_x6) {\n        return _getBalances.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Tip selection which returns trunkTransaction and branchTransaction. The input value is depth,\r\n     * which basically determines how many bundles to go back to for finding the transactions to approve.\r\n     * The higher your depth value, the more \"babysitting\" you do for the network (as you have to confirm more transactions).\r\n     * @param request The getTransactionsToApprove request object.\r\n     * @returns Promise which resolves to the getTransactionsToApprove response object or rejects with error.\r\n     */\n\n  }, {\n    key: \"getTransactionsToApprove\",\n    value: function () {\n      var _getTransactionsToApprove = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee10(request) {\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                if (!objectHelper_1.ObjectHelper.isEmpty(request)) {\n                  _context10.next = 2;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request must be defined\");\n\n              case 2:\n                if (numberHelper_1.NumberHelper.isInteger(request.depth)) {\n                  _context10.next = 4;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request.depth must be a valid number\");\n\n              case 4:\n                if (!(!objectHelper_1.ObjectHelper.isEmpty(request.reference) && stringHelper_1.StringHelper.isEmpty(request.reference))) {\n                  _context10.next = 6;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request.reference must be a non empty string\");\n\n              case 6:\n                if (!(!objectHelper_1.ObjectHelper.isEmpty(request.numWalks) && !numberHelper_1.NumberHelper.isInteger(request.numWalks))) {\n                  _context10.next = 8;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request.numWalks must be a valid number\");\n\n              case 8:\n                return _context10.abrupt(\"return\", this.sendCommand(\"getTransactionsToApprove\", request));\n\n              case 9:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      return function getTransactionsToApprove(_x7) {\n        return _getTransactionsToApprove.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Attaches the specified transactions (trytes) to the Tangle by doing Proof of Work. You need to supply\r\n     * branchTransaction as well as trunkTransaction (basically the tips which you're going to validate and\r\n     * reference with this transaction) - both of which you'll get through the getTransactionsToApprove API call.\r\n     * @param request The attachToTangle request object.\r\n     * @returns Promise which resolves to the attachToTangle response object or rejects with error.\r\n     */\n\n  }, {\n    key: \"attachToTangle\",\n    value: function () {\n      var _attachToTangle = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee11(request) {\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                if (!objectHelper_1.ObjectHelper.isEmpty(request)) {\n                  _context11.next = 2;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request must be defined\");\n\n              case 2:\n                if (!stringHelper_1.StringHelper.isEmpty(request.trunkTransaction)) {\n                  _context11.next = 4;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request.trunkTransaction must not be empty\");\n\n              case 4:\n                if (!stringHelper_1.StringHelper.isEmpty(request.branchTransaction)) {\n                  _context11.next = 6;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request.branchTransaction must not be empty\");\n\n              case 6:\n                if (numberHelper_1.NumberHelper.isInteger(request.minWeightMagnitude)) {\n                  _context11.next = 8;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request.minWeightMagnitude must be a valid number\");\n\n              case 8:\n                if (!arrayHelper_1.ArrayHelper.isEmpty(request.trytes)) {\n                  _context11.next = 10;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request.trytes must not be empty\");\n\n              case 10:\n                return _context11.abrupt(\"return\", this.sendCommand(\"attachToTangle\", request));\n\n              case 11:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      return function attachToTangle(_x8) {\n        return _attachToTangle.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Interrupts and completely aborts the attachToTangle process\r\n     * @returns Promise which resolves with empty response object or rejects with error.\r\n     */\n\n  }, {\n    key: \"interruptAttachingToTangle\",\n    value: function () {\n      var _interruptAttachingToTangle = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee12() {\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                return _context12.abrupt(\"return\", this.sendCommand(\"interruptAttachingToTangle\", {}));\n\n              case 1:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      return function interruptAttachingToTangle() {\n        return _interruptAttachingToTangle.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Broadcast a list of transactions to all neighbors. The input trytes for this call are provided by attachToTangle.\r\n     * @param request The broadcastTransactions request object.\r\n     * @returns Promise which resolves with empty response object or rejects with error.\r\n     */\n\n  }, {\n    key: \"broadcastTransactions\",\n    value: function () {\n      var _broadcastTransactions = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee13(request) {\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                if (!objectHelper_1.ObjectHelper.isEmpty(request)) {\n                  _context13.next = 2;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request must be defined\");\n\n              case 2:\n                if (!arrayHelper_1.ArrayHelper.isEmpty(request.trytes)) {\n                  _context13.next = 4;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request.trytes must not be empty\");\n\n              case 4:\n                return _context13.abrupt(\"return\", this.sendCommand(\"broadcastTransactions\", request));\n\n              case 5:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      return function broadcastTransactions(_x9) {\n        return _broadcastTransactions.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Store transactions into the local storage. The trytes to be used for this call are returned by attachToTangle.\r\n     * @param request The storeTransactions request object.\r\n     * @returns Promise which resolves with empty response object or rejects with error.\r\n     */\n\n  }, {\n    key: \"storeTransactions\",\n    value: function () {\n      var _storeTransactions = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee14(request) {\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                if (!objectHelper_1.ObjectHelper.isEmpty(request)) {\n                  _context14.next = 2;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request must be defined\");\n\n              case 2:\n                if (!arrayHelper_1.ArrayHelper.isEmpty(request.trytes)) {\n                  _context14.next = 4;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request.trytes must not be empty\");\n\n              case 4:\n                return _context14.abrupt(\"return\", this.sendCommand(\"storeTransactions\", request));\n\n              case 5:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      return function storeTransactions(_x10) {\n        return _storeTransactions.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Get transactions with missing references.\r\n     * @param request The getMissingTransactions request object.\r\n     * @returns Promise which resolves to the getMissingTransactions response object or rejects with error.\r\n     */\n\n  }, {\n    key: \"getMissingTransactions\",\n    value: function () {\n      var _getMissingTransactions = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee15() {\n        return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                return _context15.abrupt(\"return\", this.sendCommand(\"getMissingTransactions\", {}));\n\n              case 1:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      return function getMissingTransactions() {\n        return _getMissingTransactions.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Check the consistency of tail hashes.\r\n     * @param request The checkConsistency request object.\r\n     * @returns Promise which resolves to the checkConsistency response object or rejects with error.\r\n     */\n\n  }, {\n    key: \"checkConsistency\",\n    value: function () {\n      var _checkConsistency = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee16(request) {\n        return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                if (!objectHelper_1.ObjectHelper.isEmpty(request)) {\n                  _context16.next = 2;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request must be defined\");\n\n              case 2:\n                if (!arrayHelper_1.ArrayHelper.isEmpty(request.tails)) {\n                  _context16.next = 4;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request.tails must not be empty\");\n\n              case 4:\n                return _context16.abrupt(\"return\", this.sendCommand(\"checkConsistency\", request));\n\n              case 5:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n\n      return function checkConsistency(_x11) {\n        return _checkConsistency.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Have the requested addresses been spent from already.\r\n     * @param request The wereAddressesSpentFrom request object.\r\n     * @returns Promise which resolves to the wereAddressesSpentFrom response object or rejects with error.\r\n     */\n\n  }, {\n    key: \"wereAddressesSpentFrom\",\n    value: function () {\n      var _wereAddressesSpentFrom = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee17(request) {\n        return _regeneratorRuntime.wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                if (!objectHelper_1.ObjectHelper.isEmpty(request)) {\n                  _context17.next = 2;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request must be defined\");\n\n              case 2:\n                if (!arrayHelper_1.ArrayHelper.isEmpty(request.addresses)) {\n                  _context17.next = 4;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request.addresses must not be empty\");\n\n              case 4:\n                return _context17.abrupt(\"return\", this.sendCommand(\"wereAddressesSpentFrom\", request));\n\n              case 5:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n\n      return function wereAddressesSpentFrom(_x12) {\n        return _wereAddressesSpentFrom.apply(this, arguments);\n      };\n    }()\n    /* @internal */\n\n  }, {\n    key: \"sendCommand\",\n    value: function () {\n      var _sendCommand = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee18(command, request) {\n        var _this = this;\n\n        return _regeneratorRuntime.wrap(function _callee18$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                this._logger.info(\"===> \".concat(command), request);\n\n                Object.defineProperty(request, \"command\", {\n                  value: command,\n                  enumerable: true\n                });\n                return _context18.abrupt(\"return\", this._networkClient.postJson(request, undefined, this.createHeaders()).then(function (response) {\n                  _this._logger.info(\"===> \".concat(command), response);\n\n                  return response;\n                }).catch(function (err) {\n                  _this._logger.error(\"===> \".concat(command, \" Error\"), err);\n\n                  if (err.additional && err.additional.errorResponse) {\n                    try {\n                      var apiError = JSON.parse(err.additional.errorResponse);\n\n                      if (apiError.error) {\n                        delete err.additional.errorResponse;\n                        err.additional.apiError = apiError.error;\n                      } else if (apiError.exception) {\n                        delete err.additional.errorResponse;\n                        err.additional.apiError = apiError.exception;\n                      }\n                    } catch (e) {}\n                  }\n\n                  throw err;\n                }));\n\n              case 3:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n        }, _callee18, this);\n      }));\n\n      return function sendCommand(_x13, _x14) {\n        return _sendCommand.apply(this, arguments);\n      };\n    }()\n    /* @internal */\n\n  }, {\n    key: \"createHeaders\",\n    value: function createHeaders() {\n      var headers = this._additionalHeaders || {};\n      headers[\"X-IOTA-API-Version\"] = this._apiVersion;\n      return headers;\n    }\n  }]);\n\n  return ApiClient;\n}();\n\nexports.ApiClient = ApiClient;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-api/dist/client/apiClient.js?");

/***/ }),

/***/ "../iota-pico-api/dist/error/apiError.js":
/*!***********************************************!*\
  !*** ../iota-pico-api/dist/error/apiError.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar coreError_1 = __webpack_require__(/*! @iota-pico/core/dist/error/coreError */ \"../iota-pico-core/dist/error/coreError.js\");\n/**\r\n * An api implementation of an error.\r\n */\n\n\nvar ApiError =\n/*#__PURE__*/\nfunction (_coreError_1$CoreErro) {\n  _inherits(ApiError, _coreError_1$CoreErro);\n\n  function ApiError() {\n    _classCallCheck(this, ApiError);\n\n    return _possibleConstructorReturn(this, (ApiError.__proto__ || Object.getPrototypeOf(ApiError)).apply(this, arguments));\n  }\n\n  return ApiError;\n}(coreError_1.CoreError);\n\nexports.ApiError = ApiError;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-api/dist/error/apiError.js?");

/***/ }),

/***/ "../iota-pico-api/dist/index.js":
/*!**************************************!*\
  !*** ../iota-pico-api/dist/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function __export(m) {\n  for (var p in m) {\n    if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n  }\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Combined index of all the modules.\r\n */\n\n__export(__webpack_require__(/*! ./client/apiClient */ \"../iota-pico-api/dist/client/apiClient.js\"));\n\n__export(__webpack_require__(/*! ./error/apiError */ \"../iota-pico-api/dist/error/apiError.js\"));\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-api/dist/index.js?");

/***/ }),

/***/ "../iota-pico-api/node_modules/@babel/runtime/regenerator/index.js":
/*!*************************************************************************!*\
  !*** ../iota-pico-api/node_modules/@babel/runtime/regenerator/index.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! regenerator-runtime */ \"../iota-pico-api/node_modules/regenerator-runtime/runtime-module.js\");\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-api/node_modules/@babel/runtime/regenerator/index.js?");

/***/ }),

/***/ "../iota-pico-api/node_modules/regenerator-runtime/runtime-module.js":
/*!***************************************************************************!*\
  !*** ../iota-pico-api/node_modules/regenerator-runtime/runtime-module.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\nvar g = (function() { return this })() || Function(\"return this\")();\n\n// Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\nvar hadRuntime = g.regeneratorRuntime &&\n  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;\n\n// Save the old regeneratorRuntime in case it needs to be restored later.\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\n// Force reevalutation of runtime.js.\ng.regeneratorRuntime = undefined;\n\nmodule.exports = __webpack_require__(/*! ./runtime */ \"../iota-pico-api/node_modules/regenerator-runtime/runtime.js\");\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch(e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-api/node_modules/regenerator-runtime/runtime-module.js?");

/***/ }),

/***/ "../iota-pico-api/node_modules/regenerator-runtime/runtime.js":
/*!********************************************************************!*\
  !*** ../iota-pico-api/node_modules/regenerator-runtime/runtime.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // In sloppy mode, unbound `this` refers to the global object, fallback to\n  // Function constructor if we're in global strict mode. That is sadly a form\n  // of indirect eval which violates Content Security Policy.\n  (function() { return this })() || Function(\"return this\")()\n);\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-api/node_modules/regenerator-runtime/runtime.js?");

/***/ }),

/***/ "../iota-pico-business/dist/error/businessError.js":
/*!*********************************************************!*\
  !*** ../iota-pico-business/dist/error/businessError.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar coreError_1 = __webpack_require__(/*! @iota-pico/core/dist/error/coreError */ \"../iota-pico-core/dist/error/coreError.js\");\n/**\r\n * A business implementation of an error.\r\n */\n\n\nvar BusinessError =\n/*#__PURE__*/\nfunction (_coreError_1$CoreErro) {\n  _inherits(BusinessError, _coreError_1$CoreErro);\n\n  function BusinessError() {\n    _classCallCheck(this, BusinessError);\n\n    return _possibleConstructorReturn(this, (BusinessError.__proto__ || Object.getPrototypeOf(BusinessError)).apply(this, arguments));\n  }\n\n  return BusinessError;\n}(coreError_1.CoreError);\n\nexports.BusinessError = BusinessError;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-business/dist/error/businessError.js?");

/***/ }),

/***/ "../iota-pico-business/dist/helpers/bundleHelper.js":
/*!**********************************************************!*\
  !*** ../iota-pico-business/dist/helpers/bundleHelper.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar arrayHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/arrayHelper */ \"../iota-pico-core/dist/helpers/arrayHelper.js\");\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar spongeFactory_1 = __webpack_require__(/*! @iota-pico/crypto/dist/factories/spongeFactory */ \"../iota-pico-crypto/dist/factories/spongeFactory.js\");\n\nvar address_1 = __webpack_require__(/*! @iota-pico/data/dist/data/address */ \"../iota-pico-data/dist/data/address.js\");\n\nvar bundle_1 = __webpack_require__(/*! @iota-pico/data/dist/data/bundle */ \"../iota-pico-data/dist/data/bundle.js\");\n\nvar hash_1 = __webpack_require__(/*! @iota-pico/data/dist/data/hash */ \"../iota-pico-data/dist/data/hash.js\");\n\nvar signatureMessageFragment_1 = __webpack_require__(/*! @iota-pico/data/dist/data/signatureMessageFragment */ \"../iota-pico-data/dist/data/signatureMessageFragment.js\");\n\nvar tag_1 = __webpack_require__(/*! @iota-pico/data/dist/data/tag */ \"../iota-pico-data/dist/data/tag.js\");\n\nvar transaction_1 = __webpack_require__(/*! @iota-pico/data/dist/data/transaction */ \"../iota-pico-data/dist/data/transaction.js\");\n\nvar trits_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trits */ \"../iota-pico-data/dist/data/trits.js\");\n\nvar trytes_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trytes */ \"../iota-pico-data/dist/data/trytes.js\");\n\nvar tryteNumber_1 = __webpack_require__(/*! ../../../iota-pico-data/dist/data/tryteNumber */ \"../iota-pico-data/dist/data/tryteNumber.js\");\n\nvar hmacCurl_1 = __webpack_require__(/*! ../sign/hmacCurl */ \"../iota-pico-business/dist/sign/hmacCurl.js\");\n\nvar signing_1 = __webpack_require__(/*! ../sign/signing */ \"../iota-pico-business/dist/sign/signing.js\");\n/**\r\n * Helper class for signing bundles.\r\n * Converted https://github.com/iotaledger/iota.lib.js/blob/master/lib/crypto/signing/signing.js\r\n */\n\n\nvar BundleHelper =\n/*#__PURE__*/\nfunction () {\n  function BundleHelper() {\n    _classCallCheck(this, BundleHelper);\n  }\n\n  _createClass(BundleHelper, null, [{\n    key: \"isValid\",\n\n    /**\r\n     * Is the bundle valid.\r\n     * @param bundle The bundle to check for validity.\r\n     * @returns True if the bundle is valid.\r\n     */\n    value: function isValid(bundle) {\n      var isValid = false;\n\n      if (objectHelper_1.ObjectHelper.isType(bundle, bundle_1.Bundle) && arrayHelper_1.ArrayHelper.isTyped(bundle.transactions, transaction_1.Transaction)) {\n        var totalSum = 0;\n        var kerl = spongeFactory_1.SpongeFactory.instance().create(\"kerl\");\n        kerl.initialize(); // Prepare for signature validation\n\n        var signaturesToValidate = [];\n        isValid = true;\n\n        for (var t = 0; t < bundle.transactions.length && isValid; t++) {\n          var bundleTx = bundle.transactions[t];\n          totalSum += bundleTx.value.toNumber(); // currentIndex has to be equal to the index in the array\n\n          if (bundleTx.currentIndex.toNumber() !== t) {\n            isValid = false;\n          } else {\n            // Get the transaction trytes\n            var thisTxTrytes = bundleTx.toTrytes(); // Absorb bundle hash + value + timestamp + lastIndex + currentIndex trytes.\n\n            var thisTxTrits = trits_1.Trits.fromTrytes(thisTxTrytes.sub(signatureMessageFragment_1.SignatureMessageFragment.LENGTH, 162)).toArray();\n            kerl.absorb(thisTxTrits, 0, thisTxTrits.length); // Check if input transaction\n\n            if (bundleTx.value.toNumber() < 0) {\n              var newSignatureToValidate = {\n                address: bundleTx.address,\n                signatureMessageFragments: [bundleTx.signatureMessageFragment]\n              }; // Find the subsequent txs with the remaining signature fragment\n\n              for (var i = t; i < bundle.transactions.length - 1; i++) {\n                var newBundleTx = bundle.transactions[i + 1]; // Check if new tx is part of the signature fragment\n\n                if (newBundleTx.address.toTrytes().toString() === bundleTx.address.toTrytes().toString() && newBundleTx.value.toNumber() === 0) {\n                  newSignatureToValidate.signatureMessageFragments.push(newBundleTx.signatureMessageFragment);\n                }\n              }\n\n              signaturesToValidate.push(newSignatureToValidate);\n            }\n          }\n        } // Check for total sum, if not equal 0 return error\n\n\n        if (totalSum !== 0) {\n          isValid = false;\n        } else {\n          // get the bundle hash from the bundle transactions\n          var bundleFromTxs = new Int8Array(kerl.getConstants().HASH_LENGTH);\n          kerl.squeeze(bundleFromTxs, 0, bundleFromTxs.length);\n          var bundleFromTxsTrytes = trits_1.Trits.fromArray(bundleFromTxs).toTrytes().toString(); // Check if bundle hash is the same as returned by tx object\n\n          var bundleHash = bundle.transactions[0].bundle;\n\n          if (bundleFromTxsTrytes !== bundleHash.toTrytes().toString()) {\n            isValid = false;\n          } else {\n            // Last tx in the bundle should have currentIndex === lastIndex\n            if (bundle.transactions[bundle.transactions.length - 1].currentIndex.toNumber() !== bundle.transactions[bundle.transactions.length - 1].lastIndex.toNumber()) {\n              isValid = false;\n            } else {\n              // Validate the signatures\n              for (var _i = 0; _i < signaturesToValidate.length && isValid; _i++) {\n                var isValidSignature = signing_1.Signing.validateSignatures(signaturesToValidate[_i].address, signaturesToValidate[_i].signatureMessageFragments, bundleHash);\n\n                if (!isValidSignature) {\n                  isValid = false;\n                }\n              }\n            }\n          }\n        }\n      }\n\n      return isValid;\n    }\n    /**\r\n     * Validate signatures for each of the co-signers in the multi-signature to independently verify that a generated\r\n     * transaction with the corresponding signatures of the co-signers is valid.\r\n     * @param signedBundle The signed bundle to check the signatures.\r\n     * @param inputAddress The address used to initiate the transfer.\r\n     * @returns True is the signatures are valid.\r\n     */\n\n  }, {\n    key: \"validateSignatures\",\n    value: function validateSignatures(signedBundle, inputAddress) {\n      var isValid = false;\n\n      if (objectHelper_1.ObjectHelper.isType(signedBundle, bundle_1.Bundle) && arrayHelper_1.ArrayHelper.isTyped(signedBundle.transactions, transaction_1.Transaction) && objectHelper_1.ObjectHelper.isType(inputAddress, address_1.Address)) {\n        var bundleHash;\n        var signatureFragments = [];\n        var inputAddressTrytes = inputAddress.toTrytes().toString();\n\n        for (var i = 0; i < signedBundle.transactions.length; i++) {\n          if (signedBundle.transactions[i].address.toTrytes().toString() === inputAddressTrytes) {\n            bundleHash = signedBundle.transactions[i].bundle; // if we reached remainder bundle\n\n            if (signedBundle.transactions[i].signatureMessageFragment.toTrytes().toString() === signatureMessageFragment_1.SignatureMessageFragment.EMPTY.toTrytes().toString()) {\n              break;\n            }\n\n            signatureFragments.push(signedBundle.transactions[i].signatureMessageFragment);\n          }\n        }\n\n        if (bundleHash) {\n          isValid = signing_1.Signing.validateSignatures(inputAddress, signatureFragments, bundleHash);\n        }\n      }\n\n      return isValid;\n    }\n  }, {\n    key: \"prepareBundle\",\n    value: function prepareBundle(timeService, transfers) {\n      var bundle = new bundle_1.Bundle();\n      var lastTag;\n      var totalValue = 0;\n      var signatureMessageFragments = []; //  Iterate over all transfers, get totalValue\n      //  and prepare the Messages, message and tag\n\n      for (var i = 0; i < transfers.length; i++) {\n        var signatureMessageLength = 1; // If message longer than 2187 trytes, increase signatureMessageLength (add 2nd transaction)\n\n        var messageString = transfers[i].message.toString();\n\n        if (messageString.length > signatureMessageFragment_1.SignatureMessageFragment.LENGTH) {\n          // Get total length, message / maxLength (2187 trytes)\n          signatureMessageLength += Math.floor(messageString.length / signatureMessageFragment_1.SignatureMessageFragment.LENGTH);\n          var msgCopy = messageString; // While there is still a message, copy it\n\n          while (msgCopy) {\n            var fragment = msgCopy.slice(0, signatureMessageFragment_1.SignatureMessageFragment.LENGTH);\n            msgCopy = msgCopy.slice(signatureMessageFragment_1.SignatureMessageFragment.LENGTH, msgCopy.length); // Pad remainder of fragment\n\n            for (var j = 0; fragment.length < signatureMessageFragment_1.SignatureMessageFragment.LENGTH; j++) {\n              fragment += \"9\";\n            }\n\n            signatureMessageFragments.push(signatureMessageFragment_1.SignatureMessageFragment.fromTrytes(trytes_1.Trytes.fromString(fragment)));\n          }\n        } else {\n          // Else, get single fragment with 2187 of 9's trytes\n          var _fragment = \"\";\n\n          if (messageString) {\n            _fragment = messageString.slice(0, signatureMessageFragment_1.SignatureMessageFragment.LENGTH);\n          }\n\n          for (var _j = 0; _fragment.length < signatureMessageFragment_1.SignatureMessageFragment.LENGTH; _j++) {\n            _fragment += \"9\";\n          }\n\n          signatureMessageFragments.push(signatureMessageFragment_1.SignatureMessageFragment.fromTrytes(trytes_1.Trytes.fromString(_fragment)));\n        } // get current timestamp in seconds\n\n\n        var timestamp = Math.floor(timeService.msSinceEpoch() / 1000);\n        lastTag = transfers[i].tag; // Add first entries to the bundle\n\n        bundle.addTransactions(signatureMessageLength, transfers[i].address, transfers[i].value, transfers[i].tag, timestamp); // Sum up total value\n\n        totalValue += transfers[i].value;\n      }\n\n      return {\n        bundle: bundle,\n        totalValue: totalValue,\n        lastTag: lastTag,\n        signatureMessageFragments: signatureMessageFragments\n      };\n    }\n    /* @internal */\n\n  }, {\n    key: \"signInputs\",\n    value: function signInputs(seed, bundle, transferOptions, signatureMessageFragments, inputs, addedHMAC) {\n      BundleHelper.finalizeBundle(bundle);\n      bundle.addSignatureMessageFragments(signatureMessageFragments); //  Here we do the actual signing of the inputs\n      //  Iterate over all bundle transactions, find the inputs\n      //  Get the corresponding private key and calculate the signatureMessageFragment\n\n      for (var i = 0; i < bundle.transactions.length; i++) {\n        if (bundle.transactions[i].value.toNumber() < 0) {\n          var addressTrytes = bundle.transactions[i].address.toTrytes().toString(); // Get the corresponding keyIndex and security of the address\n\n          var keyIndex = void 0;\n          var keySecurity = void 0;\n\n          for (var k = 0; k < inputs.length; k++) {\n            if (inputs[k].address.toTrytes().toString() === addressTrytes) {\n              keyIndex = inputs[k].keyIndex;\n              keySecurity = inputs[k].security ? inputs[k].security : transferOptions.security;\n              break;\n            }\n          } // Get corresponding private key of address\n\n\n          var key = signing_1.Signing.key(seed, keyIndex, keySecurity);\n          BundleHelper.signTransactions(bundle, i, 0, key, addressTrytes, keySecurity);\n        }\n      }\n\n      if (addedHMAC) {\n        var hmac = new hmacCurl_1.HmacCurl(transferOptions.hmacKey);\n        hmac.addHMAC(bundle);\n      }\n    }\n    /* @internal */\n\n  }, {\n    key: \"signTransactions\",\n    value: function signTransactions(bundle, index, firstUnsignedIndex, keyTrits, addressTrytes, security) {\n      var bundleHash = bundle.transactions[index].bundle; //  Get the normalized bundle hash\n\n      var normalizedBundleHash = BundleHelper.normalizedHash(bundleHash);\n      var normalizedBundleFragments = []; // Split hash into 3 fragments\n\n      for (var l = 0; l < 3; l++) {\n        normalizedBundleFragments[l] = normalizedBundleHash.slice(l * 27, (l + 1) * 27);\n      } //  First 6561 trits for the firstFragment\n\n\n      var firstFragment = keyTrits.slice(0, 6561); //  First bundle fragment uses the first 27 trytes\n\n      var firstBundleFragment = normalizedBundleFragments[firstUnsignedIndex]; //  Calculate the new signatureMessageFragment with the first bundle fragment\n\n      var firstSignedFragment = BundleHelper.signatureMessageFragment(firstBundleFragment, firstFragment); //  Convert signature to trytes and assign the new signatureMessageFragment\n\n      bundle.transactions[index].signatureMessageFragment = signatureMessageFragment_1.SignatureMessageFragment.fromTrytes(trits_1.Trits.fromArray(firstSignedFragment).toTrytes()); // if user chooses higher than 27-tryte security\n      // for each security level, add an additional signature\n\n      for (var j = 1; j < security; j++) {\n        //  Because the signature is > 2187 trytes, we need to\n        //  find the subsequent transaction to add the remainder of the signature\n        //  Same address as well as value = 0 (as we already spent the input)\n        if (bundle.transactions[index + j].address.toTrytes().toString() === addressTrytes && bundle.transactions[index + j].value.toNumber() === 0) {\n          // Use the next 6561 trits\n          var nextFragment = keyTrits.slice(6561 * j, (j + 1) * 6561);\n          var nextBundleFragment = normalizedBundleFragments[j]; //  Calculate the new signature\n\n          var nextSignedFragment = BundleHelper.signatureMessageFragment(nextBundleFragment, nextFragment); //  Convert signature to trytes and assign it again to this bundle entry\n\n          bundle.transactions[index + j].signatureMessageFragment = signatureMessageFragment_1.SignatureMessageFragment.fromTrytes(trits_1.Trits.fromArray(nextSignedFragment).toTrytes());\n        }\n      }\n    }\n    /* @internal */\n\n  }, {\n    key: \"finalizeBundle\",\n    value: function finalizeBundle(bundle) {\n      if (bundle.transactions.length > 0) {\n        var validBundle = false;\n\n        while (!validBundle) {\n          var kerl = spongeFactory_1.SpongeFactory.instance().create(\"kerl\");\n          kerl.initialize();\n\n          for (var i = 0; i < bundle.transactions.length; i++) {\n            bundle.transactions[i].currentIndex = tryteNumber_1.TryteNumber.fromNumber(i);\n            bundle.transactions[i].lastIndex = tryteNumber_1.TryteNumber.fromNumber(bundle.transactions.length - 1);\n            var bundleEssence = trits_1.Trits.fromTrytes(trytes_1.Trytes.fromString(bundle.transactions[i].address.toTrytes().toString() + bundle.transactions[i].value.toTrytes().toString() + transaction_1.Transaction.CHECK_VALUE + bundle.transactions[i].obsoleteTag.toTrytes().toString() + bundle.transactions[i].timestamp.toTrytes().toString() + bundle.transactions[i].currentIndex.toTrytes().toString() + bundle.transactions[i].lastIndex.toTrytes().toString())).toArray();\n            kerl.absorb(bundleEssence, 0, bundleEssence.length);\n          }\n\n          var hashTrits = new Int8Array(kerl.getConstants().HASH_LENGTH);\n          kerl.squeeze(hashTrits, 0, hashTrits.length);\n          var hash = hash_1.Hash.fromTrytes(trits_1.Trits.fromArray(hashTrits).toTrytes());\n\n          for (var _i2 = 0; _i2 < bundle.transactions.length; _i2++) {\n            bundle.transactions[_i2].bundle = hash;\n          }\n\n          var normalizedHash = this.normalizedHash(hash);\n\n          if (normalizedHash.indexOf(13\n          /* = M */\n          ) !== -1) {\n            // Insecure bundle. Increment Tag and recompute bundle hash.\n            var increasedTag = trits_1.Trits.add(trits_1.Trits.fromTrytes(bundle.transactions[0].obsoleteTag.toTrytes()), trits_1.Trits.fromNumberArray([1]));\n            bundle.transactions[0].obsoleteTag = tag_1.Tag.fromTrytes(increasedTag.toTrytes());\n          } else {\n            validBundle = true;\n          }\n        }\n      }\n    }\n    /* @internal */\n\n  }, {\n    key: \"normalizedHash\",\n    value: function normalizedHash(bundleHash) {\n      var normalizedBundle = new Int8Array(4 * 27);\n      var hashString = bundleHash.toTrytes().toString();\n\n      for (var i = 0; i < 3; i++) {\n        var sum = 0;\n\n        for (var j = 0; j < 27; j++) {\n          var hashChar = hashString.charAt(i * 27 + j);\n          var val = trits_1.Trits.fromTrytes(trytes_1.Trytes.fromString(hashChar)).toNumber();\n          normalizedBundle[i * 27 + j] = val;\n          sum += val;\n        }\n\n        if (sum >= 0) {\n          while (sum-- > 0) {\n            for (var _j2 = 0; _j2 < 27; _j2++) {\n              if (normalizedBundle[i * 27 + _j2] > -13) {\n                normalizedBundle[i * 27 + _j2]--;\n                break;\n              }\n            }\n          }\n        } else {\n          while (sum++ < 0) {\n            for (var _j3 = 0; _j3 < 27; _j3++) {\n              if (normalizedBundle[i * 27 + _j3] < 13) {\n                normalizedBundle[i * 27 + _j3]++;\n                break;\n              }\n            }\n          }\n        }\n      }\n\n      return normalizedBundle;\n    }\n    /* @internal */\n\n  }, {\n    key: \"digest\",\n    value: function digest(normalizedBundleFragment, signatureMessageFragmentTrits) {\n      var buffer;\n      var kerl = spongeFactory_1.SpongeFactory.instance().create(\"kerl\");\n      kerl.initialize();\n\n      for (var i = 0; i < 27; i++) {\n        buffer = new Int8Array(signatureMessageFragmentTrits.slice(i * 243, (i + 1) * 243));\n\n        for (var j = normalizedBundleFragment[i] + 13; j-- > 0;) {\n          var jKerl = spongeFactory_1.SpongeFactory.instance().create(\"kerl\");\n          jKerl.initialize();\n          jKerl.absorb(buffer, 0, buffer.length);\n          jKerl.squeeze(buffer, 0, jKerl.getConstants().HASH_LENGTH);\n        }\n\n        kerl.absorb(buffer, 0, buffer.length);\n      }\n\n      kerl.squeeze(buffer, 0, kerl.getConstants().HASH_LENGTH);\n      return buffer;\n    }\n    /* @internal */\n\n  }, {\n    key: \"address\",\n    value: function address(digests) {\n      var kerl = spongeFactory_1.SpongeFactory.instance().create(\"kerl\");\n      kerl.initialize();\n      kerl.absorb(digests, 0, digests.length);\n      var addressTrits = new Int8Array(kerl.getConstants().HASH_LENGTH);\n      kerl.squeeze(addressTrits, 0, addressTrits.length);\n      return addressTrits;\n    }\n    /* @internal */\n\n  }, {\n    key: \"transactionHash\",\n    value: function transactionHash(transaction) {\n      var curl = spongeFactory_1.SpongeFactory.instance().create(\"curl\");\n      var transactionTrits = trits_1.Trits.fromTrytes(transaction.toTrytes()).toArray();\n      curl.initialize();\n      curl.absorb(transactionTrits, 0, transactionTrits.length);\n      var hashTrits = new Int8Array(curl.getConstants().HASH_LENGTH);\n      curl.squeeze(hashTrits, 0, hashTrits.length);\n      return hash_1.Hash.fromTrytes(trits_1.Trits.fromArray(hashTrits).toTrytes());\n    }\n    /* @internal */\n\n  }, {\n    key: \"signatureMessageFragment\",\n    value: function signatureMessageFragment(normalizedBundleFragment, keyFragment) {\n      var signatureMessageFragment = keyFragment.slice();\n      var hash;\n      var kerl = spongeFactory_1.SpongeFactory.instance().create(\"kerl\");\n      var hashLength = kerl.getConstants().HASH_LENGTH;\n\n      for (var i = 0; i < 27; i++) {\n        hash = signatureMessageFragment.slice(i * hashLength, (i + 1) * hashLength);\n\n        for (var j = 0; j < 13 - normalizedBundleFragment[i]; j++) {\n          kerl.initialize();\n          kerl.reset();\n          kerl.absorb(hash, 0, hashLength);\n          kerl.squeeze(hash, 0, hashLength);\n        }\n\n        for (var _j4 = 0; _j4 < hashLength; _j4++) {\n          signatureMessageFragment[i * hashLength + _j4] = hash[_j4];\n        }\n      }\n\n      return signatureMessageFragment;\n    }\n  }]);\n\n  return BundleHelper;\n}();\n\nexports.BundleHelper = BundleHelper;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-business/dist/helpers/bundleHelper.js?");

/***/ }),

/***/ "../iota-pico-business/dist/index.js":
/*!*******************************************!*\
  !*** ../iota-pico-business/dist/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function __export(m) {\n  for (var p in m) {\n    if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n  }\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Combined index of all the modules.\r\n */\n\n__export(__webpack_require__(/*! ./error/businessError */ \"../iota-pico-business/dist/error/businessError.js\"));\n\n__export(__webpack_require__(/*! ./helpers/bundleHelper */ \"../iota-pico-business/dist/helpers/bundleHelper.js\"));\n\n__export(__webpack_require__(/*! ./multiSig/multiSigAddress */ \"../iota-pico-business/dist/multiSig/multiSigAddress.js\"));\n\n__export(__webpack_require__(/*! ./multiSig/multiSigClient */ \"../iota-pico-business/dist/multiSig/multiSigClient.js\"));\n\n__export(__webpack_require__(/*! ./sign/signing */ \"../iota-pico-business/dist/sign/signing.js\"));\n\n__export(__webpack_require__(/*! ./sign/hmacCurl */ \"../iota-pico-business/dist/sign/hmacCurl.js\"));\n\n__export(__webpack_require__(/*! ./transactions/transactionClient */ \"../iota-pico-business/dist/transactions/transactionClient.js\"));\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-business/dist/index.js?");

/***/ }),

/***/ "../iota-pico-business/dist/multiSig/multiSigAddress.js":
/*!**************************************************************!*\
  !*** ../iota-pico-business/dist/multiSig/multiSigAddress.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar arrayHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/arrayHelper */ \"../iota-pico-core/dist/helpers/arrayHelper.js\");\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar spongeFactory_1 = __webpack_require__(/*! @iota-pico/crypto/dist/factories/spongeFactory */ \"../iota-pico-crypto/dist/factories/spongeFactory.js\");\n\nvar address_1 = __webpack_require__(/*! @iota-pico/data/dist/data/address */ \"../iota-pico-data/dist/data/address.js\");\n\nvar trits_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trits */ \"../iota-pico-data/dist/data/trits.js\");\n\nvar trytes_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trytes */ \"../iota-pico-data/dist/data/trytes.js\");\n\nvar businessError_1 = __webpack_require__(/*! ../error/businessError */ \"../iota-pico-business/dist/error/businessError.js\");\n/**\r\n * Address using multiple signatures.\r\n */\n\n\nvar MultiSigAddress =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * Create a new instance of the MultiSigAddress.\r\n   */\n  function MultiSigAddress() {\n    _classCallCheck(this, MultiSigAddress);\n\n    this._kerl = spongeFactory_1.SpongeFactory.instance().create(\"kerl\");\n    this._hashLength = this._kerl.getConstants().HASH_LENGTH;\n\n    this._kerl.initialize();\n  }\n  /**\r\n   * Absorb key digests.\r\n   * @param digests The digests hashes to absorb.\r\n   */\n\n\n  _createClass(MultiSigAddress, [{\n    key: \"absorb\",\n    value: function absorb(digests) {\n      if (!arrayHelper_1.ArrayHelper.isTyped(digests, trytes_1.Trytes)) {\n        throw new businessError_1.BusinessError(\"The digests should be an array of type Trytes\");\n      }\n\n      for (var i = 0; i < digests.length; i++) {\n        var digestTrits = trits_1.Trits.fromTrytes(digests[i]).toArray();\n\n        this._kerl.absorb(digestTrits, 0, digestTrits.length);\n      }\n    }\n    /**\r\n     * Finalizes and returns the multisig address in trytes.\r\n     * @param digests The final digests hashes to absorb.\r\n     * @returns The multi signature address.\r\n     */\n\n  }, {\n    key: \"finalize\",\n    value: function finalize(digests) {\n      if (!objectHelper_1.ObjectHelper.isEmpty(digests)) {\n        this.absorb(digests);\n      }\n\n      var addressTrits = new Int8Array(this._hashLength);\n\n      this._kerl.squeeze(addressTrits, 0, addressTrits.length);\n\n      return address_1.Address.fromTrytes(trits_1.Trits.fromArray(addressTrits).toTrytes());\n    }\n  }]);\n\n  return MultiSigAddress;\n}();\n\nexports.MultiSigAddress = MultiSigAddress;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-business/dist/multiSig/multiSigAddress.js?");

/***/ }),

/***/ "../iota-pico-business/dist/multiSig/multiSigClient.js":
/*!*************************************************************!*\
  !*** ../iota-pico-business/dist/multiSig/multiSigClient.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ \"../iota-pico-business/node_modules/@babel/runtime/regenerator/index.js\");\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _next(value) { step(\"next\", value); } function _throw(err) { step(\"throw\", err); } _next(); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar arrayHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/arrayHelper */ \"../iota-pico-core/dist/helpers/arrayHelper.js\");\n\nvar numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ \"../iota-pico-core/dist/helpers/numberHelper.js\");\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar timeService_1 = __webpack_require__(/*! @iota-pico/core/dist/services/timeService */ \"../iota-pico-core/dist/services/timeService.js\");\n\nvar address_1 = __webpack_require__(/*! @iota-pico/data/dist/data/address */ \"../iota-pico-data/dist/data/address.js\");\n\nvar bundle_1 = __webpack_require__(/*! @iota-pico/data/dist/data/bundle */ \"../iota-pico-data/dist/data/bundle.js\");\n\nvar hash_1 = __webpack_require__(/*! @iota-pico/data/dist/data/hash */ \"../iota-pico-data/dist/data/hash.js\");\n\nvar signatureMessageFragment_1 = __webpack_require__(/*! @iota-pico/data/dist/data/signatureMessageFragment */ \"../iota-pico-data/dist/data/signatureMessageFragment.js\");\n\nvar tag_1 = __webpack_require__(/*! @iota-pico/data/dist/data/tag */ \"../iota-pico-data/dist/data/tag.js\");\n\nvar transaction_1 = __webpack_require__(/*! @iota-pico/data/dist/data/transaction */ \"../iota-pico-data/dist/data/transaction.js\");\n\nvar transfer_1 = __webpack_require__(/*! @iota-pico/data/dist/data/transfer */ \"../iota-pico-data/dist/data/transfer.js\");\n\nvar trits_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trits */ \"../iota-pico-data/dist/data/trits.js\");\n\nvar trytes_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trytes */ \"../iota-pico-data/dist/data/trytes.js\");\n\nvar businessError_1 = __webpack_require__(/*! ../error/businessError */ \"../iota-pico-business/dist/error/businessError.js\");\n\nvar bundleHelper_1 = __webpack_require__(/*! ../helpers/bundleHelper */ \"../iota-pico-business/dist/helpers/bundleHelper.js\");\n\nvar signing_1 = __webpack_require__(/*! ../sign/signing */ \"../iota-pico-business/dist/sign/signing.js\");\n\nvar multiSigAddress_1 = __webpack_require__(/*! ./multiSigAddress */ \"../iota-pico-business/dist/multiSig/multiSigAddress.js\");\n/**\r\n * Multiple signatures.\r\n * Converted https://github.com/iotaledger/iota.lib.js/blob/master/lib/multisig/multisig.js\r\n */\n\n\nvar MultiSigClient =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * Create a new instance of the MultiSigClient.\r\n   * @param apiClient An API Client to communicate through.\r\n   * @param timeService A class which can provide the time.\r\n   */\n  function MultiSigClient(apiClient) {\n    var timeService = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new timeService_1.TimeService();\n\n    _classCallCheck(this, MultiSigClient);\n\n    this._apiClient = apiClient;\n    this._timeService = timeService;\n  }\n  /**\r\n   * Get the key value of a seed.\r\n   * @param seed The seed to get the key for.\r\n   * @param index The address index to use.\r\n   * @param security The security level to use.\r\n   * @returns The trytes for the key.\r\n   */\n\n\n  _createClass(MultiSigClient, [{\n    key: \"prepareTransfer\",\n\n    /**\r\n     * Initiates the creation of a new transfer by generating an empty bundle with the correct number\r\n     * of bundle entries to be later used for the signing process.\r\n     * @param address Address which has sufficient balance and is controlled by the co-signers.\r\n     * @param securitySum the sum of the security levels from all cosigners chosen during the private key generation (getKey / getDigest)\r\n     * @param balance The balance available for the transfer, if 0 will call getBalances to lookup available.\r\n     * @param transfers The transfers to perform.\r\n     * @param remainderAddress If there is a remainder after the transfer then send the amount to this address.\r\n     */\n    value: function () {\n      var _prepareTransfer = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(address, securitySum, balance, transfers, remainderAddress) {\n        var emptyTrytes, prepared, totalBalance, request, response, timestamp;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (objectHelper_1.ObjectHelper.isType(address, address_1.Address)) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The address should be an object of type Address\");\n\n              case 2:\n                if (!(!numberHelper_1.NumberHelper.isInteger(securitySum) || securitySum < 0)) {\n                  _context.next = 4;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The securitySum should be a number >= 0\");\n\n              case 4:\n                if (!(!numberHelper_1.NumberHelper.isInteger(balance) || balance < 0)) {\n                  _context.next = 6;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The balance should be a number >= 0\");\n\n              case 6:\n                if (arrayHelper_1.ArrayHelper.isTyped(transfers, transfer_1.Transfer)) {\n                  _context.next = 8;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The transfers should be an array of type Transfer\");\n\n              case 8:\n                if (!(!objectHelper_1.ObjectHelper.isEmpty(remainderAddress) && !objectHelper_1.ObjectHelper.isType(remainderAddress, address_1.Address))) {\n                  _context.next = 10;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The remainderAddress should be an object of type Address\");\n\n              case 10:\n                emptyTrytes = trytes_1.Trytes.fromString(\"\"); // If message or tag is not supplied, provide it\n\n                transfers.forEach(function (transfer) {\n                  transfer.message = transfer.message ? transfer.message : emptyTrytes;\n                  transfer.tag = transfer.tag || tag_1.Tag.EMPTY;\n                });\n                prepared = bundleHelper_1.BundleHelper.prepareBundle(this._timeService, transfers);\n\n                if (!(prepared.totalValue === 0)) {\n                  _context.next = 17;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The total transfer value is 0, the transfer does not require a signature\");\n\n              case 17:\n                totalBalance = balance;\n\n                if (!(totalBalance === 0)) {\n                  _context.next = 24;\n                  break;\n                }\n\n                request = {\n                  addresses: [address.toTrytes().toString()],\n                  threshold: 100\n                };\n                _context.next = 22;\n                return this._apiClient.getBalances(request);\n\n              case 22:\n                response = _context.sent;\n                totalBalance = parseInt(response.balances[0], 10);\n\n              case 24:\n                if (!(prepared.totalValue > totalBalance)) {\n                  _context.next = 26;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"Not enough balance to satisfy the value\", {\n                  totalValue: prepared.totalValue,\n                  totalBalance: totalBalance\n                });\n\n              case 26:\n                timestamp = Math.floor(this._timeService.msSinceEpoch() / 1000); // Add input as bundle entry\n                // Only a single entry, signatures will be added later\n\n                prepared.bundle.addTransactions(securitySum, address, -totalBalance, prepared.lastTag, timestamp); // If there is a remainder value\n                // Add extra output to send remaining funds to\n\n                if (!(totalBalance > prepared.totalValue)) {\n                  _context.next = 32;\n                  break;\n                }\n\n                if (!objectHelper_1.ObjectHelper.isEmpty(remainderAddress)) {\n                  _context.next = 31;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"Transfer has remainder but no remainder address was provided\");\n\n              case 31:\n                prepared.bundle.addTransactions(1, remainderAddress, totalBalance - prepared.totalValue, prepared.lastTag, timestamp);\n\n              case 32:\n                bundleHelper_1.BundleHelper.finalizeBundle(prepared.bundle);\n                prepared.bundle.addSignatureMessageFragments(prepared.signatureMessageFragments);\n\n              case 34:\n                return _context.abrupt(\"return\", prepared.bundle);\n\n              case 35:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      return function prepareTransfer(_x, _x2, _x3, _x4, _x5) {\n        return _prepareTransfer.apply(this, arguments);\n      };\n    }()\n  }], [{\n    key: \"getKey\",\n    value: function getKey(seed, index, security) {\n      if (!objectHelper_1.ObjectHelper.isType(seed, hash_1.Hash)) {\n        throw new businessError_1.BusinessError(\"The seed should be an object of type Hash\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(index) || index < 0) {\n        throw new businessError_1.BusinessError(\"The index should be a number >= 0\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(security) || security < 1 || security > 3) {\n        throw new businessError_1.BusinessError(\"The security must be between 1 and 3\", {\n          security: security\n        });\n      }\n\n      return trits_1.Trits.fromArray(signing_1.Signing.key(seed, index, security)).toTrytes();\n    }\n    /**\r\n     * Get the digest value of a seed.\r\n     * @param seed The seed to get the digest for.\r\n     * @param index The address index to use.\r\n     * @param security The security level to use.\r\n     * @returns The trytes for the digest.\r\n     */\n\n  }, {\n    key: \"getDigest\",\n    value: function getDigest(seed, index, security) {\n      if (!objectHelper_1.ObjectHelper.isType(seed, hash_1.Hash)) {\n        throw new businessError_1.BusinessError(\"The seed should be an object of type Hash\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(index) || index < 0) {\n        throw new businessError_1.BusinessError(\"The index should be a number >= 0\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(security) || security < 1 || security > 3) {\n        throw new businessError_1.BusinessError(\"The security must be between 1 and 3\", {\n          security: security\n        });\n      }\n\n      var key = signing_1.Signing.key(seed, index, security);\n      return trits_1.Trits.fromArray(signing_1.Signing.digests(key)).toTrytes();\n    }\n    /**\r\n     * Validate address.\r\n     * @param address The address to validate against the digests.\r\n     * @param digests The digests to use to validate the address.\r\n     * @returns True if the address matches the digests.\r\n     */\n\n  }, {\n    key: \"validateAddress\",\n    value: function validateAddress(address, digests) {\n      if (!objectHelper_1.ObjectHelper.isType(address, address_1.Address)) {\n        throw new businessError_1.BusinessError(\"The address should be an object of type Address\");\n      }\n\n      if (!arrayHelper_1.ArrayHelper.isTyped(digests, trytes_1.Trytes)) {\n        throw new businessError_1.BusinessError(\"The digests should be an array of type Trytes\");\n      }\n\n      return address.toTrytes().toString() === new multiSigAddress_1.MultiSigAddress().finalize(digests).toTrytes().toString();\n    }\n    /**\r\n     * Adds the cosigner signatures to the corresponding bundle transactions.\r\n     * @param bundle The bundle to sign.\r\n     * @param address The address to match the transactions.\r\n     * @param key The key to sign the transactions with.\r\n     */\n\n  }, {\n    key: \"addSignature\",\n    value: function addSignature(bundle, address, key) {\n      if (!objectHelper_1.ObjectHelper.isType(bundle, bundle_1.Bundle)) {\n        throw new businessError_1.BusinessError(\"The bundle should be an object of type Bundle\");\n      }\n\n      if (!arrayHelper_1.ArrayHelper.isTyped(bundle.transactions, transaction_1.Transaction)) {\n        throw new businessError_1.BusinessError(\"The bundle.transactions should be an array of type Transaction\");\n      }\n\n      if (!objectHelper_1.ObjectHelper.isType(address, address_1.Address)) {\n        throw new businessError_1.BusinessError(\"The address should be an object of type Address\");\n      }\n\n      if (!objectHelper_1.ObjectHelper.isType(key, trytes_1.Trytes)) {\n        throw new businessError_1.BusinessError(\"The key should be an object of type Trytes\");\n      }\n\n      var keyTrits = trits_1.Trits.fromTrytes(key).toArray(); // Get the security used for the private key\n      // 1 security level = 2187 trytes\n\n      var security = keyTrits.length / 3 / 2187; // First get the total number of already signed transactions\n      // use that for the bundle hash calculation as well as knowing\n      // where to add the signature\n\n      var numSignedTxs = 0;\n      var addressTrytes = address.toTrytes().toString();\n\n      for (var i = 0; i < bundle.transactions.length; i++) {\n        if (bundle.transactions[i].address.toTrytes().toString() === addressTrytes) {\n          if (bundle.transactions[i].signatureMessageFragment.toTrytes().toString() !== signatureMessageFragment_1.SignatureMessageFragment.EMPTY.toTrytes().toString()) {\n            // If transaction is already signed, increase counter\n            numSignedTxs++;\n          } else {\n            bundleHelper_1.BundleHelper.signTransactions(bundle, i, numSignedTxs % 3, keyTrits, addressTrytes, security);\n            break;\n          }\n        }\n      }\n    }\n  }]);\n\n  return MultiSigClient;\n}();\n\nexports.MultiSigClient = MultiSigClient;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-business/dist/multiSig/multiSigClient.js?");

/***/ }),

/***/ "../iota-pico-business/dist/sign/hmacCurl.js":
/*!***************************************************!*\
  !*** ../iota-pico-business/dist/sign/hmacCurl.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar spongeFactory_1 = __webpack_require__(/*! @iota-pico/crypto/dist/factories/spongeFactory */ \"../iota-pico-crypto/dist/factories/spongeFactory.js\");\n\nvar signatureMessageFragment_1 = __webpack_require__(/*! @iota-pico/data/dist/data/signatureMessageFragment */ \"../iota-pico-data/dist/data/signatureMessageFragment.js\");\n\nvar trits_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trits */ \"../iota-pico-data/dist/data/trits.js\");\n\nvar trytes_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trytes */ \"../iota-pico-data/dist/data/trytes.js\");\n/**\r\n * Hashed Message Authentication Code using Curl.\r\n */\n\n\nvar HmacCurl =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * Create a new instance of the HmacCurl.\r\n   * @param key The key to seed with.\r\n   */\n  function HmacCurl(key) {\n    _classCallCheck(this, HmacCurl);\n\n    this._keyTrits = trits_1.Trits.fromTrytes(key).toArray();\n  }\n  /**\r\n   * Add bundle to the HMAC.\r\n   */\n\n\n  _createClass(HmacCurl, [{\n    key: \"addHMAC\",\n    value: function addHMAC(bundle) {\n      var curl = spongeFactory_1.SpongeFactory.instance().create(\"curl\", HmacCurl.HMAC_ROUNDS);\n      var hashLength = curl.getConstants().HASH_LENGTH;\n      var key = this._keyTrits;\n\n      for (var i = 0; i < bundle.transactions.length; i++) {\n        if (bundle.transactions[i].value.toNumber() > 0) {\n          var bundleHashTrits = trits_1.Trits.fromTrytes(bundle.transactions[i].bundle.toTrytes()).toArray();\n          var hmac = new Int8Array(hashLength);\n          curl.initialize();\n          curl.absorb(key, 0, key.length);\n          curl.absorb(bundleHashTrits, 0, bundleHashTrits.length);\n          curl.squeeze(hmac, 0, hmac.length);\n          var hmacTrytes = trits_1.Trits.fromArray(hmac).toTrytes().toString();\n          var rest = bundle.transactions[i].signatureMessageFragment.toTrytes().toString().substring(81, signatureMessageFragment_1.SignatureMessageFragment.LENGTH);\n          bundle.transactions[i].signatureMessageFragment = signatureMessageFragment_1.SignatureMessageFragment.fromTrytes(trytes_1.Trytes.fromString(hmacTrytes + rest));\n        }\n      }\n    }\n  }]);\n\n  return HmacCurl;\n}();\n/* @internal */\n\n\nHmacCurl.HMAC_ROUNDS = 27;\nexports.HmacCurl = HmacCurl;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-business/dist/sign/hmacCurl.js?");

/***/ }),

/***/ "../iota-pico-business/dist/sign/signing.js":
/*!**************************************************!*\
  !*** ../iota-pico-business/dist/sign/signing.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar spongeFactory_1 = __webpack_require__(/*! @iota-pico/crypto/dist/factories/spongeFactory */ \"../iota-pico-crypto/dist/factories/spongeFactory.js\");\n\nvar trits_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trits */ \"../iota-pico-data/dist/data/trits.js\");\n\nvar bundleHelper_1 = __webpack_require__(/*! ../helpers/bundleHelper */ \"../iota-pico-business/dist/helpers/bundleHelper.js\");\n/**\r\n * Helper class for signing transactions.\r\n * Original https://github.com/iotaledger/iota.lib.js/blob/master/lib/crypto/signing/signing.js\r\n * @internal\r\n */\n\n\nvar Signing =\n/*#__PURE__*/\nfunction () {\n  function Signing() {\n    _classCallCheck(this, Signing);\n  }\n\n  _createClass(Signing, null, [{\n    key: \"key\",\n\n    /* @internal */\n    value: function key(seed, index, length) {\n      var seedTrits = trits_1.Trits.fromTrytes(seed.toTrytes());\n      var indexTrits = trits_1.Trits.fromNumber(index);\n      var subseed = trits_1.Trits.add(seedTrits, indexTrits).toArray();\n      var subseedLength = subseed.length;\n      var kerl = spongeFactory_1.SpongeFactory.instance().create(\"kerl\");\n      kerl.initialize();\n      kerl.absorb(subseed, 0, subseedLength);\n      kerl.squeeze(subseed, 0, subseedLength);\n      kerl.reset();\n      kerl.absorb(subseed, 0, subseedLength);\n      var key = new Int8Array(27 * 243 * length);\n      var offset = 0;\n      var buffer = new Int8Array(subseedLength);\n      var localLength = length;\n\n      while (localLength-- > 0) {\n        for (var i = 0; i < 27; i++) {\n          kerl.squeeze(buffer, 0, subseedLength);\n\n          for (var j = 0; j < 243; j++) {\n            key[offset++] = buffer[j];\n          }\n        }\n      }\n\n      return key;\n    }\n    /* @internal */\n\n  }, {\n    key: \"digests\",\n    value: function digests(key) {\n      var keyLenDiv = Math.floor(key.length / 6561);\n      var digests = new Int8Array(keyLenDiv * 243);\n      var buffer;\n\n      for (var i = 0; i < keyLenDiv; i++) {\n        var iMul = i * 6561;\n        var keyFragment = key.slice(iMul, iMul + 6561);\n\n        for (var j = 0; j < 27; j++) {\n          var jMul = j * 243;\n          buffer = keyFragment.slice(jMul, jMul + 243);\n\n          for (var k = 0; k < 26; k++) {\n            var kKerl = spongeFactory_1.SpongeFactory.instance().create(\"kerl\");\n            kKerl.initialize();\n            kKerl.absorb(buffer, 0, buffer.length);\n            kKerl.squeeze(buffer, 0, kKerl.getConstants().HASH_LENGTH);\n          }\n\n          for (var _k = 0; _k < 243; _k++) {\n            keyFragment[jMul + _k] = buffer[_k];\n          }\n        }\n\n        var kerl = spongeFactory_1.SpongeFactory.instance().create(\"kerl\");\n        kerl.initialize();\n        kerl.absorb(keyFragment, 0, keyFragment.length);\n        kerl.squeeze(buffer, 0, kerl.getConstants().HASH_LENGTH);\n        var iMul2 = i * 243;\n\n        for (var _j = 0; _j < 243; _j++) {\n          digests[iMul2 + _j] = buffer[_j];\n        }\n      }\n\n      return digests;\n    }\n    /* @internal */\n\n  }, {\n    key: \"address\",\n    value: function address(digests) {\n      var kerl = spongeFactory_1.SpongeFactory.instance().create(\"kerl\");\n      kerl.initialize();\n      kerl.absorb(digests, 0, digests.length);\n      var addressTrits = new Int8Array(kerl.getConstants().HASH_LENGTH);\n      kerl.squeeze(addressTrits, 0, addressTrits.length);\n      return addressTrits;\n    }\n    /* @internal */\n\n  }, {\n    key: \"createChecksum\",\n    value: function createChecksum(trits, checksumLength) {\n      var kerl = spongeFactory_1.SpongeFactory.instance().create(\"kerl\");\n      kerl.initialize();\n      kerl.absorb(trits, 0, trits.length);\n      var checksumTrits = new Int8Array(kerl.getConstants().HASH_LENGTH);\n      kerl.squeeze(checksumTrits, 0, checksumTrits.length);\n      return trits_1.Trits.fromArray(checksumTrits).toTrytes().toString().substring(81 - checksumLength, 81);\n    }\n    /* @internal */\n\n  }, {\n    key: \"validateSignatures\",\n    value: function validateSignatures(expectedAddress, signatureMessageFragments, bundleHash) {\n      var normalizedBundleFragments = [];\n      var normalizedBundleHash = bundleHelper_1.BundleHelper.normalizedHash(bundleHash); // Split hash into 3 fragments\n\n      for (var f = 0; f < 3; f++) {\n        normalizedBundleFragments[f] = normalizedBundleHash.slice(f * 27, (f + 1) * 27);\n      } // Get digests\n\n\n      var digests = new Int8Array(signatureMessageFragments.length * 243);\n\n      for (var i = 0; i < signatureMessageFragments.length; i++) {\n        var digestBuffer = bundleHelper_1.BundleHelper.digest(normalizedBundleFragments[i % 3], trits_1.Trits.fromTrytes(signatureMessageFragments[i].toTrytes()).toArray());\n\n        for (var j = 0; j < 243; j++) {\n          digests[i * 243 + j] = digestBuffer[j];\n        }\n      }\n\n      return expectedAddress.toTrytes().toString() === trits_1.Trits.fromArray(bundleHelper_1.BundleHelper.address(digests)).toTrytes().toString();\n    }\n  }]);\n\n  return Signing;\n}();\n\nexports.Signing = Signing;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-business/dist/sign/signing.js?");

/***/ }),

/***/ "../iota-pico-business/dist/transactions/transactionClient.js":
/*!********************************************************************!*\
  !*** ../iota-pico-business/dist/transactions/transactionClient.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ \"../iota-pico-business/node_modules/@babel/runtime/regenerator/index.js\");\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _next(value) { step(\"next\", value); } function _throw(err) { step(\"throw\", err); } _next(); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar arrayHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/arrayHelper */ \"../iota-pico-core/dist/helpers/arrayHelper.js\");\n\nvar numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ \"../iota-pico-core/dist/helpers/numberHelper.js\");\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar nullLogger_1 = __webpack_require__(/*! @iota-pico/core/dist/loggers/nullLogger */ \"../iota-pico-core/dist/loggers/nullLogger.js\");\n\nvar backgroundTaskService_1 = __webpack_require__(/*! @iota-pico/core/dist/services/backgroundTaskService */ \"../iota-pico-core/dist/services/backgroundTaskService.js\");\n\nvar timeService_1 = __webpack_require__(/*! @iota-pico/core/dist/services/timeService */ \"../iota-pico-core/dist/services/timeService.js\");\n\nvar address_1 = __webpack_require__(/*! @iota-pico/data/dist/data/address */ \"../iota-pico-data/dist/data/address.js\");\n\nvar addressSecurity_1 = __webpack_require__(/*! @iota-pico/data/dist/data/addressSecurity */ \"../iota-pico-data/dist/data/addressSecurity.js\");\n\nvar bundle_1 = __webpack_require__(/*! @iota-pico/data/dist/data/bundle */ \"../iota-pico-data/dist/data/bundle.js\");\n\nvar hash_1 = __webpack_require__(/*! @iota-pico/data/dist/data/hash */ \"../iota-pico-data/dist/data/hash.js\");\n\nvar input_1 = __webpack_require__(/*! @iota-pico/data/dist/data/input */ \"../iota-pico-data/dist/data/input.js\");\n\nvar tag_1 = __webpack_require__(/*! @iota-pico/data/dist/data/tag */ \"../iota-pico-data/dist/data/tag.js\");\n\nvar transaction_1 = __webpack_require__(/*! @iota-pico/data/dist/data/transaction */ \"../iota-pico-data/dist/data/transaction.js\");\n\nvar transfer_1 = __webpack_require__(/*! @iota-pico/data/dist/data/transfer */ \"../iota-pico-data/dist/data/transfer.js\");\n\nvar trits_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trits */ \"../iota-pico-data/dist/data/trits.js\");\n\nvar tryteNumber_1 = __webpack_require__(/*! @iota-pico/data/dist/data/tryteNumber */ \"../iota-pico-data/dist/data/tryteNumber.js\");\n\nvar trytes_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trytes */ \"../iota-pico-data/dist/data/trytes.js\");\n\nvar businessError_1 = __webpack_require__(/*! ../error/businessError */ \"../iota-pico-business/dist/error/businessError.js\");\n\nvar bundleHelper_1 = __webpack_require__(/*! ../helpers/bundleHelper */ \"../iota-pico-business/dist/helpers/bundleHelper.js\");\n\nvar signing_1 = __webpack_require__(/*! ../sign/signing */ \"../iota-pico-business/dist/sign/signing.js\");\n/**\r\n * Default implementation of the ITransactionClient.\r\n */\n\n\nvar TransactionClient =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * Create a new instance of the TransactionClient.\r\n   * @param apiClient An API Client to communicate through.\r\n   * @param proofOfWork Proof of work module to use, if undefined will use remote.\r\n   * @param timeService A class which can provide the time.\r\n   * @param backgroundTaskService A class which can provide background tasks.\r\n   * @param logger Logger to send transaction info to.\r\n   */\n  function TransactionClient(apiClient, proofOfWork, timeService, backgroundTaskService, logger) {\n    _classCallCheck(this, TransactionClient);\n\n    this._apiClient = apiClient;\n    this._proofOfWork = proofOfWork;\n    this._timeService = timeService || new timeService_1.TimeService();\n    this._backgroundTaskService = backgroundTaskService || new backgroundTaskService_1.BackgroundTaskService();\n    this._logger = logger || new nullLogger_1.NullLogger();\n  }\n  /**\r\n   * Returns the list of transaction in progress.\r\n   * @returns Promise which resolves to a list of hashes or rejects with error.\r\n   */\n\n\n  _createClass(TransactionClient, [{\n    key: \"getTransactionsInProgress\",\n    value: function () {\n      var _getTransactionsInProgress = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        var response, resp;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this._logger.info(\"===> getTransactionsInProgress\");\n\n                _context.next = 3;\n                return this._apiClient.getTips();\n\n              case 3:\n                response = _context.sent;\n\n                if (!(response && response.hashes)) {\n                  _context.next = 10;\n                  break;\n                }\n\n                resp = response.hashes.map(function (hash) {\n                  return hash_1.Hash.fromTrytes(trytes_1.Trytes.fromString(hash));\n                });\n\n                this._logger.info(\"<=== \", resp);\n\n                return _context.abrupt(\"return\", resp);\n\n              case 10:\n                this._logger.info(\"<=== []\");\n\n                return _context.abrupt(\"return\", []);\n\n              case 12:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      return function getTransactionsInProgress() {\n        return _getTransactionsInProgress.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Find the transactions which match the specified input and return. All input values are lists,\r\n     * for which a list of return values (transaction hashes), in the same order, is returned for all\r\n     * individual elements. Using multiple of these input fields returns the intersection of the values.\r\n     * @param bundles Bundles to lookup transaction hashes for.\r\n     * @param addresses Addresses to lookup transaction hashes for.\r\n     * @param tags Tags to lookup transaction hashes for.\r\n     * @param approvees Approvees to lookup transaction hashes for.\r\n     * @returns Promise which resolves with a list of hashes or rejects with error.\r\n     */\n\n  }, {\n    key: \"findTransactions\",\n    value: function () {\n      var _findTransactions = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(bundles, addresses, tags, approvees) {\n        var hasBundle, hasAddresses, hasTags, hasApprovees, request, response, resp;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                this._logger.info(\"===> findTransactions\", bundles, addresses, tags, approvees);\n\n                hasBundle = bundles !== undefined && bundles !== null && bundles.length > 0;\n                hasAddresses = addresses !== undefined && addresses !== null && addresses.length > 0;\n                hasTags = tags !== undefined && tags !== null && tags.length > 0;\n                hasApprovees = approvees !== undefined && approvees !== null && approvees.length > 0;\n\n                if (!(hasBundle && !arrayHelper_1.ArrayHelper.isTyped(bundles, hash_1.Hash))) {\n                  _context2.next = 7;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The bundles must be an array of type Hash\");\n\n              case 7:\n                if (!(hasAddresses && !arrayHelper_1.ArrayHelper.isTyped(addresses, address_1.Address))) {\n                  _context2.next = 9;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The addresses must be an array of type Address\");\n\n              case 9:\n                if (!(hasTags && !arrayHelper_1.ArrayHelper.isTyped(tags, tag_1.Tag))) {\n                  _context2.next = 11;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The tags must be an array of type Tag\");\n\n              case 11:\n                if (!(hasApprovees && !arrayHelper_1.ArrayHelper.isTyped(approvees, hash_1.Hash))) {\n                  _context2.next = 13;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The approvees must be an array of type Hash\");\n\n              case 13:\n                if (!(!hasBundle && !hasAddresses && !hasTags && !hasApprovees)) {\n                  _context2.next = 15;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"You must provide bundles, addresses, tags or approvees\");\n\n              case 15:\n                request = {\n                  bundles: hasBundle ? bundles.map(function (bundle) {\n                    return bundle.toTrytes().toString();\n                  }) : undefined,\n                  addresses: hasAddresses ? addresses.map(function (address) {\n                    return address.toTrytes().toString();\n                  }) : undefined,\n                  tags: hasTags ? tags.map(function (tag) {\n                    return tag.toTrytes().toString();\n                  }) : undefined,\n                  approvees: hasApprovees ? approvees.map(function (approvee) {\n                    return approvee.toTrytes().toString();\n                  }) : undefined\n                };\n                _context2.next = 18;\n                return this._apiClient.findTransactions(request);\n\n              case 18:\n                response = _context2.sent;\n\n                if (!(response && response.hashes)) {\n                  _context2.next = 25;\n                  break;\n                }\n\n                resp = response.hashes.map(function (hash) {\n                  return hash_1.Hash.fromTrytes(trytes_1.Trytes.fromString(hash));\n                });\n\n                this._logger.info(\"<=== \", resp);\n\n                return _context2.abrupt(\"return\", resp);\n\n              case 25:\n                this._logger.info(\"<=== []\");\n\n                return _context2.abrupt(\"return\", []);\n\n              case 27:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      return function findTransactions(_x, _x2, _x3, _x4) {\n        return _findTransactions.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Get the transaction details of specific transactions.\r\n     * @returns Promise which resolves to the list of transactions or rejects with error.\r\n     */\n\n  }, {\n    key: \"getTransactionsObjects\",\n    value: function () {\n      var _getTransactionsObjects = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3(transactionHashes) {\n        var request, response, resp;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                this._logger.info(\"===> getTransactionsObjects\", transactionHashes);\n\n                if (arrayHelper_1.ArrayHelper.isTyped(transactionHashes, hash_1.Hash)) {\n                  _context3.next = 3;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The transactionHashes must be an array of type Hash\");\n\n              case 3:\n                request = {\n                  hashes: transactionHashes.map(function (hash) {\n                    return hash.toTrytes().toString();\n                  })\n                };\n                _context3.next = 6;\n                return this._apiClient.getTrytes(request);\n\n              case 6:\n                response = _context3.sent;\n\n                if (!(response && response.trytes)) {\n                  _context3.next = 13;\n                  break;\n                }\n\n                resp = response.trytes.map(function (trytes) {\n                  return transaction_1.Transaction.fromTrytes(trytes_1.Trytes.fromString(trytes));\n                });\n\n                this._logger.info(\"<=== \", resp);\n\n                return _context3.abrupt(\"return\", resp);\n\n              case 13:\n                this._logger.info(\"<=== []\");\n\n                return _context3.abrupt(\"return\", []);\n\n              case 15:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      return function getTransactionsObjects(_x5) {\n        return _getTransactionsObjects.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Get the inclusion states of a list of transaction hashes.\r\n     * @returns Promise which resolves to the list of inclusion states or rejects with error.\r\n     */\n\n  }, {\n    key: \"getLatestInclusion\",\n    value: function () {\n      var _getLatestInclusion = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee4(transactionHashes) {\n        var nodeInfo, request, response;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                this._logger.info(\"===> transactionHashes\");\n\n                if (arrayHelper_1.ArrayHelper.isTyped(transactionHashes, hash_1.Hash)) {\n                  _context4.next = 3;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The transactionHashes must be an array of type Hash\");\n\n              case 3:\n                _context4.next = 5;\n                return this._apiClient.getNodeInfo();\n\n              case 5:\n                nodeInfo = _context4.sent;\n\n                if (!(nodeInfo && numberHelper_1.NumberHelper.isInteger(nodeInfo.latestSolidSubtangleMilestone))) {\n                  _context4.next = 20;\n                  break;\n                }\n\n                request = {\n                  transactions: transactionHashes.map(function (hash) {\n                    return hash.toTrytes().toString();\n                  }),\n                  tips: [nodeInfo.latestSolidSubtangleMilestone]\n                };\n                _context4.next = 10;\n                return this._apiClient.getInclusionStates(request);\n\n              case 10:\n                response = _context4.sent;\n\n                if (!(response && response.states)) {\n                  _context4.next = 16;\n                  break;\n                }\n\n                this._logger.info(\"<=== \", response.states);\n\n                return _context4.abrupt(\"return\", response.states);\n\n              case 16:\n                this._logger.info(\"<=== []\");\n\n                return _context4.abrupt(\"return\", []);\n\n              case 18:\n                _context4.next = 21;\n                break;\n\n              case 20:\n                throw new businessError_1.BusinessError(\"The node could not provide the latestSolidSubtangleMilestone\");\n\n              case 21:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      return function getLatestInclusion(_x6) {\n        return _getLatestInclusion.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Generates addresses with index-based or using apis.\r\n     * @param seed The seed to generate the addresses from.\r\n     * @param startIndex The start index to generate addresses.\r\n     * @param endIndex The end index to generate addresses.\r\n     * @param includeChecksum Includes the checksum on addresses.\r\n     * @param security The security level at which to create the addresses.\r\n     * @returns Promise which resolves to the list of addresses or rejects with error.\r\n     */\n\n  }, {\n    key: \"getNewAddress\",\n    value: function () {\n      var _getNewAddress = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee5(seed, startIndex, endIndex, includeChecksum, security) {\n        var localStartIndex, hasEndIndex, localSecurity, addresses, total;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                this._logger.info(\"===> getNewAddress\", seed, startIndex, endIndex, includeChecksum, security);\n\n                if (objectHelper_1.ObjectHelper.isType(seed, hash_1.Hash)) {\n                  _context5.next = 3;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The seed must be of type Hash\");\n\n              case 3:\n                if (!(!objectHelper_1.ObjectHelper.isEmpty(startIndex) && !objectHelper_1.ObjectHelper.isType(startIndex, Number))) {\n                  _context5.next = 5;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The startIndex must be an integer\", {\n                  startIndex: startIndex\n                });\n\n              case 5:\n                localStartIndex = startIndex || 0;\n\n                if (!(localStartIndex < 0)) {\n                  _context5.next = 8;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The startIndex must be >= 0\", {\n                  localStartIndex: localStartIndex\n                });\n\n              case 8:\n                hasEndIndex = numberHelper_1.NumberHelper.isInteger(endIndex);\n                localSecurity = security || addressSecurity_1.AddressSecurity.medium;\n\n                if (!hasEndIndex) {\n                  _context5.next = 19;\n                  break;\n                }\n\n                total = endIndex - startIndex + 1;\n\n                if (!(total <= 0 || total > TransactionClient.MAX_INPUTS)) {\n                  _context5.next = 14;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The total must be > 0 and <= \".concat(TransactionClient.MAX_INPUTS), {\n                  total: total\n                });\n\n              case 14:\n                _context5.next = 16;\n                return this.getAddressesByIndex(seed, startIndex, endIndex, includeChecksum, localSecurity);\n\n              case 16:\n                addresses = _context5.sent;\n                _context5.next = 22;\n                break;\n\n              case 19:\n                _context5.next = 21;\n                return this.getAddressesToUnused(seed, startIndex, includeChecksum, localSecurity);\n\n              case 21:\n                addresses = _context5.sent;\n\n              case 22:\n                this._logger.info(\"<=== \", addresses);\n\n                return _context5.abrupt(\"return\", addresses);\n\n              case 24:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      return function getNewAddress(_x7, _x8, _x9, _x10, _x11) {\n        return _getNewAddress.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Generates new addresses index-based.\r\n     * @param seed The seed to generate the addresses from.\r\n     * @param startIndex The start index to generate addresses.\r\n     * @param endIndex The end index to generate addresses.\r\n     * @param includeChecksum Includes the checksum on addresses.\r\n     * @param security The security level at which to create the addresses.\r\n     * @returns Promise which resolves to the list of addresses or rejects with error.\r\n     */\n\n  }, {\n    key: \"getAddressesByIndex\",\n    value: function () {\n      var _getAddressesByIndex = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee6(seed, startIndex, endIndex, includeChecksum, security) {\n        var total, addresses, i;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                this._logger.info(\"===> getAddressesByIndex\", seed, startIndex, endIndex, includeChecksum, security);\n\n                if (objectHelper_1.ObjectHelper.isType(seed, hash_1.Hash)) {\n                  _context6.next = 3;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The seed must be of type Hash\");\n\n              case 3:\n                if (!(!numberHelper_1.NumberHelper.isInteger(startIndex) || startIndex < 0)) {\n                  _context6.next = 5;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The startIndex must be a number >= 0\", {\n                  startIndex: startIndex\n                });\n\n              case 5:\n                if (!(!numberHelper_1.NumberHelper.isInteger(endIndex) || endIndex <= 0)) {\n                  _context6.next = 7;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The endIndex must be a number > 0\", {\n                  endIndex: endIndex\n                });\n\n              case 7:\n                total = endIndex - startIndex + 1;\n\n                if (!(total <= 0 || total > TransactionClient.MAX_INPUTS)) {\n                  _context6.next = 10;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The total must be > 0 and <= \".concat(TransactionClient.MAX_INPUTS), {\n                  total: total\n                });\n\n              case 10:\n                if (!(!numberHelper_1.NumberHelper.isInteger(security) || security < 1 || security > 3)) {\n                  _context6.next = 12;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The security must be between 1 and 3\", {\n                  security: security\n                });\n\n              case 12:\n                addresses = [];\n\n                for (i = 0; i < total; i++) {\n                  addresses.push(this.generateAddress(seed, startIndex + i, security, includeChecksum));\n                }\n\n                this._logger.info(\"<=== \", addresses);\n\n                return _context6.abrupt(\"return\", Promise.resolve(addresses));\n\n              case 16:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      return function getAddressesByIndex(_x12, _x13, _x14, _x15, _x16) {\n        return _getAddressesByIndex.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Generates new address which havent been used using apis.\r\n     * @param seed The seed to generate the addresses from.\r\n     * @param startIndex The start index to generate addresses.\r\n     * @param includeChecksum Includes the checksum on addresses.\r\n     * @param security The security level at which to create the addresses.\r\n     * @returns Promise which resolves to an addresses list, the first unused address is the last in the list or rejects with error.\r\n     */\n\n  }, {\n    key: \"getAddressesToUnused\",\n    value: function () {\n      var _getAddressesToUnused = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee7(seed, startIndex, includeChecksum, security) {\n        var localStartIndex, isUsed, addresses, address, addressNoChecksum, spentFromRequest, spentFromResponse, findTransactionsRequest, findResponse;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                this._logger.info(\"===> getAddressesToUnused\", seed, startIndex, includeChecksum, security);\n\n                if (objectHelper_1.ObjectHelper.isType(seed, hash_1.Hash)) {\n                  _context7.next = 3;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The seed must be of type Hash\");\n\n              case 3:\n                if (!(!numberHelper_1.NumberHelper.isInteger(startIndex) || startIndex < 0)) {\n                  _context7.next = 5;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The startIndex must be a number >= 0\", {\n                  startIndex: startIndex\n                });\n\n              case 5:\n                if (!(!numberHelper_1.NumberHelper.isInteger(security) || security < 1 || security > 3)) {\n                  _context7.next = 7;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The security must be between 1 and 3\", {\n                  security: security\n                });\n\n              case 7:\n                localStartIndex = startIndex;\n                addresses = [];\n\n              case 9:\n                address = this.generateAddress(seed, localStartIndex++, security, includeChecksum);\n                addresses.push(address);\n                addressNoChecksum = address.toTrytes().toString();\n                spentFromRequest = {\n                  addresses: [addressNoChecksum]\n                };\n                _context7.next = 15;\n                return this._apiClient.wereAddressesSpentFrom(spentFromRequest);\n\n              case 15:\n                spentFromResponse = _context7.sent;\n                isUsed = spentFromResponse && spentFromResponse.states && spentFromResponse.states.length > 0 ? spentFromResponse.states[0] : false;\n\n                if (isUsed) {\n                  _context7.next = 23;\n                  break;\n                }\n\n                findTransactionsRequest = {\n                  addresses: [addressNoChecksum]\n                };\n                _context7.next = 21;\n                return this._apiClient.findTransactions(findTransactionsRequest);\n\n              case 21:\n                findResponse = _context7.sent;\n                isUsed = findResponse && findResponse.hashes && findResponse.hashes.length > 0;\n\n              case 23:\n                if (isUsed) {\n                  _context7.next = 9;\n                  break;\n                }\n\n              case 24:\n                this._logger.info(\"<=== \", addresses);\n\n                return _context7.abrupt(\"return\", Promise.resolve(addresses));\n\n              case 26:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      return function getAddressesToUnused(_x17, _x18, _x19, _x20) {\n        return _getAddressesToUnused.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Get the input data for a range of addresses.\r\n     * @param seed The seed to get the input data for.\r\n     * @param startIndex The start index to get the addresses.\r\n     * @param endIndex The end index to get the addresses.\r\n     * @param security The security level used to create the addresses.\r\n     * @param totalRequired The threshold at which total balance to stop gathering addresses.\r\n     * @returns Promise which resolves to the inputs for each address or rejects with error.\r\n     */\n\n  }, {\n    key: \"getInputs\",\n    value: function () {\n      var _getInputs = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee8(seed, startIndex, endIndex, security, totalRequired) {\n        var addresses, request, response, inputs, totalBalance, i, balance, resp;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                this._logger.info(\"===> getInputs\", seed, startIndex, endIndex, security, totalRequired);\n\n                if (objectHelper_1.ObjectHelper.isType(seed, hash_1.Hash)) {\n                  _context8.next = 3;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The seed must be of type Hash\");\n\n              case 3:\n                if (!(!numberHelper_1.NumberHelper.isInteger(startIndex) || startIndex < 0)) {\n                  _context8.next = 5;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The startIndex must be a number >= 0\", {\n                  startIndex: startIndex\n                });\n\n              case 5:\n                if (!(!numberHelper_1.NumberHelper.isInteger(security) || security < 1 || security > 3)) {\n                  _context8.next = 7;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The security must be between 1 and 3\", {\n                  security: security\n                });\n\n              case 7:\n                if (!(!numberHelper_1.NumberHelper.isInteger(totalRequired) || totalRequired < 0)) {\n                  _context8.next = 9;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The totalRequired must be >= 0\", {\n                  totalRequired: totalRequired\n                });\n\n              case 9:\n                _context8.next = 11;\n                return this.getNewAddress(seed, startIndex, endIndex, false, security);\n\n              case 11:\n                addresses = _context8.sent;\n                request = {\n                  addresses: addresses.map(function (add) {\n                    return add.toTrytes().toString();\n                  }),\n                  threshold: 100\n                };\n                _context8.next = 15;\n                return this._apiClient.getBalances(request);\n\n              case 15:\n                response = _context8.sent;\n                inputs = [];\n                totalBalance = 0;\n\n                if (!response) {\n                  _context8.next = 30;\n                  break;\n                }\n\n                i = 0;\n\n              case 20:\n                if (!(i < addresses.length)) {\n                  _context8.next = 30;\n                  break;\n                }\n\n                balance = parseInt(response.balances[i], 10);\n\n                if (!(balance > 0)) {\n                  _context8.next = 27;\n                  break;\n                }\n\n                inputs.push(input_1.Input.fromParams(addresses[i], security, startIndex + i, balance));\n                totalBalance += balance;\n\n                if (!(totalRequired > 0 && totalBalance >= totalRequired)) {\n                  _context8.next = 27;\n                  break;\n                }\n\n                return _context8.abrupt(\"break\", 30);\n\n              case 27:\n                i++;\n                _context8.next = 20;\n                break;\n\n              case 30:\n                if (!(totalRequired > 0 && totalBalance < totalRequired)) {\n                  _context8.next = 32;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"Not enough combined balance in the addresses to satisfy the total required\", {\n                  totalRequired: totalRequired,\n                  totalBalance: totalBalance\n                });\n\n              case 32:\n                resp = {\n                  inputs: inputs,\n                  totalBalance: totalBalance\n                };\n\n                this._logger.info(\"<=== \", resp);\n\n                return _context8.abrupt(\"return\", resp);\n\n              case 35:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      return function getInputs(_x21, _x22, _x23, _x24, _x25) {\n        return _getInputs.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Prepares transfer by generating bundle, finding and signing inputs.\r\n     * @param seed The seed to prepare the transfer for.\r\n     * @param transfers The transfers to prepare.\r\n     * @param transferOptions\r\n     *      @property inputs List of inputs used for funding the transfer.\r\n     *      @property security Security level to be used for the private key / addresses.\r\n     *      @property remainderAddress If defined, this address will be used for sending the remainder value (of the inputs) to.\r\n     *      @property hmacKey Hmac key to sign the bundle.\r\n     *      @property reference The transaction to reference.\r\n     * @returns Promise which resolves to the array of Trytes for the transfer or rejects with error.\r\n     */\n\n  }, {\n    key: \"prepareTransfers\",\n    value: function () {\n      var _prepareTransfers = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee9(seed, transfers, transferOptions) {\n        var localTransferOptions, emptyTrytes, addHMAC, addedHMAC, prepared, bundle, lastTag, totalValue, signatureMessageFragments, request, balances, confirmedInputs, totalBalance, i, balance, inputsResponse;\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                this._logger.info(\"===> prepareTransfers\", seed, transfers, transferOptions);\n\n                if (objectHelper_1.ObjectHelper.isType(seed, hash_1.Hash)) {\n                  _context9.next = 3;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The seed must be of type Hash\");\n\n              case 3:\n                if (arrayHelper_1.ArrayHelper.isTyped(transfers, transfer_1.Transfer)) {\n                  _context9.next = 5;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The transfers must be an array of Transfer objects\");\n\n              case 5:\n                localTransferOptions = transferOptions || {};\n                localTransferOptions.security = localTransferOptions.security || addressSecurity_1.AddressSecurity.medium;\n                emptyTrytes = trytes_1.Trytes.fromString(\"\");\n                addHMAC = !objectHelper_1.ObjectHelper.isEmpty(localTransferOptions.hmacKey);\n                addedHMAC = false; // If message or tag is not supplied, provide it\n\n                transfers.forEach(function (transfer) {\n                  transfer.message = transfer.message ? transfer.message : emptyTrytes;\n                  transfer.tag = transfer.tag || tag_1.Tag.EMPTY;\n\n                  if (addHMAC && transfer.value > 0) {\n                    transfer.message = trytes_1.Trytes.fromString(TransactionClient.NULL_HASH_TRYTES + transfer.message.toString());\n                    addedHMAC = true;\n                  }\n                }); // Create a new bundle\n\n                prepared = bundleHelper_1.BundleHelper.prepareBundle(this._timeService, transfers);\n                bundle = prepared.bundle;\n                lastTag = prepared.lastTag;\n                totalValue = prepared.totalValue;\n                signatureMessageFragments = prepared.signatureMessageFragments; // Get inputs if we are sending tokens\n\n                if (!totalValue) {\n                  _context9.next = 49;\n                  break;\n                }\n\n                if (!localTransferOptions.inputs) {\n                  _context9.next = 42;\n                  break;\n                }\n\n                request = {\n                  addresses: localTransferOptions.inputs.map(function (input) {\n                    return input.address.toTrytes().toString();\n                  }),\n                  threshold: 100\n                };\n                _context9.next = 21;\n                return this._apiClient.getBalances(request);\n\n              case 21:\n                balances = _context9.sent;\n                confirmedInputs = [];\n                totalBalance = 0;\n                i = 0;\n\n              case 25:\n                if (!(i < balances.balances.length)) {\n                  _context9.next = 36;\n                  break;\n                }\n\n                balance = parseInt(balances.balances[i], 10); // If input has balance, add it to confirmedInputs\n\n                if (!(balance > 0)) {\n                  _context9.next = 33;\n                  break;\n                }\n\n                totalBalance += balance;\n                localTransferOptions.inputs[i].balance = balance;\n                confirmedInputs.push(localTransferOptions.inputs[i]); // if we've already reached the intended input value, break out of loop\n\n                if (!(totalBalance >= totalValue)) {\n                  _context9.next = 33;\n                  break;\n                }\n\n                return _context9.abrupt(\"break\", 36);\n\n              case 33:\n                i++;\n                _context9.next = 25;\n                break;\n\n              case 36:\n                if (!(totalValue > totalBalance)) {\n                  _context9.next = 38;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"Not enough balance in the input addresses to satisfy the total for the transfer\");\n\n              case 38:\n                _context9.next = 40;\n                return this.addRemainder(seed, bundle, localTransferOptions, confirmedInputs, signatureMessageFragments, totalValue, lastTag, addedHMAC);\n\n              case 40:\n                _context9.next = 47;\n                break;\n\n              case 42:\n                _context9.next = 44;\n                return this.getInputs(seed, 0, undefined, localTransferOptions.security, totalValue);\n\n              case 44:\n                inputsResponse = _context9.sent;\n                _context9.next = 47;\n                return this.addRemainder(seed, bundle, localTransferOptions, inputsResponse.inputs, signatureMessageFragments, totalValue, lastTag, addedHMAC);\n\n              case 47:\n                _context9.next = 51;\n                break;\n\n              case 49:\n                // If no input required, don't sign and simply finalize the bundle\n                bundleHelper_1.BundleHelper.finalizeBundle(bundle);\n                bundle.addSignatureMessageFragments(signatureMessageFragments);\n\n              case 51:\n                bundle.transactions = bundle.transactions.reverse();\n\n                this._logger.info(\"<=== \", bundle);\n\n                return _context9.abrupt(\"return\", bundle);\n\n              case 54:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      return function prepareTransfers(_x26, _x27, _x28) {\n        return _prepareTransfers.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Attach the transactions to the tangle by doing proof of work.\r\n     * @param bundle The bundle of transactions to attach.\r\n     * @param depth Value that determines how far to go for tip selection.\r\n     * @param minWeightMagnitude The minimum weight magnitude for the proof of work.\r\n     * @param reference The reference to send with the transactions.\r\n     * @returns Promise which resolves to the bundle of transactions created or rejects with an error.\r\n     */\n\n  }, {\n    key: \"attachToTangle\",\n    value: function () {\n      var _attachToTangle = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee10(bundle, depth, minWeightMagnitude, reference) {\n        var transactionsToApproveRequest, transactionsToApprove, powTransactions, allTrytes, attachToTangleRequest, attachToTangleResponse, newBundle;\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                this._logger.info(\"===> attachToTangle\", bundle, depth, minWeightMagnitude, reference);\n\n                if (objectHelper_1.ObjectHelper.isType(bundle, bundle_1.Bundle)) {\n                  _context10.next = 3;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The bundle must be an array of type Bundle\");\n\n              case 3:\n                if (arrayHelper_1.ArrayHelper.isTyped(bundle.transactions, transaction_1.Transaction)) {\n                  _context10.next = 5;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The bundle.transactions must be an array of type Transaction\");\n\n              case 5:\n                if (!(!numberHelper_1.NumberHelper.isInteger(depth) || depth <= 0)) {\n                  _context10.next = 7;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The depth must be a number > 0\", {\n                  depth: depth\n                });\n\n              case 7:\n                if (!(!numberHelper_1.NumberHelper.isInteger(minWeightMagnitude) || minWeightMagnitude <= 0)) {\n                  _context10.next = 9;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The minWeightMagnitude must be a number > 0\", {\n                  minWeightMagnitude: minWeightMagnitude\n                });\n\n              case 9:\n                transactionsToApproveRequest = {\n                  depth: depth,\n                  reference: reference ? reference.toTrytes().toString() : undefined\n                };\n                _context10.next = 12;\n                return this._apiClient.getTransactionsToApprove(transactionsToApproveRequest);\n\n              case 12:\n                transactionsToApprove = _context10.sent;\n\n                if (!this._proofOfWork) {\n                  _context10.next = 26;\n                  break;\n                }\n\n                if (!this._proofOfWork.performsSingle()) {\n                  _context10.next = 20;\n                  break;\n                }\n\n                _context10.next = 17;\n                return this.proofOfWorkIterate(hash_1.Hash.fromTrytes(trytes_1.Trytes.fromString(transactionsToApprove.trunkTransaction)), hash_1.Hash.fromTrytes(trytes_1.Trytes.fromString(transactionsToApprove.branchTransaction)), bundle.transactions, minWeightMagnitude);\n\n              case 17:\n                powTransactions = _context10.sent;\n                _context10.next = 24;\n                break;\n\n              case 20:\n                _context10.next = 22;\n                return this._proofOfWork.pow(hash_1.Hash.fromTrytes(trytes_1.Trytes.fromString(transactionsToApprove.trunkTransaction)), hash_1.Hash.fromTrytes(trytes_1.Trytes.fromString(transactionsToApprove.branchTransaction)), bundle.transactions.map(function (t) {\n                  return t.toTrytes();\n                }), minWeightMagnitude);\n\n              case 22:\n                allTrytes = _context10.sent;\n                powTransactions = allTrytes.map(function (returnTrytes) {\n                  return transaction_1.Transaction.fromTrytes(returnTrytes);\n                });\n\n              case 24:\n                _context10.next = 31;\n                break;\n\n              case 26:\n                attachToTangleRequest = {\n                  trunkTransaction: transactionsToApprove.trunkTransaction,\n                  branchTransaction: transactionsToApprove.branchTransaction,\n                  minWeightMagnitude: minWeightMagnitude,\n                  trytes: bundle.transactions.map(function (t) {\n                    return t.toTrytes().toString();\n                  })\n                };\n                _context10.next = 29;\n                return this._apiClient.attachToTangle(attachToTangleRequest);\n\n              case 29:\n                attachToTangleResponse = _context10.sent;\n                powTransactions = attachToTangleResponse.trytes.map(function (returnTrytes) {\n                  return transaction_1.Transaction.fromTrytes(trytes_1.Trytes.fromString(returnTrytes));\n                });\n\n              case 31:\n                newBundle = new bundle_1.Bundle();\n                newBundle.transactions = powTransactions;\n\n                this._logger.info(\"<=== \", newBundle);\n\n                return _context10.abrupt(\"return\", newBundle);\n\n              case 35:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      return function attachToTangle(_x29, _x30, _x31, _x32) {\n        return _attachToTangle.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Wrapper function that does attachToTangle and then stores and broadcasts the transactions.\r\n     * @param bundle The bundle of transactions to send.\r\n     * @param depth Value that determines how far to go for tip selection.\r\n     * @param minWeightMagnitude The minimum weight magnitude for the proof of work.\r\n     * @param reference The reference to send with the transactions.\r\n     * @returns Promise which resolves to the bundle of transactions created or rejects with an error.\r\n     */\n\n  }, {\n    key: \"sendTransactions\",\n    value: function () {\n      var _sendTransactions = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee11(bundle, depth, minWeightMagnitude, reference) {\n        var attachedTransactionsBundle, storeTransactionsRequest, broadcastTransactionsRequest;\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                this._logger.info(\"===> sendTransactions\", bundle, depth, minWeightMagnitude, reference);\n\n                _context11.next = 3;\n                return this.attachToTangle(bundle, depth, minWeightMagnitude, reference);\n\n              case 3:\n                attachedTransactionsBundle = _context11.sent;\n                storeTransactionsRequest = {\n                  trytes: attachedTransactionsBundle.transactions.map(function (t) {\n                    return t.toTrytes().toString();\n                  })\n                };\n                _context11.next = 7;\n                return this._apiClient.storeTransactions(storeTransactionsRequest);\n\n              case 7:\n                broadcastTransactionsRequest = {\n                  trytes: storeTransactionsRequest.trytes\n                };\n                _context11.next = 10;\n                return this._apiClient.broadcastTransactions(broadcastTransactionsRequest);\n\n              case 10:\n                this._logger.info(\"<=== \", attachedTransactionsBundle);\n\n                return _context11.abrupt(\"return\", attachedTransactionsBundle);\n\n              case 12:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      return function sendTransactions(_x33, _x34, _x35, _x36) {\n        return _sendTransactions.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Wrapper function that does prepareTransfers and then sendTransactions.\r\n     * @param seed The seed to send the transfer for.\r\n     * @param depth Value that determines how far to go for tip selection.\r\n     * @param minWeightMagnitude The minimum weight magnitude for the proof of work.\r\n     * @param transfers The transfers to send.\r\n     * @param transferOptions Additional options for the transfer.\r\n     *      @property inputs List of inputs used for funding the transfer.\r\n     *      @property security Security level to be used for the private key / addresses.\r\n     *      @property remainderAddress If defined, this address will be used for sending the remainder value (of the inputs) to.\r\n     *      @property hmacKey Hmac key to sign the bundle.\r\n     * @param reference The reference to send with the transactions.\r\n     * @returns Promise which resolves to the list of transactions created or rejects with an error.\r\n     */\n\n  }, {\n    key: \"sendTransfer\",\n    value: function () {\n      var _sendTransfer = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee12(seed, depth, minWeightMagnitude, transfers, transferOptions, reference) {\n        var transferTrytes, sentBundle;\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                this._logger.info(\"===> sendTransfer\", seed, depth, minWeightMagnitude, transfers, transferOptions, reference);\n\n                _context12.next = 3;\n                return this.prepareTransfers(seed, transfers, transferOptions);\n\n              case 3:\n                transferTrytes = _context12.sent;\n                _context12.next = 6;\n                return this.sendTransactions(transferTrytes, depth, minWeightMagnitude, reference);\n\n              case 6:\n                sentBundle = _context12.sent;\n\n                this._logger.info(\"<=== \", sentBundle);\n\n                return _context12.abrupt(\"return\", sentBundle);\n\n              case 9:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      return function sendTransfer(_x37, _x38, _x39, _x40, _x41, _x42) {\n        return _sendTransfer.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Find out if a transaction is promotable.\r\n     * @param transactionTail The hash of the transaction to be promoted.\r\n     * @returns Promise which resolves to true if the transaction is promotable rejects with an error.\r\n     */\n\n  }, {\n    key: \"isPromotable\",\n    value: function () {\n      var _isPromotable = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee13(transactionTail) {\n        var checkConsistencyRequest, checkConsistencyResponse;\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                this._logger.info(\"===> isPromotable\", transactionTail);\n\n                if (objectHelper_1.ObjectHelper.isType(transactionTail, hash_1.Hash)) {\n                  _context13.next = 3;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The transactionTail must be an object of type Hash\");\n\n              case 3:\n                checkConsistencyRequest = {\n                  tails: [transactionTail.toTrytes().toString()]\n                };\n                _context13.next = 6;\n                return this._apiClient.checkConsistency(checkConsistencyRequest);\n\n              case 6:\n                checkConsistencyResponse = _context13.sent;\n\n                this._logger.info(\"<=== \", checkConsistencyResponse.state);\n\n                return _context13.abrupt(\"return\", checkConsistencyResponse.state);\n\n              case 9:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      return function isPromotable(_x43) {\n        return _isPromotable.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Determines whether you should replay a transaction or make a new one (either with the same input, or a different one).\r\n     * @param addresses Input address you want to have tested.\r\n     * @returns Promise which resolves to true if the addresses are reattachable or rejects with an error.\r\n     */\n\n  }, {\n    key: \"isReattachable\",\n    value: function () {\n      var _isReattachable = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee14(addresses) {\n        var addrsTxsMap, i, addressString, transactions, valueTransactions, results, inclusionStates, _i2;\n\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                this._logger.info(\"===> isReattachable\", addresses);\n\n                if (arrayHelper_1.ArrayHelper.isTyped(addresses, address_1.Address)) {\n                  _context14.next = 3;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The addresses must be an object of type Address\");\n\n              case 3:\n                addrsTxsMap = {};\n\n                for (i = 0; i < addresses.length; i++) {\n                  addressString = addresses[i].toTrytes().toString();\n                  addrsTxsMap[addressString] = [];\n                }\n\n                _context14.next = 7;\n                return this.findTransactionObjects(undefined, addresses);\n\n              case 7:\n                transactions = _context14.sent;\n                valueTransactions = [];\n                transactions.forEach(function (transaction) {\n                  if (transaction.value.toNumber() < 0) {\n                    var txAddress = transaction.address;\n                    var txHash = bundleHelper_1.BundleHelper.transactionHash(transaction);\n                    addrsTxsMap[txAddress.toTrytes().toString()].push(txHash);\n                    valueTransactions.push(txHash);\n                  }\n                });\n\n                if (!(valueTransactions.length > 0)) {\n                  _context14.next = 17;\n                  break;\n                }\n\n                _context14.next = 13;\n                return this.getLatestInclusion(valueTransactions);\n\n              case 13:\n                inclusionStates = _context14.sent;\n                results = addresses.map(function (address) {\n                  var shouldReattach = true;\n                  var txs = addrsTxsMap[address.toTrytes().toString()];\n\n                  for (var _i = 0; _i < txs.length; _i++) {\n                    var txIndex = valueTransactions.indexOf(txs[_i]);\n                    shouldReattach = !inclusionStates[txIndex];\n\n                    if (!shouldReattach) {\n                      break;\n                    }\n                  }\n\n                  return shouldReattach;\n                });\n                _context14.next = 19;\n                break;\n\n              case 17:\n                results = [];\n\n                for (_i2 = 0; _i2 < addresses.length; _i2++) {\n                  results.push(true);\n                }\n\n              case 19:\n                this._logger.info(\"<=== \", results);\n\n                return _context14.abrupt(\"return\", results);\n\n              case 21:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      return function isReattachable(_x44) {\n        return _isReattachable.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Promotes a transaction by adding spam on top of it, as long as it is promotable.\r\n     * Will promote by adding transfers on top of the current one with delay interval.\r\n     * Use promoteOptions.interrupt to terminate the promotion.\r\n     * If promoteOptions.delay is set to 0 only one promotion transfer will be sent.\r\n     * @param transactionTail The hash of the transaction to be promoted.\r\n     * @param depth Value that determines how far to go for tip selection.\r\n     * @param minWeightMagnitude The minimum weight magnitude for the proof of work.\r\n     * @param transfers The transfers to send.\r\n     * @param promoteOptions Additional options for the promote.\r\n     *      @property delay Delay between promotion transfers\r\n     *      @property interrupt Flag or method to terminate promotion.\r\n     * @returns Promise which resolves to the list of transactions created or rejects with an error.\r\n     */\n\n  }, {\n    key: \"promoteTransaction\",\n    value: function () {\n      var _promoteTransaction = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee16(transactionTail, depth, minWeightMagnitude, transfers, promoteOptions) {\n        var _this = this;\n\n        var localPromoteOptions, isPromotable, sendTransferResponse;\n        return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                this._logger.info(\"===> promoteTransaction\", transactionTail, depth, minWeightMagnitude, transfers, promoteOptions);\n\n                if (objectHelper_1.ObjectHelper.isType(transactionTail, hash_1.Hash)) {\n                  _context16.next = 3;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The transactionTail must be an object of type Hash\");\n\n              case 3:\n                if (!(!numberHelper_1.NumberHelper.isInteger(depth) || depth <= 0)) {\n                  _context16.next = 5;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The depth must be a number > 0\", {\n                  depth: depth\n                });\n\n              case 5:\n                if (!(!numberHelper_1.NumberHelper.isInteger(minWeightMagnitude) || minWeightMagnitude <= 0)) {\n                  _context16.next = 7;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The minWeightMagnitude must be a number > 0\", {\n                  minWeightMagnitude: minWeightMagnitude\n                });\n\n              case 7:\n                if (arrayHelper_1.ArrayHelper.isTyped(transfers, transfer_1.Transfer)) {\n                  _context16.next = 9;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The transfers must an array of Transfer objects\");\n\n              case 9:\n                localPromoteOptions = promoteOptions || {};\n\n                if (objectHelper_1.ObjectHelper.isEmpty(localPromoteOptions.interrupt)) {\n                  localPromoteOptions.interrupt = false;\n                }\n\n                if (!(localPromoteOptions.interrupt === false || typeof localPromoteOptions.interrupt === \"function\" && !localPromoteOptions.interrupt())) {\n                  _context16.next = 30;\n                  break;\n                }\n\n                _context16.next = 14;\n                return this.isPromotable(transactionTail);\n\n              case 14:\n                isPromotable = _context16.sent;\n\n                if (!isPromotable) {\n                  _context16.next = 27;\n                  break;\n                }\n\n                _context16.next = 18;\n                return this.sendTransfer(hash_1.Hash.fromTrytes(transfers[0].address.toTrytes()), depth, minWeightMagnitude, transfers, undefined, transactionTail);\n\n              case 18:\n                sendTransferResponse = _context16.sent;\n\n                if (!numberHelper_1.NumberHelper.isInteger(localPromoteOptions.delay)) {\n                  _context16.next = 23;\n                  break;\n                }\n\n                return _context16.abrupt(\"return\", this._backgroundTaskService.create(\n                /*#__PURE__*/\n                _asyncToGenerator(\n                /*#__PURE__*/\n                _regeneratorRuntime.mark(function _callee15() {\n                  return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n                    while (1) {\n                      switch (_context15.prev = _context15.next) {\n                        case 0:\n                          return _context15.abrupt(\"return\", _this.promoteTransaction(transactionTail, depth, minWeightMagnitude, transfers, localPromoteOptions));\n\n                        case 1:\n                        case \"end\":\n                          return _context15.stop();\n                      }\n                    }\n                  }, _callee15, this);\n                })), localPromoteOptions.delay));\n\n              case 23:\n                this._logger.info(\"<=== \", sendTransferResponse);\n\n                return _context16.abrupt(\"return\", sendTransferResponse);\n\n              case 25:\n                _context16.next = 28;\n                break;\n\n              case 27:\n                throw new businessError_1.BusinessError(\"Transaction is not promotable\");\n\n              case 28:\n                _context16.next = 32;\n                break;\n\n              case 30:\n                this._logger.info(\"<=== \", undefined);\n\n                return _context16.abrupt(\"return\", undefined);\n\n              case 32:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n\n      return function promoteTransaction(_x45, _x46, _x47, _x48, _x49) {\n        return _promoteTransaction.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Gets the associated bundle transactions of a single transaction.\r\n     * Does validation of signatures, total sum as well as bundle order.\r\n     * @param transactionHash Hash of a trunk or a tail transaction of a bundle.\r\n     * @returns Promise which resolves to the bundle transactions or rejects with an error.\r\n     */\n\n  }, {\n    key: \"getBundle\",\n    value: function () {\n      var _getBundle = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee17(transactionHash) {\n        var transactions, bundle, isValid;\n        return _regeneratorRuntime.wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                this._logger.info(\"===> getBundle\", transactionHash);\n\n                if (objectHelper_1.ObjectHelper.isType(transactionHash, hash_1.Hash)) {\n                  _context17.next = 3;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The transactionHash must be an object of type Hash\");\n\n              case 3:\n                _context17.next = 5;\n                return this.traverseBundle(transactionHash);\n\n              case 5:\n                transactions = _context17.sent;\n                bundle = new bundle_1.Bundle();\n                bundle.transactions = transactions;\n                isValid = bundleHelper_1.BundleHelper.isValid(bundle);\n\n                if (isValid) {\n                  _context17.next = 11;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"Invalid bundle provided\");\n\n              case 11:\n                this._logger.info(\"<=== \", bundle);\n\n                return _context17.abrupt(\"return\", bundle);\n\n              case 13:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n\n      return function getBundle(_x50) {\n        return _getBundle.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Traverse the Bundle by going down the trunkTransactions until\r\n     * the bundle hash of the transaction is no longer the same.\r\n     * @param trunkTransaction Hash of a trunk or a tail transaction of a bundle.\r\n     * @param bundleHash The bundle hash to match.\r\n     * @returns Promise which resolves to the bundle transactions or rejects with an error.\r\n     */\n\n  }, {\n    key: \"traverseBundle\",\n    value: function () {\n      var _traverseBundle = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee18(trunkTransaction, bundleHash) {\n        var allBundleTransactions, newTrunkTransaction, newBundleHash, getTrytesRequest, getTrytesResponse, trytes, transactionObject, hasHash, localBundleHash;\n        return _regeneratorRuntime.wrap(function _callee18$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                this._logger.info(\"===> traverseBundle\", trunkTransaction, bundleHash);\n\n                if (objectHelper_1.ObjectHelper.isType(trunkTransaction, hash_1.Hash)) {\n                  _context18.next = 3;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The trunkTransaction must be an object of type Hash\");\n\n              case 3:\n                allBundleTransactions = [];\n                newTrunkTransaction = trunkTransaction;\n                newBundleHash = bundleHash;\n\n              case 6:\n                getTrytesRequest = {\n                  hashes: [newTrunkTransaction.toTrytes().toString()]\n                };\n                _context18.next = 9;\n                return this._apiClient.getTrytes(getTrytesRequest);\n\n              case 9:\n                getTrytesResponse = _context18.sent;\n                trytes = !objectHelper_1.ObjectHelper.isEmpty(getTrytesResponse) && !objectHelper_1.ObjectHelper.isEmpty(getTrytesResponse.trytes) && getTrytesResponse.trytes.length > 0 ? getTrytesResponse.trytes[0] : undefined;\n\n                if (!objectHelper_1.ObjectHelper.isEmpty(trytes)) {\n                  _context18.next = 15;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"Bundle transactions not visible\");\n\n              case 15:\n                transactionObject = transaction_1.Transaction.fromTrytes(trytes_1.Trytes.fromString(trytes)); // If first transaction to search is not a tail, return error\n\n                hasHash = !objectHelper_1.ObjectHelper.isEmpty(newBundleHash);\n\n                if (!(!hasHash && transactionObject.currentIndex.toNumber() !== 0)) {\n                  _context18.next = 19;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"Invalid tail transaction supplied\");\n\n              case 19:\n                // If no bundle hash, define it\n                localBundleHash = hasHash ? newBundleHash : transactionObject.bundle;\n                newTrunkTransaction = undefined;\n                newBundleHash = undefined; // If same bundle hash continue\n\n                if (localBundleHash.toTrytes().toString() === transactionObject.bundle.toTrytes().toString()) {\n                  // Add transaction object to bundle\n                  allBundleTransactions.push(transactionObject); // If more than one element then continue\n\n                  if (transactionObject.lastIndex.toNumber() !== 0 || transactionObject.currentIndex.toNumber() !== 0) {\n                    newTrunkTransaction = transactionObject.trunkTransaction;\n                    newBundleHash = localBundleHash;\n                  }\n                }\n\n              case 23:\n                if (newTrunkTransaction !== undefined) {\n                  _context18.next = 6;\n                  break;\n                }\n\n              case 24:\n                this._logger.info(\"<=== \", allBundleTransactions);\n\n                return _context18.abrupt(\"return\", allBundleTransactions);\n\n              case 26:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n        }, _callee18, this);\n      }));\n\n      return function traverseBundle(_x51, _x52) {\n        return _traverseBundle.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Wrapper which gets a bundle and then replays a transfer by doing Proof of Work again.\r\n     * @param transactionHash The hash of the transaction to be promoted.\r\n     * @param depth Value that determines how far to go for tip selection.\r\n     * @param minWeightMagnitude The minimum weight magnitude for the proof of work.\r\n     * @returns Promise which resolves to the list of transactions created or rejects with an error.\r\n     */\n\n  }, {\n    key: \"reattachBundle\",\n    value: function () {\n      var _reattachBundle = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee19(transactionHash, depth, minWeightMagnitude) {\n        var bundle, sendTransactionsResponse;\n        return _regeneratorRuntime.wrap(function _callee19$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                this._logger.info(\"===> reattachBundle\", transactionHash, depth, minWeightMagnitude);\n\n                _context19.next = 3;\n                return this.getBundle(transactionHash);\n\n              case 3:\n                bundle = _context19.sent;\n                bundle.transactions = bundle.transactions.reverse();\n                _context19.next = 7;\n                return this.sendTransactions(bundle, depth, minWeightMagnitude);\n\n              case 7:\n                sendTransactionsResponse = _context19.sent;\n\n                this._logger.info(\"<=== \", sendTransactionsResponse);\n\n                return _context19.abrupt(\"return\", sendTransactionsResponse);\n\n              case 10:\n              case \"end\":\n                return _context19.stop();\n            }\n          }\n        }, _callee19, this);\n      }));\n\n      return function reattachBundle(_x53, _x54, _x55) {\n        return _reattachBundle.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Wrapper which gets a bundle and then broadcasts it.\r\n     * @param transactionHash The hash of the transaction to be re-broadcast.\r\n     * @returns Promise which resolves or rejects with an error.\r\n     */\n\n  }, {\n    key: \"rebroadcastBundle\",\n    value: function () {\n      var _rebroadcastBundle = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee20(transactionHash) {\n        var bundle, broadcastTransactionsRequest;\n        return _regeneratorRuntime.wrap(function _callee20$(_context20) {\n          while (1) {\n            switch (_context20.prev = _context20.next) {\n              case 0:\n                this._logger.info(\"===> rebroadcastBundle\", transactionHash);\n\n                _context20.next = 3;\n                return this.getBundle(transactionHash);\n\n              case 3:\n                bundle = _context20.sent;\n                broadcastTransactionsRequest = {\n                  trytes: bundle.transactions.reverse().map(function (bt) {\n                    return bt.toTrytes().toString();\n                  })\n                };\n                _context20.next = 7;\n                return this._apiClient.broadcastTransactions(broadcastTransactionsRequest);\n\n              case 7:\n                this._logger.info(\"<=== \", bundle);\n\n                return _context20.abrupt(\"return\", bundle);\n\n              case 9:\n              case \"end\":\n                return _context20.stop();\n            }\n          }\n        }, _callee20, this);\n      }));\n\n      return function rebroadcastBundle(_x56) {\n        return _rebroadcastBundle.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Get transaction objects by fist performing a findTransactions call.\r\n     * @param addresses The addresses to get the transaction objects for.\r\n     * @param bundles Bundles to lookup transactions for.\r\n     * @param addresses Addresses to lookup transactions for.\r\n     * @param tags Tags to lookup transactions for.\r\n     * @param approvees Approvees to lookup transactions for.\r\n     * @returns Promise which resolves to the list of transactions or rejects with an error.\r\n     */\n\n  }, {\n    key: \"findTransactionObjects\",\n    value: function () {\n      var _findTransactionObjects = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee21(bundles, addresses, tags, approvees) {\n        var transactions, resp;\n        return _regeneratorRuntime.wrap(function _callee21$(_context21) {\n          while (1) {\n            switch (_context21.prev = _context21.next) {\n              case 0:\n                this._logger.info(\"===> findTransactionObjects\", bundles, addresses, tags, approvees);\n\n                _context21.next = 3;\n                return this.findTransactions(bundles, addresses, tags, approvees);\n\n              case 3:\n                transactions = _context21.sent;\n\n                if (!(transactions.length > 0)) {\n                  _context21.next = 12;\n                  break;\n                }\n\n                _context21.next = 7;\n                return this.getTransactionsObjects(transactions);\n\n              case 7:\n                resp = _context21.sent;\n\n                this._logger.info(\"<=== \", resp);\n\n                return _context21.abrupt(\"return\", resp);\n\n              case 12:\n                this._logger.info(\"<=== []\");\n\n                return _context21.abrupt(\"return\", []);\n\n              case 14:\n              case \"end\":\n                return _context21.stop();\n            }\n          }\n        }, _callee21, this);\n      }));\n\n      return function findTransactionObjects(_x57, _x58, _x59, _x60) {\n        return _findTransactionObjects.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * The transfers which are associated with a seed. The transfers are determined by either calculating\r\n     * deterministically which addresses were already used, or by providing a list of indexes to get the\r\n     * addresses and the associated transfers from. The transfers are sorted by their timestamp.\r\n     * @param seed The seed to get the transfers for\r\n     * @param startIndex The start index to get the transfers for.\r\n     * @param endIndex The end index to get the transfers for.\r\n     * @param security The security level for the transfers.\r\n     * @param inclusionStates Do you want inclusion states in the bundles.\r\n     * @returns Promise which resolves to the requested bundles or rejects with an error.\r\n     */\n\n  }, {\n    key: \"getTransfers\",\n    value: function () {\n      var _getTransfers = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee22(seed, startIndex, endIndex, security, inclusionStates) {\n        var localStartIndex, addresses, bundles;\n        return _regeneratorRuntime.wrap(function _callee22$(_context22) {\n          while (1) {\n            switch (_context22.prev = _context22.next) {\n              case 0:\n                this._logger.info(\"===> getTransfers\", seed, startIndex, endIndex, security, inclusionStates);\n\n                if (objectHelper_1.ObjectHelper.isType(seed, hash_1.Hash)) {\n                  _context22.next = 3;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The seed must be of type Hash\");\n\n              case 3:\n                localStartIndex = startIndex;\n\n                if (!numberHelper_1.NumberHelper.isInteger(localStartIndex)) {\n                  localStartIndex = 0;\n                }\n\n                _context22.next = 7;\n                return this.getNewAddress(seed, localStartIndex, endIndex, false, security);\n\n              case 7:\n                addresses = _context22.sent;\n                _context22.next = 10;\n                return this.bundlesFromAddresses(addresses, inclusionStates);\n\n              case 10:\n                bundles = _context22.sent;\n\n                this._logger.info(\"<=== \", bundles);\n\n                return _context22.abrupt(\"return\", bundles);\n\n              case 13:\n              case \"end\":\n                return _context22.stop();\n            }\n          }\n        }, _callee22, this);\n      }));\n\n      return function getTransfers(_x61, _x62, _x63, _x64, _x65) {\n        return _getTransfers.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Similar to getTransfers, just that it returns additional account data.\r\n     * @param seed The seed to get the transfers for\r\n     * @param startIndex The start index to get the transfers for.\r\n     * @param endIndex The end index to get the transfers for.\r\n     * @param security The security level for the transfers.\r\n     * @returns Promise which resolves to the account data or rejects with an error.\r\n     */\n\n  }, {\n    key: \"getAccountData\",\n    value: function () {\n      var _getAccountData = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee23(seed, startIndex, endIndex, security) {\n        var localStartIndex, addresses, bundles, accountData, balanceRequest, balanceResponse, i, balance;\n        return _regeneratorRuntime.wrap(function _callee23$(_context23) {\n          while (1) {\n            switch (_context23.prev = _context23.next) {\n              case 0:\n                this._logger.info(\"===> getAccountData\", seed, startIndex, endIndex, security);\n\n                if (objectHelper_1.ObjectHelper.isType(seed, hash_1.Hash)) {\n                  _context23.next = 3;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The seed must be of type Hash\");\n\n              case 3:\n                localStartIndex = startIndex;\n\n                if (!numberHelper_1.NumberHelper.isInteger(localStartIndex)) {\n                  localStartIndex = 0;\n                }\n\n                _context23.next = 7;\n                return this.getNewAddress(seed, localStartIndex, endIndex, false, security || addressSecurity_1.AddressSecurity.medium);\n\n              case 7:\n                addresses = _context23.sent;\n                _context23.next = 10;\n                return this.bundlesFromAddresses(addresses, true);\n\n              case 10:\n                bundles = _context23.sent;\n                accountData = {\n                  latestAddress: addresses.pop(),\n                  addresses: addresses,\n                  transfers: bundles,\n                  inputs: [],\n                  balance: 0\n                };\n                balanceRequest = {\n                  addresses: accountData.addresses.map(function (add) {\n                    return add.toTrytes().toString();\n                  }),\n                  threshold: 100\n                };\n                _context23.next = 15;\n                return this._apiClient.getBalances(balanceRequest);\n\n              case 15:\n                balanceResponse = _context23.sent;\n\n                for (i = 0; i < balanceResponse.balances.length; i++) {\n                  balance = parseInt(balanceResponse.balances[i], 10);\n\n                  if (balance > 0) {\n                    accountData.inputs.push(input_1.Input.fromParams(accountData.addresses[i], security || addressSecurity_1.AddressSecurity.medium, localStartIndex + i, balance));\n                    accountData.balance += balance;\n                  }\n                }\n\n                this._logger.info(\"<=== \", accountData);\n\n                return _context23.abrupt(\"return\", accountData);\n\n              case 19:\n              case \"end\":\n                return _context23.stop();\n            }\n          }\n        }, _callee23, this);\n      }));\n\n      return function getAccountData(_x66, _x67, _x68, _x69) {\n        return _getAccountData.apply(this, arguments);\n      };\n    }()\n    /* @internal */\n\n  }, {\n    key: \"bundlesFromAddresses\",\n    value: function () {\n      var _bundlesFromAddresses = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee24(addresses, inclusionStates) {\n        var transactionObjects, tailTransactions, nonTailBundleHashes, nonTailBundleTransactions, finalBundles, tailTxArray, tailTxStates, i, bundle;\n        return _regeneratorRuntime.wrap(function _callee24$(_context24) {\n          while (1) {\n            switch (_context24.prev = _context24.next) {\n              case 0:\n                _context24.next = 2;\n                return this.findTransactionObjects(undefined, addresses, undefined, undefined);\n\n              case 2:\n                transactionObjects = _context24.sent;\n                // set of tail transactions\n                tailTransactions = new Set();\n                nonTailBundleHashes = new Set();\n                transactionObjects.forEach(function (transaction) {\n                  // Sort tail and nonTails\n                  if (transaction.currentIndex.toNumber() === 0) {\n                    tailTransactions.add(bundleHelper_1.BundleHelper.transactionHash(transaction).toTrytes().toString());\n                  } else {\n                    nonTailBundleHashes.add(transaction.bundle.toTrytes().toString());\n                  }\n                });\n\n                if (!(nonTailBundleHashes.size > 0)) {\n                  _context24.next = 11;\n                  break;\n                }\n\n                _context24.next = 9;\n                return this.findTransactionObjects(Array.from(nonTailBundleHashes).map(function (hash) {\n                  return hash_1.Hash.fromTrytes(trytes_1.Trytes.fromString(hash));\n                }));\n\n              case 9:\n                nonTailBundleTransactions = _context24.sent;\n                nonTailBundleTransactions.forEach(function (transaction) {\n                  if (transaction.currentIndex.toNumber() === 0) {\n                    tailTransactions.add(bundleHelper_1.BundleHelper.transactionHash(transaction).toTrytes().toString());\n                  }\n                });\n\n              case 11:\n                finalBundles = [];\n                tailTxArray = Array.from(tailTransactions); // If inclusionStates, get the confirmation status\n                // of the tail transactions, and thus the bundles\n\n                if (!inclusionStates) {\n                  _context24.next = 17;\n                  break;\n                }\n\n                _context24.next = 16;\n                return this.getLatestInclusion(tailTxArray.map(function (tail) {\n                  return hash_1.Hash.fromTrytes(trytes_1.Trytes.fromString(tail));\n                }));\n\n              case 16:\n                tailTxStates = _context24.sent;\n\n              case 17:\n                i = 0;\n\n              case 18:\n                if (!(i < tailTxArray.length)) {\n                  _context24.next = 27;\n                  break;\n                }\n\n                _context24.next = 21;\n                return this.getBundle(hash_1.Hash.fromTrytes(trytes_1.Trytes.fromString(tailTxArray[i])));\n\n              case 21:\n                bundle = _context24.sent;\n                bundle.inclusionState = tailTxStates ? tailTxStates[i] : undefined;\n                finalBundles.push(bundle);\n\n              case 24:\n                i++;\n                _context24.next = 18;\n                break;\n\n              case 27:\n                // Sort bundles by timestamp\n                finalBundles.sort(function (a, b) {\n                  var x = a.transactions[0].attachmentTimestamp.toNumber();\n                  var y = b.transactions[0].attachmentTimestamp.toNumber();\n                  return x < y ? -1 : x > y ? 1 : 0;\n                });\n                return _context24.abrupt(\"return\", finalBundles);\n\n              case 29:\n              case \"end\":\n                return _context24.stop();\n            }\n          }\n        }, _callee24, this);\n      }));\n\n      return function bundlesFromAddresses(_x70, _x71) {\n        return _bundlesFromAddresses.apply(this, arguments);\n      };\n    }()\n    /* @internal */\n\n  }, {\n    key: \"generateAddress\",\n    value: function generateAddress(seed, index, security, includeChecksum) {\n      var key = signing_1.Signing.key(seed, index, security);\n      var digests = signing_1.Signing.digests(key);\n      var addressTrits = signing_1.Signing.address(digests);\n      var addressTrytesString = trits_1.Trits.fromArray(addressTrits).toTrytes().toString();\n\n      if (includeChecksum) {\n        addressTrytesString += signing_1.Signing.createChecksum(addressTrits, 9);\n      }\n\n      return address_1.Address.fromTrytes(trytes_1.Trytes.fromString(addressTrytesString));\n    }\n    /* @internal */\n\n  }, {\n    key: \"addRemainder\",\n    value: function () {\n      var _addRemainder = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee25(seed, bundle, transferOptions, inputs, signatureMessageFragments, totalValue, tag, addedHMAC) {\n        var totalTransferValue, i, timestamp, remainder, startIndex, k, addresses, ts;\n        return _regeneratorRuntime.wrap(function _callee25$(_context25) {\n          while (1) {\n            switch (_context25.prev = _context25.next) {\n              case 0:\n                totalTransferValue = totalValue;\n                i = 0;\n\n              case 2:\n                if (!(i < inputs.length)) {\n                  _context25.next = 31;\n                  break;\n                }\n\n                timestamp = Math.floor(this._timeService.msSinceEpoch() / 1000); // Add input as bundle entry\n\n                bundle.addTransactions(inputs[i].security, inputs[i].address, -inputs[i].balance, tag, timestamp); // If there is a remainder value\n                // Add extra output to send remaining funds to\n\n                if (!(inputs[i].balance >= totalTransferValue)) {\n                  _context25.next = 27;\n                  break;\n                }\n\n                remainder = inputs[i].balance - totalTransferValue; // If user has provided remainder address use it to send remaining funds to\n\n                if (!(remainder > 0 && !objectHelper_1.ObjectHelper.isEmpty(transferOptions) && objectHelper_1.ObjectHelper.isType(transferOptions.remainderAddress, address_1.Address))) {\n                  _context25.next = 12;\n                  break;\n                }\n\n                // Remainder bundle entry\n                bundle.addTransactions(1, transferOptions.remainderAddress, remainder, tag, timestamp); // Final function for signing inputs\n\n                bundleHelper_1.BundleHelper.signInputs(seed, bundle, transferOptions, signatureMessageFragments, inputs, addedHMAC);\n                _context25.next = 25;\n                break;\n\n              case 12:\n                if (!(remainder > 0)) {\n                  _context25.next = 24;\n                  break;\n                }\n\n                startIndex = 0;\n\n                for (k = 0; k < inputs.length; k++) {\n                  startIndex = Math.max(inputs[k].keyIndex, startIndex);\n                }\n\n                startIndex++;\n                _context25.next = 18;\n                return this.getAddressesToUnused(seed, startIndex, false, transferOptions.security);\n\n              case 18:\n                addresses = _context25.sent;\n                ts = Math.floor(this._timeService.msSinceEpoch() / 1000); // Remainder bundle entry\n\n                bundle.addTransactions(1, addresses[addresses.length - 1], remainder, tag, ts); // Final function for signing inputs\n\n                bundleHelper_1.BundleHelper.signInputs(seed, bundle, transferOptions, signatureMessageFragments, inputs, addedHMAC);\n                _context25.next = 25;\n                break;\n\n              case 24:\n                // If there is no remainder, do not add transaction to bundle\n                // simply sign and return\n                bundleHelper_1.BundleHelper.signInputs(seed, bundle, transferOptions, signatureMessageFragments, inputs, addedHMAC);\n\n              case 25:\n                _context25.next = 28;\n                break;\n\n              case 27:\n                // If multiple inputs provided, subtract the totalTransferValue by\n                // the inputs balance\n                totalTransferValue -= inputs[i].balance;\n\n              case 28:\n                i++;\n                _context25.next = 2;\n                break;\n\n              case 31:\n              case \"end\":\n                return _context25.stop();\n            }\n          }\n        }, _callee25, this);\n      }));\n\n      return function addRemainder(_x72, _x73, _x74, _x75, _x76, _x77, _x78, _x79) {\n        return _addRemainder.apply(this, arguments);\n      };\n    }()\n    /* @internal */\n\n  }, {\n    key: \"proofOfWorkIterate\",\n    value: function () {\n      var _proofOfWorkIterate = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee26(trunkTransaction, branchTransaction, transactions, minWeightMagnitude) {\n        var finalTransactions, previousTransactionHash, i, newTrytes, returnedTrytes, returnTransaction;\n        return _regeneratorRuntime.wrap(function _callee26$(_context26) {\n          while (1) {\n            switch (_context26.prev = _context26.next) {\n              case 0:\n                finalTransactions = [];\n                i = 0;\n\n              case 2:\n                if (!(i < transactions.length)) {\n                  _context26.next = 26;\n                  break;\n                }\n\n                // Start with last index transaction\n                // Assign it the trunk / branch which the user has supplied\n                // If there is a bundle, chain the bundle transactions via\n                // trunkTransaction together\n                transactions[i].attachmentTimestamp = tryteNumber_1.TryteNumber.fromNumber(this._timeService.msSinceEpoch());\n                transactions[i].attachmentTimestampLowerBound = tryteNumber_1.TryteNumber.fromNumber(0);\n                transactions[i].attachmentTimestampUpperBound = tryteNumber_1.TryteNumber.fromNumber(TransactionClient.MAX_TIMESTAMP_VALUE); // If this is the first transaction, to be processed\n                // Make sure that it's the last in the bundle and then\n                // assign it the supplied trunk and branch transactions\n\n                if (!objectHelper_1.ObjectHelper.isEmpty(previousTransactionHash)) {\n                  _context26.next = 13;\n                  break;\n                }\n\n                if (!(transactions[i].lastIndex.toNumber() !== transactions[i].currentIndex.toNumber())) {\n                  _context26.next = 9;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"Wrong bundle order. The bundle should be ordered in descending order from currentIndex\");\n\n              case 9:\n                transactions[i].trunkTransaction = trunkTransaction;\n                transactions[i].branchTransaction = branchTransaction;\n                _context26.next = 15;\n                break;\n\n              case 13:\n                transactions[i].trunkTransaction = previousTransactionHash;\n                transactions[i].branchTransaction = trunkTransaction;\n\n              case 15:\n                newTrytes = transactions[i].toTrytes();\n                _context26.next = 18;\n                return this._proofOfWork.pow(trunkTransaction, branchTransaction, [newTrytes], minWeightMagnitude);\n\n              case 18:\n                returnedTrytes = _context26.sent;\n                transactions[i].nonce = tag_1.Tag.fromTrytes(returnedTrytes[0].sub(transaction_1.Transaction.LENGTH - tag_1.Tag.LENGTH, tag_1.Tag.LENGTH)); // Calculate the hash of the new transaction with nonce and use that as the previous hash for next entry\n\n                returnTransaction = transaction_1.Transaction.fromTrytes(returnedTrytes[0]);\n                previousTransactionHash = bundleHelper_1.BundleHelper.transactionHash(returnTransaction);\n                finalTransactions.push(returnTransaction);\n\n              case 23:\n                i++;\n                _context26.next = 2;\n                break;\n\n              case 26:\n                return _context26.abrupt(\"return\", Promise.resolve(finalTransactions.reverse()));\n\n              case 27:\n              case \"end\":\n                return _context26.stop();\n            }\n          }\n        }, _callee26, this);\n      }));\n\n      return function proofOfWorkIterate(_x80, _x81, _x82, _x83) {\n        return _proofOfWorkIterate.apply(this, arguments);\n      };\n    }()\n  }]);\n\n  return TransactionClient;\n}();\n/* @internal */\n\n\nTransactionClient.NULL_HASH_TRYTES = \"9\".repeat(243);\n/* @internal */\n\nTransactionClient.MAX_TIMESTAMP_VALUE = (Math.pow(3, 27) - 1) / 2;\n/* @internal */\n\nTransactionClient.MAX_INPUTS = 500;\nexports.TransactionClient = TransactionClient;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-business/dist/transactions/transactionClient.js?");

/***/ }),

/***/ "../iota-pico-business/node_modules/@babel/runtime/regenerator/index.js":
/*!******************************************************************************!*\
  !*** ../iota-pico-business/node_modules/@babel/runtime/regenerator/index.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! regenerator-runtime */ \"../iota-pico-business/node_modules/regenerator-runtime/runtime-module.js\");\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-business/node_modules/@babel/runtime/regenerator/index.js?");

/***/ }),

/***/ "../iota-pico-business/node_modules/regenerator-runtime/runtime-module.js":
/*!********************************************************************************!*\
  !*** ../iota-pico-business/node_modules/regenerator-runtime/runtime-module.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\nvar g = (function() { return this })() || Function(\"return this\")();\n\n// Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\nvar hadRuntime = g.regeneratorRuntime &&\n  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;\n\n// Save the old regeneratorRuntime in case it needs to be restored later.\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\n// Force reevalutation of runtime.js.\ng.regeneratorRuntime = undefined;\n\nmodule.exports = __webpack_require__(/*! ./runtime */ \"../iota-pico-business/node_modules/regenerator-runtime/runtime.js\");\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch(e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-business/node_modules/regenerator-runtime/runtime-module.js?");

/***/ }),

/***/ "../iota-pico-business/node_modules/regenerator-runtime/runtime.js":
/*!*************************************************************************!*\
  !*** ../iota-pico-business/node_modules/regenerator-runtime/runtime.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // In sloppy mode, unbound `this` refers to the global object, fallback to\n  // Function constructor if we're in global strict mode. That is sadly a form\n  // of indirect eval which violates Content Security Policy.\n  (function() { return this })() || Function(\"return this\")()\n);\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-business/node_modules/regenerator-runtime/runtime.js?");

/***/ }),

/***/ "../iota-pico-core/dist/error/coreError.js":
/*!*************************************************!*\
  !*** ../iota-pico-core/dist/error/coreError.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _extendableBuiltin(cls) {\n  function ExtendableBuiltin() {\n    var instance = Reflect.construct(cls, Array.from(arguments));\n    Object.setPrototypeOf(instance, Object.getPrototypeOf(this));\n    return instance;\n  }\n\n  ExtendableBuiltin.prototype = Object.create(cls.prototype, {\n    constructor: {\n      value: cls,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n\n  if (Object.setPrototypeOf) {\n    Object.setPrototypeOf(ExtendableBuiltin, cls);\n  } else {\n    ExtendableBuiltin.__proto__ = cls;\n  }\n\n  return ExtendableBuiltin;\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar jsonHelper_1 = __webpack_require__(/*! ../helpers/jsonHelper */ \"../iota-pico-core/dist/helpers/jsonHelper.js\");\n/**\r\n * A core implementation of an error.\r\n */\n\n\nvar CoreError =\n/*#__PURE__*/\nfunction (_extendableBuiltin2) {\n  _inherits(CoreError, _extendableBuiltin2);\n\n  /**\r\n   * Create an instance of CoreError.\r\n   * @param message The message for the error.\r\n   * @param additional Additional details about the error.\r\n   * @param innerError Add information from inner error if there was one.\r\n   */\n  function CoreError(message, additional, innerError) {\n    var _this;\n\n    _classCallCheck(this, CoreError);\n\n    _this = _possibleConstructorReturn(this, (CoreError.__proto__ || Object.getPrototypeOf(CoreError)).call(this, message));\n    _this.additional = additional ? additional : {};\n    _this.innerError = innerError;\n    return _this;\n  }\n  /**\r\n   * Check if an object could be a CoreError.\r\n   * @param obj The object to check if it is a CoreError.\r\n   * @returns true If the tested object is a CoreError.\r\n   */\n\n\n  _createClass(CoreError, [{\n    key: \"format\",\n\n    /**\r\n     * Format the error to a readable version.\r\n     */\n    value: function format() {\n      var _this2 = this;\n\n      var out = this.message || \"\";\n      var keys = Object.keys(this.additional);\n\n      if (keys.length > 0) {\n        if (out.length > 0) {\n          out += \"\\n\";\n        }\n\n        keys.forEach(function (key) {\n          out += \"\\t\".concat(key, \": \").concat(jsonHelper_1.JsonHelper.stringify(_this2.additional[key]), \"\\n\");\n        });\n      }\n\n      return out;\n    }\n  }], [{\n    key: \"isError\",\n    value: function isError(obj) {\n      return obj !== undefined && obj !== null && _typeof(obj) === \"object\" && \"message\" in obj && \"additional\" in obj;\n    }\n  }]);\n\n  return CoreError;\n}(_extendableBuiltin(Error));\n\nexports.CoreError = CoreError;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-core/dist/error/coreError.js?");

/***/ }),

/***/ "../iota-pico-core/dist/factories/factoryBase.js":
/*!*******************************************************!*\
  !*** ../iota-pico-core/dist/factories/factoryBase.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Factory to generate types.\r\n * @typeparam T The generic type for the object types in the factory.\r\n */\n\nvar FactoryBase =\n/*#__PURE__*/\nfunction () {\n  function FactoryBase() {\n    _classCallCheck(this, FactoryBase);\n\n    /* @internal */\n    this._types = {};\n  }\n  /**\r\n   * Register a new type with the factory.\r\n   * @param name The name of the type to register.\r\n   * @param typeConstructor The constructor for the type.\r\n   */\n\n\n  _createClass(FactoryBase, [{\n    key: \"register\",\n    value: function register(name, typeConstructor) {\n      this.getInstance()._types[name] = typeConstructor;\n    }\n    /**\r\n     * Unregister a type from the factory.\r\n     * @param name The name of the type to unregister.\r\n     */\n\n  }, {\n    key: \"unregister\",\n    value: function unregister(name) {\n      delete this.getInstance()._types[name];\n    }\n    /**\r\n     * Does the factory contain a specific type.\r\n     * @param name The name of the type to look for.\r\n     * @returns True if the type exists.\r\n     */\n\n  }, {\n    key: \"exists\",\n    value: function exists(name) {\n      return this.getInstance()._types[name] !== undefined;\n    }\n    /**\r\n     * Create an instance of an object from the factory.\r\n     * @param name The name of the type to create.\r\n     * @param args Any parameters to pass to the constructor.\r\n     * @returns A new instance of the type if it exists, or undefined if it does not.\r\n     */\n\n  }, {\n    key: \"create\",\n    value: function create(name) {\n      var instance = this.getInstance();\n\n      if (instance._types[name]) {\n        var _instance$_types;\n\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n\n        return (_instance$_types = instance._types)[name].apply(_instance$_types, args);\n      } else {\n        return undefined;\n      }\n    }\n  }]);\n\n  return FactoryBase;\n}();\n\nexports.FactoryBase = FactoryBase;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-core/dist/factories/factoryBase.js?");

/***/ }),

/***/ "../iota-pico-core/dist/factories/networkClientFactory.js":
/*!****************************************************************!*\
  !*** ../iota-pico-core/dist/factories/networkClientFactory.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar factoryBase_1 = __webpack_require__(/*! ./factoryBase */ \"../iota-pico-core/dist/factories/factoryBase.js\");\n/**\r\n * Factory to generate network clients.\r\n */\n\n\nvar NetworkClientFactory =\n/*#__PURE__*/\nfunction (_factoryBase_1$Factor) {\n  _inherits(NetworkClientFactory, _factoryBase_1$Factor);\n\n  /**\r\n   * Don't allow manual construction of the factory.\r\n   * @internal\r\n   */\n  function NetworkClientFactory() {\n    _classCallCheck(this, NetworkClientFactory);\n\n    return _possibleConstructorReturn(this, (NetworkClientFactory.__proto__ || Object.getPrototypeOf(NetworkClientFactory)).call(this));\n  }\n  /**\r\n   * Get the instance of the factory.\r\n   * @returns The factory instance.\r\n   */\n\n\n  _createClass(NetworkClientFactory, [{\n    key: \"getInstance\",\n\n    /* @internal */\n    value: function getInstance() {\n      return NetworkClientFactory.instance();\n    }\n  }], [{\n    key: \"instance\",\n    value: function instance() {\n      if (!NetworkClientFactory._instance) {\n        NetworkClientFactory._instance = new NetworkClientFactory();\n      }\n\n      return NetworkClientFactory._instance;\n    }\n  }]);\n\n  return NetworkClientFactory;\n}(factoryBase_1.FactoryBase);\n\nexports.NetworkClientFactory = NetworkClientFactory;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-core/dist/factories/networkClientFactory.js?");

/***/ }),

/***/ "../iota-pico-core/dist/helpers/arrayHelper.js":
/*!*****************************************************!*\
  !*** ../iota-pico-core/dist/helpers/arrayHelper.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar objectHelper_1 = __webpack_require__(/*! ./objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n/**\r\n * Array helper methods.\r\n */\n\n\nvar ArrayHelper =\n/*#__PURE__*/\nfunction () {\n  function ArrayHelper() {\n    _classCallCheck(this, ArrayHelper);\n  }\n\n  _createClass(ArrayHelper, null, [{\n    key: \"isArray\",\n\n    /**\r\n     * Is the value an array.\r\n     * @param value Object to test.\r\n     * @returns True if the value is an array.\r\n     */\n    value: function isArray(value) {\n      return value === null || value === undefined ? false : Array.isArray(value);\n    }\n    /**\r\n     * Is the value a empty array.\r\n     * @param value Object to test.\r\n     * @returns True if the value is a empty array.\r\n     */\n\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty(value) {\n      return !ArrayHelper.isArray(value) || value.length === 0;\n    }\n    /**\r\n     * Is the value a non empty array of specific type.\r\n     * @param value Object to test.\r\n     * @param type The type of the object\r\n     * @returns True if the value is a non empty array of a specific type.\r\n     */\n\n  }, {\n    key: \"isTyped\",\n    value: function isTyped(value, type) {\n      return !ArrayHelper.isEmpty(value) && !value.includes(undefined) && !value.includes(null) && value.every(function (a) {\n        return objectHelper_1.ObjectHelper.isType(a, type);\n      });\n    }\n  }]);\n\n  return ArrayHelper;\n}();\n\nexports.ArrayHelper = ArrayHelper;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-core/dist/helpers/arrayHelper.js?");

/***/ }),

/***/ "../iota-pico-core/dist/helpers/errorHelper.js":
/*!*****************************************************!*\
  !*** ../iota-pico-core/dist/helpers/errorHelper.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar coreError_1 = __webpack_require__(/*! ../error/coreError */ \"../iota-pico-core/dist/error/coreError.js\");\n\nvar jsonHelper_1 = __webpack_require__(/*! ./jsonHelper */ \"../iota-pico-core/dist/helpers/jsonHelper.js\");\n\nvar objectHelper_1 = __webpack_require__(/*! ./objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar stringHelper_1 = __webpack_require__(/*! ./stringHelper */ \"../iota-pico-core/dist/helpers/stringHelper.js\");\n/**\r\n * Handle errors as gracefully as possible.\r\n */\n\n\nvar ErrorHelper =\n/*#__PURE__*/\nfunction () {\n  function ErrorHelper() {\n    _classCallCheck(this, ErrorHelper);\n  }\n\n  _createClass(ErrorHelper, null, [{\n    key: \"format\",\n\n    /**\r\n     * Format an error object into something readable.\r\n     * @param err The object to format.\r\n     * @param includeStack Include the stack trace if there is one.\r\n     * @returns Formatted version of the error object.\r\n     */\n    value: function format(err, includeStack) {\n      if (err === null || err === undefined) {\n        return \"unknown error\";\n      } else if (coreError_1.CoreError.isError(err)) {\n        var ret = err.format();\n\n        if (includeStack && err.stack) {\n          ret += \"\\nStack Trace\";\n          var parts = err.stack.split(\"\\n\");\n          parts.shift();\n          ret += \"\\n\".concat(parts.join(\"\\n\"));\n        }\n\n        if (!objectHelper_1.ObjectHelper.isEmpty(err.innerError)) {\n          if (includeStack && !objectHelper_1.ObjectHelper.isEmpty(err.innerError.stack)) {\n            ret += \"\\n\\n-----------------------------------------------\";\n            ret += \"\\nInner Stack Trace\\n\";\n            ret += err.innerError.stack;\n          } else {\n            ret += \"\\nInner Error: \".concat(err.innerError.message, \"\\n\");\n          }\n        }\n\n        return ret;\n      } else if (err instanceof Error) {\n        var _ret = \"\";\n\n        if (includeStack && !objectHelper_1.ObjectHelper.isEmpty(err.stack)) {\n          _ret += err.stack;\n        } else {\n          _ret += err.message;\n        }\n\n        return _ret;\n      } else {\n        if (stringHelper_1.StringHelper.isString(err)) {\n          return err;\n        } else {\n          return jsonHelper_1.JsonHelper.stringify(err, undefined, \"\\t\");\n        }\n      }\n    }\n  }]);\n\n  return ErrorHelper;\n}();\n\nexports.ErrorHelper = ErrorHelper;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-core/dist/helpers/errorHelper.js?");

/***/ }),

/***/ "../iota-pico-core/dist/helpers/jsonHelper.js":
/*!****************************************************!*\
  !*** ../iota-pico-core/dist/helpers/jsonHelper.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Json helper methods.\r\n */\n\nvar JsonHelper =\n/*#__PURE__*/\nfunction () {\n  function JsonHelper() {\n    _classCallCheck(this, JsonHelper);\n  }\n\n  _createClass(JsonHelper, null, [{\n    key: \"stringify\",\n\n    /**\r\n     * Stringify an object with recursion breaking.\r\n     * @param value A JavaScript value, usually an object or array, to be converted.\r\n     * @param replacer A function that transforms the results.\r\n     * @param space Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.\r\n     * @returns String version of the object.\r\n     */\n    value: function stringify(value, replacer, space) {\n      // eliminates any recursion in the stringify\n      var cache = [];\n\n      var recusionReplacer = function recusionReplacer(key, replaceValue) {\n        if (_typeof(replaceValue) === \"object\" && value !== null && replaceValue !== undefined) {\n          if (cache.indexOf(replaceValue) !== -1) {\n            // circular reference found, discard key\n            return;\n          } else {\n            cache.push(replaceValue);\n          }\n        }\n\n        return replacer ? replacer(key, replaceValue) : replaceValue;\n      };\n\n      return JSON.stringify(value, recusionReplacer, space);\n    }\n  }]);\n\n  return JsonHelper;\n}();\n\nexports.JsonHelper = JsonHelper;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-core/dist/helpers/jsonHelper.js?");

/***/ }),

/***/ "../iota-pico-core/dist/helpers/numberHelper.js":
/*!******************************************************!*\
  !*** ../iota-pico-core/dist/helpers/numberHelper.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Number helper methods.\r\n */\n\nvar NumberHelper =\n/*#__PURE__*/\nfunction () {\n  function NumberHelper() {\n    _classCallCheck(this, NumberHelper);\n  }\n\n  _createClass(NumberHelper, null, [{\n    key: \"isInteger\",\n\n    /**\r\n     * Is the value a number.\r\n     * @param value Object to test for its numberyness.\r\n     * @returns True if the object is a number.\r\n     */\n    value: function isInteger(value) {\n      return Number.isInteger(value) && !Number.isNaN(value) && Number.isFinite(value);\n    }\n  }]);\n\n  return NumberHelper;\n}();\n\nexports.NumberHelper = NumberHelper;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-core/dist/helpers/numberHelper.js?");

/***/ }),

/***/ "../iota-pico-core/dist/helpers/objectHelper.js":
/*!******************************************************!*\
  !*** ../iota-pico-core/dist/helpers/objectHelper.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Object helper methods.\r\n */\n\nvar ObjectHelper =\n/*#__PURE__*/\nfunction () {\n  function ObjectHelper() {\n    _classCallCheck(this, ObjectHelper);\n  }\n\n  _createClass(ObjectHelper, null, [{\n    key: \"isEmpty\",\n\n    /**\r\n     * Is the value empty.\r\n     * @param value Object to test.\r\n     * @returns True if the value is empty.\r\n     */\n    value: function isEmpty(value) {\n      return value === null || value === undefined;\n    }\n    /**\r\n     * Is the value an object.\r\n     * @param value Object to test.\r\n     * @returns True if the value is an object.\r\n     */\n\n  }, {\n    key: \"isObject\",\n    value: function isObject(value) {\n      return value === null || value === undefined ? false : _typeof(value) === \"object\" && !Array.isArray(value);\n    }\n    /**\r\n     * Is the value an object if given type.\r\n     * @param value Object to test.\r\n     * @param type The type of the object\r\n     * @returns True if the value is an object of the specified type.\r\n     */\n\n  }, {\n    key: \"isType\",\n    value: function isType(value, typeConstructor) {\n      var valueClassName = ObjectHelper.getClassName(value);\n      return valueClassName !== undefined && valueClassName === ObjectHelper.getClassName(typeConstructor);\n    }\n    /**\r\n     * Get the class name of an object if it has one.\r\n     * @param object The object to get the class name for.\r\n     * @returns The class name if it has one or undefined if not.\r\n     */\n\n  }, {\n    key: \"getClassName\",\n    value: function getClassName(object) {\n      if (object === null || object === undefined) {\n        return undefined;\n      } else {\n        var _constructor = typeof object === \"function\" ? object.toString() : object.constructor.toString();\n\n        var results = _constructor.match(/\\w+/g);\n\n        return results && results.length > 1 ? results[1] : undefined;\n      }\n    }\n  }]);\n\n  return ObjectHelper;\n}();\n\nexports.ObjectHelper = ObjectHelper;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-core/dist/helpers/objectHelper.js?");

/***/ }),

/***/ "../iota-pico-core/dist/helpers/stringHelper.js":
/*!******************************************************!*\
  !*** ../iota-pico-core/dist/helpers/stringHelper.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * String helper methods.\r\n */\n\nvar StringHelper =\n/*#__PURE__*/\nfunction () {\n  function StringHelper() {\n    _classCallCheck(this, StringHelper);\n  }\n\n  _createClass(StringHelper, null, [{\n    key: \"isString\",\n\n    /**\r\n     * Is the value a string.\r\n     * @param value Object to test for its stringyness.\r\n     * @returns True if the object is a string.\r\n     */\n    value: function isString(value) {\n      return value === null || value === undefined ? false : Object.prototype.toString.call(value) === \"[object String]\";\n    }\n    /**\r\n     * Is the value a string that is empty.\r\n     * @param value Object to test for its no emptyness.\r\n     * @returns True if the object is an empty string.\r\n     */\n\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty(value) {\n      return !StringHelper.isString(value) || value.length === 0;\n    }\n    /**\r\n     * Is the string all ASCII characters.\r\n     * @param value string to test if is is ASCII.\r\n     * @returns True if the object is all ASCII.\r\n     */\n\n  }, {\n    key: \"isAscii\",\n    value: function isAscii(value) {\n      return value === null || value === undefined ? false : /^[\\x00-\\xFF]*$/.test(value);\n    }\n    /**\r\n     * Encode non ASCII characters with control characters.\r\n     * @param value The string value to escape.\r\n     * @returns The escaped version of the string.\r\n     */\n\n  }, {\n    key: \"encodeNonASCII\",\n    value: function encodeNonASCII(value) {\n      return StringHelper.isString(value) ? value.replace(/[\\u007F-\\uFFFF]/g, function (chr) {\n        return \"\\\\u\".concat(\"0000\".concat(chr.charCodeAt(0).toString(16)).substr(-4));\n      }) : undefined;\n    }\n    /**\r\n     * Decode control characters to ASCII.\r\n     * @param value The encoded string to convert back to ASCII.\r\n     * @returns The decoded version of the string.\r\n     */\n\n  }, {\n    key: \"decodeNonASCII\",\n    value: function decodeNonASCII(value) {\n      return StringHelper.isString(value) ? value.replace(/\\\\u([\\d\\w]{4})/gi, function (match, grp) {\n        return String.fromCharCode(parseInt(grp, 16));\n      }) : undefined;\n    }\n  }]);\n\n  return StringHelper;\n}();\n\nexports.StringHelper = StringHelper;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-core/dist/helpers/stringHelper.js?");

/***/ }),

/***/ "../iota-pico-core/dist/index.js":
/*!***************************************!*\
  !*** ../iota-pico-core/dist/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function __export(m) {\n  for (var p in m) {\n    if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n  }\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Combined index of all the modules.\r\n */\n\n__export(__webpack_require__(/*! ./error/coreError */ \"../iota-pico-core/dist/error/coreError.js\"));\n\n__export(__webpack_require__(/*! ./factories/factoryBase */ \"../iota-pico-core/dist/factories/factoryBase.js\"));\n\n__export(__webpack_require__(/*! ./factories/networkClientFactory */ \"../iota-pico-core/dist/factories/networkClientFactory.js\"));\n\n__export(__webpack_require__(/*! ./helpers/arrayHelper */ \"../iota-pico-core/dist/helpers/arrayHelper.js\"));\n\n__export(__webpack_require__(/*! ./helpers/errorHelper */ \"../iota-pico-core/dist/helpers/errorHelper.js\"));\n\n__export(__webpack_require__(/*! ./helpers/jsonHelper */ \"../iota-pico-core/dist/helpers/jsonHelper.js\"));\n\n__export(__webpack_require__(/*! ./helpers/numberHelper */ \"../iota-pico-core/dist/helpers/numberHelper.js\"));\n\n__export(__webpack_require__(/*! ./helpers/stringHelper */ \"../iota-pico-core/dist/helpers/stringHelper.js\"));\n\n__export(__webpack_require__(/*! ./helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\"));\n\n__export(__webpack_require__(/*! ./loggers/consoleLogger */ \"../iota-pico-core/dist/loggers/consoleLogger.js\"));\n\n__export(__webpack_require__(/*! ./loggers/nullLogger */ \"../iota-pico-core/dist/loggers/nullLogger.js\"));\n\n__export(__webpack_require__(/*! ./network/networkEndPoint */ \"../iota-pico-core/dist/network/networkEndPoint.js\"));\n\n__export(__webpack_require__(/*! ./services/backgroundTaskService */ \"../iota-pico-core/dist/services/backgroundTaskService.js\"));\n\n__export(__webpack_require__(/*! ./services/timeService */ \"../iota-pico-core/dist/services/timeService.js\"));\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-core/dist/index.js?");

/***/ }),

/***/ "../iota-pico-core/dist/loggers/consoleLogger.js":
/*!*******************************************************!*\
  !*** ../iota-pico-core/dist/loggers/consoleLogger.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar arrayHelper_1 = __webpack_require__(/*! ../helpers/arrayHelper */ \"../iota-pico-core/dist/helpers/arrayHelper.js\");\n\nvar errorHelper_1 = __webpack_require__(/*! ../helpers/errorHelper */ \"../iota-pico-core/dist/helpers/errorHelper.js\");\n\nvar objectHelper_1 = __webpack_require__(/*! ../helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar stringHelper_1 = __webpack_require__(/*! ../helpers/stringHelper */ \"../iota-pico-core/dist/helpers/stringHelper.js\");\n/**\r\n * Implementation of ILogger which sends to the this._loggingObject.\r\n */\n// tslint:disable:no-console\n\n\nvar ConsoleLogger =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * Create and instance of the console logger.\r\n   */\n  function ConsoleLogger(loggingObject) {\n    _classCallCheck(this, ConsoleLogger);\n\n    this._loggingObject = loggingObject || console;\n  }\n  /**\r\n   * Send banner to the logger.\r\n   * @param message The message to log.\r\n   * @param args Additional parameters to log.\r\n   */\n\n\n  _createClass(ConsoleLogger, [{\n    key: \"banner\",\n    value: function banner(message) {\n      this._loggingObject.log(\"=\".repeat(80));\n\n      this._loggingObject.log(message);\n\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      this.logArgs(this._loggingObject.log, args);\n\n      this._loggingObject.log(\"=\".repeat(80));\n    }\n    /**\r\n     * Send log to the logger.\r\n     * @param message The message to log.\r\n     * @param args Additional parameters to log.\r\n     */\n\n  }, {\n    key: \"log\",\n    value: function log(message) {\n      this._loggingObject.log(message);\n\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      this.logArgs(this._loggingObject.log, args);\n    }\n    /**\r\n     * Send information to the logger.\r\n     * @param message The message to log.\r\n     * @param args Additional parameters to log.\r\n     */\n\n  }, {\n    key: \"info\",\n    value: function info(message) {\n      this._loggingObject.info(message);\n\n      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        args[_key3 - 1] = arguments[_key3];\n      }\n\n      this.logArgs(this._loggingObject.info, args);\n    }\n    /**\r\n     * Send warning to the logger.\r\n     * @param message The message to log.\r\n     * @param args Additional parameters to log.\r\n     */\n\n  }, {\n    key: \"warning\",\n    value: function warning(message) {\n      this._loggingObject.warn(message);\n\n      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n        args[_key4 - 1] = arguments[_key4];\n      }\n\n      this.logArgs(this._loggingObject.warn, args);\n    }\n    /**\r\n     * Send error to the logger.\r\n     * @param message The message to log.\r\n     * @param err An error object to log.\r\n     * @param args Additional parameters to log.\r\n     */\n\n  }, {\n    key: \"error\",\n    value: function error(message, err) {\n      var _this = this;\n\n      this._loggingObject.error(message);\n\n      if (!objectHelper_1.ObjectHelper.isEmpty(err)) {\n        var lines = errorHelper_1.ErrorHelper.format(err, true).split(\"\\n\");\n        lines.forEach(function (line) {\n          _this._loggingObject.error(\"\\t\".concat(line));\n        });\n      }\n\n      for (var _len5 = arguments.length, args = new Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {\n        args[_key5 - 2] = arguments[_key5];\n      }\n\n      this.logArgs(this._loggingObject.error, args);\n    }\n    /* @internal */\n\n  }, {\n    key: \"logArgs\",\n    value: function logArgs(logMethod, args) {\n      var _this2 = this;\n\n      if (!arrayHelper_1.ArrayHelper.isEmpty(args)) {\n        var indent = \"\\t\";\n        var output = \"\";\n        args.forEach(function (arg, index) {\n          output += _this2.createItem(indent, \"\", arg);\n\n          if (index < args.length - 1) {\n            output += \"\".concat(indent).concat(\"-\".repeat(70), \"\\n\");\n          }\n        });\n        logMethod(output);\n      }\n    }\n    /* @internal */\n\n  }, {\n    key: \"createItem\",\n    value: function createItem(indent, key, item) {\n      var _this3 = this;\n\n      var singleItemLineBreak = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"\\n\";\n      var output = \"\";\n\n      if (arrayHelper_1.ArrayHelper.isArray(item)) {\n        var newIndent = \"\".concat(indent, \"\\t\");\n\n        if (stringHelper_1.StringHelper.isEmpty(key)) {\n          output += \"\".concat(indent, \"[\\n\");\n        } else {\n          output += \"\".concat(indent).concat(key, \": [\\n\");\n        }\n\n        item.forEach(function (element, index) {\n          output += _this3.createItem(newIndent, \"\", element, \"\".concat(index < item.length - 1 ? \",\" : \"\", \"\\n\"));\n        });\n        output += \"\".concat(indent, \"]\\n\");\n      } else if (objectHelper_1.ObjectHelper.isObject(item)) {\n        var obString = item.toString();\n\n        if (obString === \"[object Object]\") {\n          var _newIndent = \"\".concat(indent, \"\\t\");\n\n          if (stringHelper_1.StringHelper.isEmpty(key)) {\n            output += \"\".concat(indent, \"{\\n\");\n          } else {\n            output += \"\".concat(indent).concat(key, \": {\\n\");\n          }\n\n          var keys = Object.keys(item);\n          keys.forEach(function (itemKey, index) {\n            output += _this3.createItem(_newIndent, itemKey, item[itemKey], \"\".concat(index < keys.length - 1 ? \",\" : \"\", \"\\n\"));\n          });\n          output += \"\".concat(indent, \"}\\n\");\n        } else {\n          output += this.createItem(indent, key, obString, \"\\n\");\n        }\n      } else {\n        if (stringHelper_1.StringHelper.isEmpty(key)) {\n          output += \"\".concat(indent).concat(objectHelper_1.ObjectHelper.isEmpty(item) ? item : item.toString()).concat(singleItemLineBreak);\n        } else {\n          output += \"\".concat(indent).concat(key, \": \").concat(objectHelper_1.ObjectHelper.isEmpty(item) ? item : item.toString()).concat(singleItemLineBreak);\n        }\n      }\n\n      return output;\n    }\n  }]);\n\n  return ConsoleLogger;\n}();\n\nexports.ConsoleLogger = ConsoleLogger;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-core/dist/loggers/consoleLogger.js?");

/***/ }),

/***/ "../iota-pico-core/dist/loggers/nullLogger.js":
/*!****************************************************!*\
  !*** ../iota-pico-core/dist/loggers/nullLogger.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Implementation of ILogger which is silent.\r\n */\n\nvar NullLogger =\n/*#__PURE__*/\nfunction () {\n  function NullLogger() {\n    _classCallCheck(this, NullLogger);\n  }\n\n  _createClass(NullLogger, [{\n    key: \"banner\",\n\n    /**\r\n     * Send banner to the logger.\r\n     * @param message The message to log.\r\n     * @param args Additional parameters to log.\r\n     */\n    value: function banner(message) {}\n    /**\r\n     * Send log to the logger.\r\n     * @param message The message to log.\r\n     * @param args Additional parameters to log.\r\n     */\n\n  }, {\n    key: \"log\",\n    value: function log(message) {}\n    /**\r\n     * Send information to the logger.\r\n     * @param message The message to log.\r\n     * @param args Additional parameters to log.\r\n     */\n\n  }, {\n    key: \"info\",\n    value: function info(message) {}\n    /**\r\n     * Send warning to the logger.\r\n     * @param message The message to log.\r\n     * @param args Additional parameters to log.\r\n     */\n\n  }, {\n    key: \"warning\",\n    value: function warning(message) {}\n    /**\r\n     * Send error to the logger.\r\n     * @param message The message to log.\r\n     * @param err An error object to log.\r\n     * @param args Additional parameters to log.\r\n     */\n\n  }, {\n    key: \"error\",\n    value: function error(message, err) {}\n  }]);\n\n  return NullLogger;\n}();\n\nexports.NullLogger = NullLogger;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-core/dist/loggers/nullLogger.js?");

/***/ }),

/***/ "../iota-pico-core/dist/network/networkEndPoint.js":
/*!*********************************************************!*\
  !*** ../iota-pico-core/dist/network/networkEndPoint.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar coreError_1 = __webpack_require__(/*! ../error/coreError */ \"../iota-pico-core/dist/error/coreError.js\");\n\nvar numberHelper_1 = __webpack_require__(/*! ../helpers/numberHelper */ \"../iota-pico-core/dist/helpers/numberHelper.js\");\n\nvar objectHelper_1 = __webpack_require__(/*! ../helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar stringHelper_1 = __webpack_require__(/*! ../helpers/stringHelper */ \"../iota-pico-core/dist/helpers/stringHelper.js\");\n/**\r\n * Default implementation of a network endpoint.\r\n */\n\n\nvar NetworkEndPoint =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * Create an instance of NetworkEndPoint.\r\n   * @param protocol The protocol to access the endpoint with.\r\n   * @param host The host name or ip of the endpoint.\r\n   * @param port The port of the endpoint.\r\n   * @param rootPath The path to the endpoint.\r\n   */\n  function NetworkEndPoint(protocol, host, port, rootPath) {\n    _classCallCheck(this, NetworkEndPoint);\n\n    if (!stringHelper_1.StringHelper.isString(protocol) || !/http|https/.test(protocol)) {\n      throw new coreError_1.CoreError(\"The protocol must be defined as http or https\");\n    }\n\n    if (!stringHelper_1.StringHelper.isString(host)) {\n      throw new coreError_1.CoreError(\"The host must be defined\");\n    }\n\n    if (!numberHelper_1.NumberHelper.isInteger(port) || port <= 0) {\n      throw new coreError_1.CoreError(\"The port must be a number greater than zero\");\n    }\n\n    if (!objectHelper_1.ObjectHelper.isEmpty(rootPath) && !stringHelper_1.StringHelper.isString(rootPath)) {\n      throw new coreError_1.CoreError(\"The rootPath must be a valid string\");\n    }\n\n    this._protocol = protocol;\n    this._host = host.replace(/^\\/*/, \"\").replace(/\\/*$/, \"\");\n    this._port = port;\n    this._rootPath = (rootPath || \"\").replace(/^\\/*/, \"\").replace(/\\/*$/, \"\");\n  }\n  /**\r\n   * The protocol to access the endpoint with.\r\n   * @return The protocol.\r\n   */\n\n\n  _createClass(NetworkEndPoint, [{\n    key: \"getProtocol\",\n    value: function getProtocol() {\n      return this._protocol;\n    }\n    /**\r\n     * The host name or ip of the endpoint.\r\n     * @returns The host.\r\n     */\n\n  }, {\n    key: \"getHost\",\n    value: function getHost() {\n      return this._host;\n    }\n    /**\r\n     * The path to the endpoint.\r\n     * @returns The path.\r\n     */\n\n  }, {\n    key: \"getRootPath\",\n    value: function getRootPath() {\n      return this._rootPath;\n    }\n    /**\r\n     * The port of the endpoint.\r\n     * @returns The port.\r\n     */\n\n  }, {\n    key: \"getPort\",\n    value: function getPort() {\n      return this._port;\n    }\n    /**\r\n     * The complete uri.\r\n     * @returns The uri.\r\n     */\n\n  }, {\n    key: \"getUri\",\n    value: function getUri() {\n      return \"\".concat(this._protocol, \"://\").concat(this._host, \":\").concat(this._port, \"/\").concat(this._rootPath);\n    }\n  }]);\n\n  return NetworkEndPoint;\n}();\n\nexports.NetworkEndPoint = NetworkEndPoint;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-core/dist/network/networkEndPoint.js?");

/***/ }),

/***/ "../iota-pico-core/dist/services/backgroundTaskService.js":
/*!****************************************************************!*\
  !*** ../iota-pico-core/dist/services/backgroundTaskService.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ \"../iota-pico-core/node_modules/@babel/runtime/regenerator/index.js\");\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _next(value) { step(\"next\", value); } function _throw(err) { step(\"throw\", err); } _next(); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Default implementation of background task service.\r\n */\n\nvar BackgroundTaskService =\n/*#__PURE__*/\nfunction () {\n  function BackgroundTaskService() {\n    _classCallCheck(this, BackgroundTaskService);\n  }\n\n  _createClass(BackgroundTaskService, [{\n    key: \"create\",\n\n    /**\r\n     * Create a background task.\r\n     * @param task The task to run in the background.\r\n     * @param delay The delay before running the task.\r\n     */\n    value: function () {\n      var _create = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(task, delay) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  setTimeout(function () {\n                    try {\n                      resolve(task());\n                    } catch (err) {\n                      reject(err);\n                    }\n                  }, delay);\n                }));\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      return function create(_x, _x2) {\n        return _create.apply(this, arguments);\n      };\n    }()\n  }]);\n\n  return BackgroundTaskService;\n}();\n\nexports.BackgroundTaskService = BackgroundTaskService;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-core/dist/services/backgroundTaskService.js?");

/***/ }),

/***/ "../iota-pico-core/dist/services/timeService.js":
/*!******************************************************!*\
  !*** ../iota-pico-core/dist/services/timeService.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Represents a class which can provide the time.\r\n */\n\nvar TimeService =\n/*#__PURE__*/\nfunction () {\n  function TimeService() {\n    _classCallCheck(this, TimeService);\n  }\n\n  _createClass(TimeService, [{\n    key: \"msSinceEpoch\",\n\n    /**\r\n     * Returns the number of milliseconds since 1970/01/01.\r\n     * @returns Number of milliseconds.\r\n     */\n    value: function msSinceEpoch() {\n      return Date.now();\n    }\n  }]);\n\n  return TimeService;\n}();\n\nexports.TimeService = TimeService;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-core/dist/services/timeService.js?");

/***/ }),

/***/ "../iota-pico-core/node_modules/@babel/runtime/regenerator/index.js":
/*!**************************************************************************!*\
  !*** ../iota-pico-core/node_modules/@babel/runtime/regenerator/index.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! regenerator-runtime */ \"../iota-pico-core/node_modules/regenerator-runtime/runtime-module.js\");\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-core/node_modules/@babel/runtime/regenerator/index.js?");

/***/ }),

/***/ "../iota-pico-core/node_modules/regenerator-runtime/runtime-module.js":
/*!****************************************************************************!*\
  !*** ../iota-pico-core/node_modules/regenerator-runtime/runtime-module.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\nvar g = (function() { return this })() || Function(\"return this\")();\n\n// Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\nvar hadRuntime = g.regeneratorRuntime &&\n  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;\n\n// Save the old regeneratorRuntime in case it needs to be restored later.\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\n// Force reevalutation of runtime.js.\ng.regeneratorRuntime = undefined;\n\nmodule.exports = __webpack_require__(/*! ./runtime */ \"../iota-pico-core/node_modules/regenerator-runtime/runtime.js\");\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch(e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-core/node_modules/regenerator-runtime/runtime-module.js?");

/***/ }),

/***/ "../iota-pico-core/node_modules/regenerator-runtime/runtime.js":
/*!*********************************************************************!*\
  !*** ../iota-pico-core/node_modules/regenerator-runtime/runtime.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // In sloppy mode, unbound `this` refers to the global object, fallback to\n  // Function constructor if we're in global strict mode. That is sadly a form\n  // of indirect eval which violates Content Security Policy.\n  (function() { return this })() || Function(\"return this\")()\n);\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-core/node_modules/regenerator-runtime/runtime.js?");

/***/ }),

/***/ "../iota-pico-crypto/dist/digests/sha3.js":
/*!************************************************!*\
  !*** ../iota-pico-crypto/dist/digests/sha3.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar cryptoError_1 = __webpack_require__(/*! ../error/cryptoError */ \"../iota-pico-crypto/dist/error/cryptoError.js\");\n/**\r\n * Sha3 implementation.\r\n */\n\n\nvar Sha3 =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * Create a new instance of SHA3.\r\n   * @param bits The number of input bits.\r\n   * @param padding The padding to use.\r\n   * @param outputBits The number of output bits.\r\n   */\n  function Sha3(bits, padding, outputBits) {\n    _classCallCheck(this, Sha3);\n\n    this._padding = padding;\n    this._outputBits = outputBits;\n    this._blockCount = 1600 - (bits << 1) >> 5;\n    this._byteCount = this._blockCount << 2;\n    this._outputBlocks = outputBits >> 5;\n    this._extraBytes = (outputBits & 31) >> 3;\n    this.reset();\n  }\n  /**\r\n   * Reset the digest.\r\n   */\n\n\n  _createClass(Sha3, [{\n    key: \"reset\",\n    value: function reset() {\n      this._reset = true;\n      this._block = 0;\n      this._start = 0;\n      this._blocks = new Uint32Array(this._blockCount + 1);\n      this._state = new Uint32Array(50);\n    }\n    /**\r\n     * Update the digest.\r\n     * @param input Array of data to use in the update.\r\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(input) {\n      if (!objectHelper_1.ObjectHelper.isType(input, ArrayBuffer)) {\n        throw new cryptoError_1.CryptoError(\"Input is not of type ArrayBuffer\");\n      }\n\n      var message = new Uint8Array(input);\n      var length = message.length;\n      var index = 0;\n      var i;\n\n      while (index < length) {\n        if (this._reset) {\n          this._reset = false;\n          this._blocks[0] = this._block;\n\n          for (i = 1; i < this._blockCount + 1; ++i) {\n            this._blocks[i] = 0;\n          }\n        }\n\n        for (i = this._start; index < length && i < this._byteCount; ++index) {\n          this._blocks[i >> 2] |= message[index] << Sha3.SHIFT[i++ & 3];\n        }\n\n        this._lastByteIndex = i;\n\n        if (i >= this._byteCount) {\n          this._start = i - this._byteCount;\n          this._block = this._blocks[this._blockCount];\n\n          for (i = 0; i < this._blockCount; ++i) {\n            this._state[i] ^= this._blocks[i];\n          }\n\n          this.keccakPermutation(this._state);\n          this._reset = true;\n        } else {\n          this._start = i;\n        }\n      }\n    }\n    /**\r\n     * Finalize and return the hash for the digest, will also reset the state.\r\n     * @return Array buffer containing the digest.\r\n     */\n\n  }, {\n    key: \"digest\",\n    value: function digest() {\n      this.finalize();\n      var i = 0;\n      var j = 0;\n      var bytes = this._outputBits >> 3;\n      var buffer;\n\n      if (this._extraBytes) {\n        buffer = new ArrayBuffer(this._outputBlocks + 1 << 2);\n      } else {\n        buffer = new ArrayBuffer(bytes);\n      }\n\n      var array = new Uint32Array(buffer);\n\n      while (j < this._outputBlocks) {\n        for (i = 0; i < this._blockCount && j < this._outputBlocks; ++i, ++j) {\n          array[j] = this._state[i];\n        }\n      }\n\n      if (this._extraBytes) {\n        array[i] = this._state[i];\n        buffer = buffer.slice(0, bytes);\n      }\n\n      this.reset();\n      return buffer;\n    }\n    /* @internal */\n\n  }, {\n    key: \"finalize\",\n    value: function finalize() {\n      var i = this._lastByteIndex;\n      this._blocks[i >> 2] |= this._padding[i & 3];\n\n      if (this._lastByteIndex === this._byteCount) {\n        this._blocks[0] = this._blocks[this._blockCount];\n\n        for (i = 1; i < this._blockCount + 1; ++i) {\n          this._blocks[i] = 0;\n        }\n      }\n\n      this._blocks[this._blockCount - 1] |= 0x80000000;\n\n      for (i = 0; i < this._blockCount; ++i) {\n        this._state[i] ^= this._blocks[i];\n      }\n\n      this.keccakPermutation(this._state);\n    }\n    /* @internal */\n\n  }, {\n    key: \"keccakPermutation\",\n    value: function keccakPermutation(s) {\n      // tslint:disable-next-line:one-variable-per-declaration\n      var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;\n\n      for (n = 0; n < 48; n += 2) {\n        c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];\n        c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];\n        c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];\n        c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];\n        c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];\n        c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];\n        c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];\n        c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];\n        c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];\n        c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];\n        h = c8 ^ (c2 << 1 | c3 >>> 31);\n        l = c9 ^ (c3 << 1 | c2 >>> 31);\n        s[0] ^= h;\n        s[1] ^= l;\n        s[10] ^= h;\n        s[11] ^= l;\n        s[20] ^= h;\n        s[21] ^= l;\n        s[30] ^= h;\n        s[31] ^= l;\n        s[40] ^= h;\n        s[41] ^= l;\n        h = c0 ^ (c4 << 1 | c5 >>> 31);\n        l = c1 ^ (c5 << 1 | c4 >>> 31);\n        s[2] ^= h;\n        s[3] ^= l;\n        s[12] ^= h;\n        s[13] ^= l;\n        s[22] ^= h;\n        s[23] ^= l;\n        s[32] ^= h;\n        s[33] ^= l;\n        s[42] ^= h;\n        s[43] ^= l;\n        h = c2 ^ (c6 << 1 | c7 >>> 31);\n        l = c3 ^ (c7 << 1 | c6 >>> 31);\n        s[4] ^= h;\n        s[5] ^= l;\n        s[14] ^= h;\n        s[15] ^= l;\n        s[24] ^= h;\n        s[25] ^= l;\n        s[34] ^= h;\n        s[35] ^= l;\n        s[44] ^= h;\n        s[45] ^= l;\n        h = c4 ^ (c8 << 1 | c9 >>> 31);\n        l = c5 ^ (c9 << 1 | c8 >>> 31);\n        s[6] ^= h;\n        s[7] ^= l;\n        s[16] ^= h;\n        s[17] ^= l;\n        s[26] ^= h;\n        s[27] ^= l;\n        s[36] ^= h;\n        s[37] ^= l;\n        s[46] ^= h;\n        s[47] ^= l;\n        h = c6 ^ (c0 << 1 | c1 >>> 31);\n        l = c7 ^ (c1 << 1 | c0 >>> 31);\n        s[8] ^= h;\n        s[9] ^= l;\n        s[18] ^= h;\n        s[19] ^= l;\n        s[28] ^= h;\n        s[29] ^= l;\n        s[38] ^= h;\n        s[39] ^= l;\n        s[48] ^= h;\n        s[49] ^= l;\n        b0 = s[0];\n        b1 = s[1];\n        b32 = s[11] << 4 | s[10] >>> 28;\n        b33 = s[10] << 4 | s[11] >>> 28;\n        b14 = s[20] << 3 | s[21] >>> 29;\n        b15 = s[21] << 3 | s[20] >>> 29;\n        b46 = s[31] << 9 | s[30] >>> 23;\n        b47 = s[30] << 9 | s[31] >>> 23;\n        b28 = s[40] << 18 | s[41] >>> 14;\n        b29 = s[41] << 18 | s[40] >>> 14;\n        b20 = s[2] << 1 | s[3] >>> 31;\n        b21 = s[3] << 1 | s[2] >>> 31;\n        b2 = s[13] << 12 | s[12] >>> 20;\n        b3 = s[12] << 12 | s[13] >>> 20;\n        b34 = s[22] << 10 | s[23] >>> 22;\n        b35 = s[23] << 10 | s[22] >>> 22;\n        b16 = s[33] << 13 | s[32] >>> 19;\n        b17 = s[32] << 13 | s[33] >>> 19;\n        b48 = s[42] << 2 | s[43] >>> 30;\n        b49 = s[43] << 2 | s[42] >>> 30;\n        b40 = s[5] << 30 | s[4] >>> 2;\n        b41 = s[4] << 30 | s[5] >>> 2;\n        b22 = s[14] << 6 | s[15] >>> 26;\n        b23 = s[15] << 6 | s[14] >>> 26;\n        b4 = s[25] << 11 | s[24] >>> 21;\n        b5 = s[24] << 11 | s[25] >>> 21;\n        b36 = s[34] << 15 | s[35] >>> 17;\n        b37 = s[35] << 15 | s[34] >>> 17;\n        b18 = s[45] << 29 | s[44] >>> 3;\n        b19 = s[44] << 29 | s[45] >>> 3;\n        b10 = s[6] << 28 | s[7] >>> 4;\n        b11 = s[7] << 28 | s[6] >>> 4;\n        b42 = s[17] << 23 | s[16] >>> 9;\n        b43 = s[16] << 23 | s[17] >>> 9;\n        b24 = s[26] << 25 | s[27] >>> 7;\n        b25 = s[27] << 25 | s[26] >>> 7;\n        b6 = s[36] << 21 | s[37] >>> 11;\n        b7 = s[37] << 21 | s[36] >>> 11;\n        b38 = s[47] << 24 | s[46] >>> 8;\n        b39 = s[46] << 24 | s[47] >>> 8;\n        b30 = s[8] << 27 | s[9] >>> 5;\n        b31 = s[9] << 27 | s[8] >>> 5;\n        b12 = s[18] << 20 | s[19] >>> 12;\n        b13 = s[19] << 20 | s[18] >>> 12;\n        b44 = s[29] << 7 | s[28] >>> 25;\n        b45 = s[28] << 7 | s[29] >>> 25;\n        b26 = s[38] << 8 | s[39] >>> 24;\n        b27 = s[39] << 8 | s[38] >>> 24;\n        b8 = s[48] << 14 | s[49] >>> 18;\n        b9 = s[49] << 14 | s[48] >>> 18;\n        s[0] = b0 ^ ~b2 & b4;\n        s[1] = b1 ^ ~b3 & b5;\n        s[10] = b10 ^ ~b12 & b14;\n        s[11] = b11 ^ ~b13 & b15;\n        s[20] = b20 ^ ~b22 & b24;\n        s[21] = b21 ^ ~b23 & b25;\n        s[30] = b30 ^ ~b32 & b34;\n        s[31] = b31 ^ ~b33 & b35;\n        s[40] = b40 ^ ~b42 & b44;\n        s[41] = b41 ^ ~b43 & b45;\n        s[2] = b2 ^ ~b4 & b6;\n        s[3] = b3 ^ ~b5 & b7;\n        s[12] = b12 ^ ~b14 & b16;\n        s[13] = b13 ^ ~b15 & b17;\n        s[22] = b22 ^ ~b24 & b26;\n        s[23] = b23 ^ ~b25 & b27;\n        s[32] = b32 ^ ~b34 & b36;\n        s[33] = b33 ^ ~b35 & b37;\n        s[42] = b42 ^ ~b44 & b46;\n        s[43] = b43 ^ ~b45 & b47;\n        s[4] = b4 ^ ~b6 & b8;\n        s[5] = b5 ^ ~b7 & b9;\n        s[14] = b14 ^ ~b16 & b18;\n        s[15] = b15 ^ ~b17 & b19;\n        s[24] = b24 ^ ~b26 & b28;\n        s[25] = b25 ^ ~b27 & b29;\n        s[34] = b34 ^ ~b36 & b38;\n        s[35] = b35 ^ ~b37 & b39;\n        s[44] = b44 ^ ~b46 & b48;\n        s[45] = b45 ^ ~b47 & b49;\n        s[6] = b6 ^ ~b8 & b0;\n        s[7] = b7 ^ ~b9 & b1;\n        s[16] = b16 ^ ~b18 & b10;\n        s[17] = b17 ^ ~b19 & b11;\n        s[26] = b26 ^ ~b28 & b20;\n        s[27] = b27 ^ ~b29 & b21;\n        s[36] = b36 ^ ~b38 & b30;\n        s[37] = b37 ^ ~b39 & b31;\n        s[46] = b46 ^ ~b48 & b40;\n        s[47] = b47 ^ ~b49 & b41;\n        s[8] = b8 ^ ~b0 & b2;\n        s[9] = b9 ^ ~b1 & b3;\n        s[18] = b18 ^ ~b10 & b12;\n        s[19] = b19 ^ ~b11 & b13;\n        s[28] = b28 ^ ~b20 & b22;\n        s[29] = b29 ^ ~b21 & b23;\n        s[38] = b38 ^ ~b30 & b32;\n        s[39] = b39 ^ ~b31 & b33;\n        s[48] = b48 ^ ~b40 & b42;\n        s[49] = b49 ^ ~b41 & b43;\n        s[0] ^= Sha3.ROUND_CONSTANTS[n];\n        s[1] ^= Sha3.ROUND_CONSTANTS[n + 1];\n      }\n    }\n  }]);\n\n  return Sha3;\n}();\n/* Padding to use for Keccak */\n\n\nSha3.KECCAK_PADDING = new Uint32Array([1, 256, 65536, 16777216]);\n/* @internal */\n\nSha3.SHIFT = new Uint8Array([0, 8, 16, 24]);\n/* @internal */\n\nSha3.ROUND_CONSTANTS = new Uint32Array([1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648]);\nexports.Sha3 = Sha3;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-crypto/dist/digests/sha3.js?");

/***/ }),

/***/ "../iota-pico-crypto/dist/error/cryptoError.js":
/*!*****************************************************!*\
  !*** ../iota-pico-crypto/dist/error/cryptoError.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar coreError_1 = __webpack_require__(/*! @iota-pico/core/dist/error/coreError */ \"../iota-pico-core/dist/error/coreError.js\");\n/**\r\n * A crypto implementation of an error.\r\n */\n\n\nvar CryptoError =\n/*#__PURE__*/\nfunction (_coreError_1$CoreErro) {\n  _inherits(CryptoError, _coreError_1$CoreErro);\n\n  function CryptoError() {\n    _classCallCheck(this, CryptoError);\n\n    return _possibleConstructorReturn(this, (CryptoError.__proto__ || Object.getPrototypeOf(CryptoError)).apply(this, arguments));\n  }\n\n  return CryptoError;\n}(coreError_1.CoreError);\n\nexports.CryptoError = CryptoError;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-crypto/dist/error/cryptoError.js?");

/***/ }),

/***/ "../iota-pico-crypto/dist/factories/spongeFactory.js":
/*!***********************************************************!*\
  !*** ../iota-pico-crypto/dist/factories/spongeFactory.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar factoryBase_1 = __webpack_require__(/*! @iota-pico/core/dist/factories/factoryBase */ \"../iota-pico-core/dist/factories/factoryBase.js\");\n\nvar curl_1 = __webpack_require__(/*! ../sponges/curl */ \"../iota-pico-crypto/dist/sponges/curl.js\");\n\nvar kerl_1 = __webpack_require__(/*! ../sponges/kerl */ \"../iota-pico-crypto/dist/sponges/kerl.js\");\n/**\r\n * Factory to generate sponges.\r\n */\n\n\nvar SpongeFactory =\n/*#__PURE__*/\nfunction (_factoryBase_1$Factor) {\n  _inherits(SpongeFactory, _factoryBase_1$Factor);\n\n  /**\r\n   * Don't allow manual construction of the factory.\r\n   * @internal\r\n   */\n  function SpongeFactory() {\n    _classCallCheck(this, SpongeFactory);\n\n    return _possibleConstructorReturn(this, (SpongeFactory.__proto__ || Object.getPrototypeOf(SpongeFactory)).call(this));\n  }\n  /**\r\n   * Get the instance of the factory.\r\n   * @returns The factory instance.\r\n   */\n\n\n  _createClass(SpongeFactory, [{\n    key: \"getInstance\",\n\n    /* @internal */\n    value: function getInstance() {\n      return SpongeFactory.instance();\n    }\n  }], [{\n    key: \"instance\",\n    value: function instance() {\n      if (!SpongeFactory._instance) {\n        SpongeFactory._instance = new SpongeFactory();\n\n        SpongeFactory._instance.register(\"curl\", function () {\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          return new (Function.prototype.bind.apply(curl_1.Curl, [null].concat(args)))();\n        });\n\n        SpongeFactory._instance.register(\"kerl\", function () {\n          return new kerl_1.Kerl();\n        });\n      }\n\n      return SpongeFactory._instance;\n    }\n  }]);\n\n  return SpongeFactory;\n}(factoryBase_1.FactoryBase);\n\nexports.SpongeFactory = SpongeFactory;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-crypto/dist/factories/spongeFactory.js?");

/***/ }),

/***/ "../iota-pico-crypto/dist/helpers/bigIntegerHelper.js":
/*!************************************************************!*\
  !*** ../iota-pico-crypto/dist/helpers/bigIntegerHelper.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ \"../iota-pico-core/dist/helpers/numberHelper.js\");\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\"); // tslint:disable-next-line:import-name\n\n\nvar big_integer_1 = __importDefault(__webpack_require__(/*! big-integer */ \"big-integer\"));\n\nvar cryptoError_1 = __webpack_require__(/*! ../error/cryptoError */ \"../iota-pico-crypto/dist/error/cryptoError.js\");\n/**\r\n * Helper class to convert between BigInteger and other types.\r\n * Converted from https://github.com/iotaledger/iri/blob/dev/src/main/java/com/iota/iri/hash/Kerl.java\r\n */\n\n\nvar BigIntegerHelper =\n/*#__PURE__*/\nfunction () {\n  function BigIntegerHelper() {\n    _classCallCheck(this, BigIntegerHelper);\n  }\n\n  _createClass(BigIntegerHelper, null, [{\n    key: \"tritsToBigInteger\",\n\n    /**\r\n     * Convert trits to a bigInteger.\r\n     * @param trits The trits to convert.\r\n     * @param offset Offset within the array to start.\r\n     * @param length The length of the trits array to convert.\r\n     */\n    value: function tritsToBigInteger(trits, offset, length) {\n      if (!objectHelper_1.ObjectHelper.isType(trits, Int8Array) || trits.length === 0) {\n        throw new cryptoError_1.CryptoError(\"The trits must be a non empty Int8Array\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(offset) || offset < 0) {\n        throw new cryptoError_1.CryptoError(\"The offset must be a number >= 0\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(length) || length <= 0) {\n        throw new cryptoError_1.CryptoError(\"The length must be a number > 0\");\n      }\n\n      if (offset + length > trits.length) {\n        throw new cryptoError_1.CryptoError(\"The offset + length is beyond the length of the array\");\n      }\n\n      var value = big_integer_1.default.zero;\n\n      for (var i = length - 1; i >= 0; i--) {\n        value = value.multiply(BigIntegerHelper.RADIX).add(big_integer_1.default(trits[offset + i]));\n      }\n\n      return value;\n    }\n    /**\r\n     * Convert bigInteger to trits.\r\n     * @param value The bigInteger to convert to trits.\r\n     * @param trits The array to receive the trits.\r\n     * @param offset The offset to place the trits in the array.\r\n     * @param length The length of the array.\r\n     */\n\n  }, {\n    key: \"bigIntegerToTrits\",\n    value: function bigIntegerToTrits(value, trits, offset, length) {\n      if (!objectHelper_1.ObjectHelper.isType(value, big_integer_1.default)) {\n        throw new cryptoError_1.CryptoError(\"The value must be a bigInteger type\");\n      }\n\n      if (!objectHelper_1.ObjectHelper.isType(trits, Int8Array)) {\n        throw new cryptoError_1.CryptoError(\"The trits must be an Int8Array\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(offset) || offset < 0) {\n        throw new cryptoError_1.CryptoError(\"The offset must be a number >= 0\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(length) || length <= 0) {\n        throw new cryptoError_1.CryptoError(\"The length must be a number > 0\");\n      }\n\n      if (offset + length > trits.length) {\n        throw new cryptoError_1.CryptoError(\"The offset + length is beyond the length of the array\");\n      }\n\n      var absoluteValue = value.compareTo(big_integer_1.default.zero) < 0 ? value.negate() : value;\n\n      for (var i = 0; i < length; i++) {\n        var divRemainder = absoluteValue.divmod(BigIntegerHelper.RADIX);\n        absoluteValue = divRemainder.quotient;\n        var remainder = divRemainder.remainder;\n\n        if (remainder > BigIntegerHelper.MAX_TRIT_VALUE) {\n          remainder = BigIntegerHelper.MIN_TRIT_VALUE;\n          absoluteValue = absoluteValue.add(big_integer_1.default[\"1\"]);\n        }\n\n        trits[offset + i] = remainder.toJSNumber();\n      }\n\n      if (value.compareTo(big_integer_1.default.zero) < 0) {\n        for (var _i = 0; _i < length; _i++) {\n          // Avoid negative zero\n          trits[offset + _i] = trits[offset + _i] === 0 ? 0 : -trits[offset + _i];\n        }\n      }\n    }\n    /**\r\n     * Convert the bigInteger into bytes.\r\n     * @param value The value to convert.\r\n     * @param destination The destination array to store the bytes.\r\n     * @param offset The offset within the array to store the bytes.\r\n     */\n\n  }, {\n    key: \"bigIntegerToBytes\",\n    value: function bigIntegerToBytes(value, destination, offset) {\n      if (!objectHelper_1.ObjectHelper.isType(value, big_integer_1.default)) {\n        throw new cryptoError_1.CryptoError(\"The value must be a bigInteger type\");\n      }\n\n      if (!objectHelper_1.ObjectHelper.isType(destination, ArrayBuffer) || destination.byteLength === 0) {\n        throw new cryptoError_1.CryptoError(\"The destination must be an array\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(offset) || offset < 0) {\n        throw new cryptoError_1.CryptoError(\"The offset must be a number >= 0\");\n      }\n\n      if (destination.byteLength - offset < BigIntegerHelper.BYTE_HASH_LENGTH) {\n        throw new cryptoError_1.CryptoError(\"Destination array has invalid size, it must be at least \".concat(BigIntegerHelper.BYTE_HASH_LENGTH));\n      } // Remember if it is negative for later\n\n\n      var isNeg = value.isNegative() ? -1 : 0;\n      var hexString = value.toString(16);\n\n      if (isNeg === -1) {\n        // But remove it for now\n        hexString = hexString.slice(1);\n      } // Now make sure the hex string is an even length so the regex works\n\n\n      if (hexString.length % 2 === 1) {\n        hexString = \"0\".concat(hexString);\n      }\n\n      var matches = hexString.match(/[0-9a-f]{2}/g); // Convert the hex to numbers\n\n      var signedBytes = new Int8Array(matches.map(function (hex) {\n        return parseInt(\"0x\".concat(hex), 16);\n      }));\n\n      if (isNeg === -1) {\n        BigIntegerHelper.twosComplement(signedBytes);\n      }\n\n      var dataView = new DataView(destination); // Pad the start of the buffer with the neg value\n\n      var i = offset;\n\n      while (i + signedBytes.length < BigIntegerHelper.BYTE_HASH_LENGTH) {\n        dataView.setInt8(i++, isNeg);\n      } // And copy in the actual bytes\n\n\n      for (var j = signedBytes.length; j-- > 0;) {\n        dataView.setInt8(i++, signedBytes[signedBytes.length - 1 - j]);\n      }\n    }\n    /**\r\n     * Convert bytes to a bigInteger.\r\n     * @param source The source bytes.\r\n     * @param offset The offset within the bytes to start conversion.\r\n     * @param length The length of the bytes to use for conversion.\r\n     */\n\n  }, {\n    key: \"bytesToBigInteger\",\n    value: function bytesToBigInteger(source, offset, length) {\n      if (!objectHelper_1.ObjectHelper.isType(source, ArrayBuffer) || source.byteLength === 0) {\n        throw new cryptoError_1.CryptoError(\"The source must be a non empty number array\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(offset) || offset < 0) {\n        throw new cryptoError_1.CryptoError(\"The offset must be a number >= 0\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(length) || length <= 0) {\n        throw new cryptoError_1.CryptoError(\"The length must be a number > 0\");\n      }\n\n      if (source.byteLength - offset < BigIntegerHelper.BYTE_HASH_LENGTH) {\n        throw new cryptoError_1.CryptoError(\"Source array has invalid size, it must be at least \".concat(BigIntegerHelper.BYTE_HASH_LENGTH));\n      }\n\n      var dataView = new DataView(source);\n      var signedBytes = new Int8Array(dataView.byteLength);\n\n      for (var b = 0; b < dataView.byteLength; b++) {\n        signedBytes[b] = dataView.getInt8(b + offset);\n      } // Remove the initial padding leaving at least one byte\n\n\n      var paddingOffset = 0;\n      var firstByte = signedBytes[0];\n      var isNeg = firstByte < 0; // If the first padding character is negative then reverse the 2s complement\n      // but first strip of the leading padding\n\n      if (firstByte === 0 || firstByte === -1) {\n        while (signedBytes[paddingOffset] === firstByte && paddingOffset < signedBytes.length - 1) {\n          paddingOffset++;\n        } // Strip any padding\n\n\n        signedBytes = signedBytes.slice(paddingOffset);\n      }\n\n      if (isNeg) {\n        BigIntegerHelper.twosComplement(signedBytes);\n      }\n\n      var hexString = isNeg ? \"-\" : \"\";\n      var dv = new DataView(signedBytes.buffer);\n\n      for (var h = 0; h < dv.byteLength; h++) {\n        hexString += \"00\".concat(dv.getUint8(h).toString(16)).slice(-2);\n      }\n\n      return big_integer_1.default(hexString, 16);\n    }\n    /* @internal */\n\n  }, {\n    key: \"twosComplement\",\n    value: function twosComplement(signedBytes) {\n      // if the whole number is negative then\n      // change to 2's complements by noting all the numbers\n      // and adding 1 to the last i.e. ~bignum+1\n      for (var b = 0; b < signedBytes.length; b++) {\n        signedBytes[b] = ~signedBytes[b];\n      } // Add 1 to last number, if the number is 0xFF continue to carry\n\n\n      var c = signedBytes.length - 1;\n\n      do {\n        signedBytes[c]++;\n      } while (signedBytes[c--] === 0 && c > 0);\n    }\n  }]);\n\n  return BigIntegerHelper;\n}();\n/* @internal */\n\n\nBigIntegerHelper.RADIX = big_integer_1.default(3);\n/* @internal */\n\nBigIntegerHelper.MAX_TRIT_VALUE = BigIntegerHelper.RADIX.minus(1).divide(2);\n/* @internal */\n\nBigIntegerHelper.MIN_TRIT_VALUE = BigIntegerHelper.MAX_TRIT_VALUE.negate();\n/* @internal */\n\nBigIntegerHelper.BIT_HASH_LENGTH = 384;\n/* @internal */\n\nBigIntegerHelper.BYTE_HASH_LENGTH = BigIntegerHelper.BIT_HASH_LENGTH / 8;\nexports.BigIntegerHelper = BigIntegerHelper;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-crypto/dist/helpers/bigIntegerHelper.js?");

/***/ }),

/***/ "../iota-pico-crypto/dist/index.js":
/*!*****************************************!*\
  !*** ../iota-pico-crypto/dist/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function __export(m) {\n  for (var p in m) {\n    if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n  }\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Combined index of all the modules.\r\n */\n\n__export(__webpack_require__(/*! ./digests/sha3 */ \"../iota-pico-crypto/dist/digests/sha3.js\"));\n\n__export(__webpack_require__(/*! ./error/cryptoError */ \"../iota-pico-crypto/dist/error/cryptoError.js\"));\n\n__export(__webpack_require__(/*! ./factories/spongeFactory */ \"../iota-pico-crypto/dist/factories/spongeFactory.js\"));\n\n__export(__webpack_require__(/*! ./helpers/bigIntegerHelper */ \"../iota-pico-crypto/dist/helpers/bigIntegerHelper.js\"));\n\n__export(__webpack_require__(/*! ./sponges/curl */ \"../iota-pico-crypto/dist/sponges/curl.js\"));\n\n__export(__webpack_require__(/*! ./sponges/kerl */ \"../iota-pico-crypto/dist/sponges/kerl.js\"));\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-crypto/dist/index.js?");

/***/ }),

/***/ "../iota-pico-crypto/dist/sponges/curl.js":
/*!************************************************!*\
  !*** ../iota-pico-crypto/dist/sponges/curl.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ \"../iota-pico-core/dist/helpers/numberHelper.js\");\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar cryptoError_1 = __webpack_require__(/*! ../error/cryptoError */ \"../iota-pico-crypto/dist/error/cryptoError.js\");\n/**\r\n * Implementation of ISponge using Curl algorithm.\r\n * https://github.com/iotaledger/iota.lib.js/blob/master/lib/crypto/curl/curl.js\r\n */\n\n\nvar Curl =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * Create a new instance of Curl.\r\n   * @param rounds The number of rounds to use.\r\n   */\n  function Curl() {\n    var rounds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Curl.NUMBER_OF_ROUNDS;\n\n    _classCallCheck(this, Curl);\n\n    this._numberOfRounds = rounds;\n  }\n  /**\r\n   * Get the constant for the hasher.\r\n   * @returns The constants.\r\n   */\n\n\n  _createClass(Curl, [{\n    key: \"getConstants\",\n    value: function getConstants() {\n      return {\n        HASH_LENGTH: Curl.HASH_LENGTH,\n        STATE_LENGTH: Curl.STATE_LENGTH,\n        NUMBER_OF_ROUNDS: this._numberOfRounds\n      };\n    }\n    /**\r\n     * Get the state.\r\n     * @returns The state.\r\n     */\n\n  }, {\n    key: \"getState\",\n    value: function getState() {\n      return this._state;\n    }\n    /**\r\n     * Initialise the hasher.\r\n     * @param state The initial state for the hasher.\r\n     */\n\n  }, {\n    key: \"initialize\",\n    value: function initialize(state) {\n      if (state) {\n        this._state = state;\n      } else {\n        this._state = new Int8Array(Curl.STATE_LENGTH);\n      }\n    }\n    /**\r\n     * Reset the hasher.\r\n     */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.initialize();\n    }\n    /**\r\n     * Absorb trits into the hash.\r\n     * @param trits The trits to absorb.\r\n     * @param offset The offset into the trits to absorb from.\r\n     * @param length The number of trits to absorb.\r\n     */\n\n  }, {\n    key: \"absorb\",\n    value: function absorb(trits, offset, length) {\n      if (!objectHelper_1.ObjectHelper.isType(trits, Int8Array) || trits.length === 0) {\n        throw new cryptoError_1.CryptoError(\"Trits must be a non empty Int8Array\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(offset) || offset < 0) {\n        throw new cryptoError_1.CryptoError(\"Offset must be a number >= 0\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(length) || length < 0) {\n        throw new cryptoError_1.CryptoError(\"Length must be a number >= 0\");\n      }\n\n      if (length + offset > trits.length) {\n        throw new cryptoError_1.CryptoError(\"The offset + length is beyond the length of the trits\");\n      }\n\n      var localOffset = offset;\n      var localLength = length;\n\n      do {\n        var i = 0;\n        var limit = localLength < Curl.HASH_LENGTH ? localLength : Curl.HASH_LENGTH;\n\n        while (i < limit) {\n          this._state[i++] = trits[localOffset++];\n        }\n\n        this.transform();\n        localLength -= Curl.HASH_LENGTH;\n      } while (localLength > 0);\n    }\n    /**\r\n     * Squeeze trits into the hash.\r\n     * @param trits The trits to squeeze.\r\n     * @param offset The offset into the trits to squeeze from.\r\n     * @param length The number of trits to squeeze.\r\n     */\n\n  }, {\n    key: \"squeeze\",\n    value: function squeeze(trits, offset, length) {\n      if (!objectHelper_1.ObjectHelper.isType(trits, Int8Array) || trits.length === 0) {\n        throw new cryptoError_1.CryptoError(\"Trits must be a non empty Int8Array\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(offset) || offset < 0) {\n        throw new cryptoError_1.CryptoError(\"Offset must be a number >= 0\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(length) || length < 0) {\n        throw new cryptoError_1.CryptoError(\"Length must be a number >= 0\");\n      }\n\n      if (length + offset > trits.length) {\n        throw new cryptoError_1.CryptoError(\"The offset + length is beyond the length of the trits\");\n      }\n\n      var localOffset = offset;\n      var localLength = length;\n\n      do {\n        var i = 0;\n        var limit = localLength < Curl.HASH_LENGTH ? length : Curl.HASH_LENGTH;\n\n        while (i < limit) {\n          trits[localOffset++] = this._state[i++];\n        }\n\n        this.transform();\n        localLength -= Curl.HASH_LENGTH;\n      } while (localLength > 0);\n    }\n    /**\r\n     * Transform the hash.\r\n     * @internal\r\n     */\n\n  }, {\n    key: \"transform\",\n    value: function transform() {\n      var stateCopy;\n      var index = 0;\n\n      for (var round = 0; round < this._numberOfRounds; round++) {\n        stateCopy = new Int8Array(this._state.slice());\n\n        for (var i = 0; i < Curl.STATE_LENGTH; i++) {\n          this._state[i] = Curl.TRUTH_TABLE[stateCopy[index] + (stateCopy[index += index < 365 ? 364 : -365] << 2) + 5];\n        }\n      }\n    }\n  }]);\n\n  return Curl;\n}();\n\nCurl.HASH_LENGTH = 243;\nCurl.NUMBER_OF_ROUNDS = 81;\nCurl.STATE_LENGTH = Curl.HASH_LENGTH * 3;\n/* @internal */\n\nCurl.TRUTH_TABLE = new Int8Array([1, 0, -1, 2, 1, -1, 0, 2, -1, 1, 0]);\nexports.Curl = Curl;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-crypto/dist/sponges/curl.js?");

/***/ }),

/***/ "../iota-pico-crypto/dist/sponges/kerl.js":
/*!************************************************!*\
  !*** ../iota-pico-crypto/dist/sponges/kerl.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ \"../iota-pico-core/dist/helpers/numberHelper.js\");\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar sha3_1 = __webpack_require__(/*! ../digests/sha3 */ \"../iota-pico-crypto/dist/digests/sha3.js\");\n\nvar cryptoError_1 = __webpack_require__(/*! ../error/cryptoError */ \"../iota-pico-crypto/dist/error/cryptoError.js\");\n\nvar bigIntegerHelper_1 = __webpack_require__(/*! ../helpers/bigIntegerHelper */ \"../iota-pico-crypto/dist/helpers/bigIntegerHelper.js\");\n/**\r\n * Implementation of ISponge using Kerl algorithm.\r\n * https://github.com/iotaledger/iri/blob/dev/src/main/java/com/iota/iri/hash/Kerl.java\r\n */\n\n\nvar Kerl =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * Create a new instance of Kerl.\r\n   */\n  function Kerl() {\n    _classCallCheck(this, Kerl);\n\n    this._keccak = new sha3_1.Sha3(384, sha3_1.Sha3.KECCAK_PADDING, 384);\n  }\n  /**\r\n   * Get the constant for the hasher.\r\n   * @returns The constants.\r\n   */\n\n\n  _createClass(Kerl, [{\n    key: \"getConstants\",\n    value: function getConstants() {\n      return {\n        HASH_LENGTH: Kerl.HASH_LENGTH,\n        BIT_HASH_LENGTH: Kerl.BIT_HASH_LENGTH,\n        BYTE_HASH_LENGTH: Kerl.BYTE_HASH_LENGTH\n      };\n    }\n    /**\r\n     * Get the state.\r\n     * @returns The state.\r\n     */\n\n  }, {\n    key: \"getState\",\n    value: function getState() {\n      return undefined;\n    }\n    /**\r\n     * Initialise the hasher.\r\n     * @param state The initial state for the hasher.\r\n     */\n\n  }, {\n    key: \"initialize\",\n    value: function initialize(state) {}\n    /**\r\n     * Reset the hasher.\r\n     */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this._keccak.reset();\n    }\n    /**\r\n     * Absorb trits into the hash.\r\n     * @param trits The trits to absorb.\r\n     * @param offset The offset into the trits to absorb from.\r\n     * @param length The number of trits to absorb.\r\n     */\n\n  }, {\n    key: \"absorb\",\n    value: function absorb(trits, offset, length) {\n      if (!objectHelper_1.ObjectHelper.isType(trits, Int8Array) || trits.length === 0) {\n        throw new cryptoError_1.CryptoError(\"Trits must be a non empty Int8Array\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(offset) || offset < 0) {\n        throw new cryptoError_1.CryptoError(\"Offset must be a number >= 0\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(length) || length < 0) {\n        throw new cryptoError_1.CryptoError(\"Length must be a number >= 0\");\n      }\n\n      if (length + offset > trits.length) {\n        throw new cryptoError_1.CryptoError(\"The offset + length is beyond the length of the trits\");\n      }\n\n      if (length % 243 !== 0) {\n        throw new cryptoError_1.CryptoError(\"Length must be a multiple of \".concat(Kerl.HASH_LENGTH), {\n          length: length\n        });\n      }\n\n      var localOffset = offset;\n      var localLength = length;\n\n      do {\n        var tritState = trits.slice(localOffset, localOffset + Kerl.HASH_LENGTH);\n        tritState[Kerl.HASH_LENGTH - 1] = 0;\n        var bigInt = bigIntegerHelper_1.BigIntegerHelper.tritsToBigInteger(tritState, 0, tritState.length);\n        var byteState = new ArrayBuffer(Kerl.BYTE_HASH_LENGTH);\n        bigIntegerHelper_1.BigIntegerHelper.bigIntegerToBytes(bigInt, byteState, 0);\n\n        this._keccak.update(byteState);\n\n        localOffset += Kerl.HASH_LENGTH;\n        localLength -= Kerl.HASH_LENGTH;\n      } while (localLength > 0);\n    }\n    /**\r\n     * Squeeze trits into the hash.\r\n     * @param trits The trits to squeeze.\r\n     * @param offset The offset into the trits to squeeze from.\r\n     * @param length The number of trits to squeeze.\r\n     */\n\n  }, {\n    key: \"squeeze\",\n    value: function squeeze(trits, offset, length) {\n      if (!objectHelper_1.ObjectHelper.isType(trits, Int8Array) || trits.length === 0) {\n        throw new cryptoError_1.CryptoError(\"Trits must be a non empty Int8Array\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(offset) || offset < 0) {\n        throw new cryptoError_1.CryptoError(\"Offset must be a number >= 0\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(length) || length < 0) {\n        throw new cryptoError_1.CryptoError(\"Length must be a number >= 0\");\n      }\n\n      if (length + offset > trits.length) {\n        throw new cryptoError_1.CryptoError(\"The offset + length is beyond the length of the trits\");\n      }\n\n      if (length % 243 !== 0) {\n        throw new cryptoError_1.CryptoError(\"Length must be a multiple of \".concat(Kerl.HASH_LENGTH), {\n          length: length\n        });\n      }\n\n      var localOffset = offset;\n      var localLength = length;\n\n      do {\n        var byteStateBuffer = this._keccak.digest();\n\n        var bigInt = bigIntegerHelper_1.BigIntegerHelper.bytesToBigInteger(byteStateBuffer, 0, Kerl.BYTE_HASH_LENGTH);\n        var tritState = new Int8Array(Kerl.HASH_LENGTH);\n        bigIntegerHelper_1.BigIntegerHelper.bigIntegerToTrits(bigInt, tritState, 0, Kerl.HASH_LENGTH);\n        tritState[Kerl.HASH_LENGTH - 1] = 0;\n        var i = 0;\n\n        while (i < Kerl.HASH_LENGTH) {\n          trits[localOffset++] = tritState[i++];\n        }\n\n        var dv = new DataView(byteStateBuffer);\n\n        for (i = 0; i < dv.byteLength; i++) {\n          dv.setUint8(i, dv.getUint8(i) ^ 0xFF);\n        }\n\n        this._keccak.update(byteStateBuffer);\n\n        localLength -= Kerl.HASH_LENGTH;\n      } while (localLength > 0);\n    }\n  }]);\n\n  return Kerl;\n}();\n/* @internal */\n\n\nKerl.HASH_LENGTH = 243;\n/* @internal */\n\nKerl.BIT_HASH_LENGTH = 384;\n/* @internal */\n\nKerl.BYTE_HASH_LENGTH = Kerl.BIT_HASH_LENGTH / 8;\nexports.Kerl = Kerl;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-crypto/dist/sponges/kerl.js?");

/***/ }),

/***/ "../iota-pico-data/dist/converters/asciiTrytesConverter.js":
/*!*****************************************************************!*\
  !*** ../iota-pico-data/dist/converters/asciiTrytesConverter.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar stringHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/stringHelper */ \"../iota-pico-core/dist/helpers/stringHelper.js\");\n\nvar trytes_1 = __webpack_require__(/*! ../data/trytes */ \"../iota-pico-data/dist/data/trytes.js\");\n\nvar dataError_1 = __webpack_require__(/*! ../error/dataError */ \"../iota-pico-data/dist/error/dataError.js\");\n/**\r\n * Trytes converter that converts to and from a string.\r\n */\n\n\nvar AsciiTrytesConverter =\n/*#__PURE__*/\nfunction () {\n  function AsciiTrytesConverter() {\n    _classCallCheck(this, AsciiTrytesConverter);\n  }\n\n  _createClass(AsciiTrytesConverter, [{\n    key: \"to\",\n\n    /**\r\n     * Convert a string value into trytes.\r\n     * @param string value to convert into trytes.\r\n     * @returns The trytes representation of the value.\r\n     */\n    value: function to(value) {\n      if (!stringHelper_1.StringHelper.isString(value)) {\n        throw new dataError_1.DataError(\"The value must not be string\", {\n          value: value\n        });\n      }\n\n      if (!stringHelper_1.StringHelper.isAscii(value)) {\n        throw new dataError_1.DataError(\"The value contains non ASCII characters\", {\n          value: value\n        });\n      }\n\n      var trytes = \"\";\n\n      for (var i = 0; i < value.length; i++) {\n        var asciiValue = value.charCodeAt(i);\n        var firstValue = asciiValue % 27;\n        var secondValue = (asciiValue - firstValue) / 27;\n        trytes += trytes_1.Trytes.ALPHABET[firstValue] + trytes_1.Trytes.ALPHABET[secondValue];\n      }\n\n      return trytes_1.Trytes.fromString(trytes);\n    }\n    /**\r\n     * Convert trytes into a string value.\r\n     * @param trytes to convert into a string value.\r\n     * @returns The string value converted from the trytes.\r\n     */\n\n  }, {\n    key: \"from\",\n    value: function from(trytes) {\n      if (!objectHelper_1.ObjectHelper.isType(trytes, trytes_1.Trytes)) {\n        throw new dataError_1.DataError(\"The trytes parameter is empty or not the correct type\");\n      }\n\n      var trytesString = trytes.toString();\n\n      if (trytesString.length % 2 === 1) {\n        throw new dataError_1.DataError(\"The trytes length must be an even number\");\n      }\n\n      var ascii = \"\";\n\n      for (var i = 0; i < trytesString.length; i += 2) {\n        var trytesPair = trytesString[i] + trytesString[i + 1];\n        var firstValue = trytes_1.Trytes.ALPHABET.indexOf(trytesPair[0]);\n        var secondValue = trytes_1.Trytes.ALPHABET.indexOf(trytesPair[1]);\n        var decimalValue = firstValue + secondValue * 27;\n        ascii += String.fromCharCode(decimalValue);\n      }\n\n      return ascii;\n    }\n  }]);\n\n  return AsciiTrytesConverter;\n}();\n\nexports.AsciiTrytesConverter = AsciiTrytesConverter;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-data/dist/converters/asciiTrytesConverter.js?");

/***/ }),

/***/ "../iota-pico-data/dist/converters/objectTrytesConverter.js":
/*!******************************************************************!*\
  !*** ../iota-pico-data/dist/converters/objectTrytesConverter.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar jsonHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/jsonHelper */ \"../iota-pico-core/dist/helpers/jsonHelper.js\");\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar stringHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/stringHelper */ \"../iota-pico-core/dist/helpers/stringHelper.js\");\n\nvar trytes_1 = __webpack_require__(/*! ../data/trytes */ \"../iota-pico-data/dist/data/trytes.js\");\n\nvar dataError_1 = __webpack_require__(/*! ../error/dataError */ \"../iota-pico-data/dist/error/dataError.js\");\n\nvar asciiTrytesConverter_1 = __webpack_require__(/*! ./asciiTrytesConverter */ \"../iota-pico-data/dist/converters/asciiTrytesConverter.js\");\n/**\r\n * Trytes converter that converts to and from an object.\r\n * @typeparam T The generic type for the conversion methods.\r\n */\n\n\nvar ObjectTrytesConverter =\n/*#__PURE__*/\nfunction () {\n  function ObjectTrytesConverter() {\n    _classCallCheck(this, ObjectTrytesConverter);\n  }\n\n  _createClass(ObjectTrytesConverter, [{\n    key: \"to\",\n\n    /**\r\n     * Convert an object value into trytes.\r\n     * @param object to convert into trytes.\r\n     * @returns The trytes representation of the object.\r\n     */\n    value: function to(value) {\n      if (objectHelper_1.ObjectHelper.isEmpty(value)) {\n        throw new dataError_1.DataError(\"The value can not be empty\");\n      }\n\n      var json;\n\n      try {\n        json = jsonHelper_1.JsonHelper.stringify(value);\n      } catch (err) {\n        throw new dataError_1.DataError(\"There was a problem converting the object to JSON\", {\n          err: err\n        });\n      }\n\n      return new asciiTrytesConverter_1.AsciiTrytesConverter().to(stringHelper_1.StringHelper.encodeNonASCII(json));\n    }\n    /**\r\n     * Convert trytes into a string value.\r\n     * @param trytes to convert into a string value.\r\n     * @returns The string value converted from the trytes.\r\n     */\n\n  }, {\n    key: \"from\",\n    value: function from(trytes) {\n      if (!objectHelper_1.ObjectHelper.isType(trytes, trytes_1.Trytes)) {\n        throw new dataError_1.DataError(\"The trytes parameter is empty or not the correct type\");\n      }\n\n      var ascii = new asciiTrytesConverter_1.AsciiTrytesConverter().from(trytes); // Must have a a start and closing pairs\n\n      if (ascii.length < 2) {\n        throw new dataError_1.DataError(\"The trytes do not represent an object\");\n      } // The start and end must be either {} or \"\" to represent a JSON object\n\n\n      if (!(ascii[0] === \"{\" && ascii[ascii.length - 1] === \"}\" || ascii[0] === \"\\\"\" && ascii[ascii.length - 1] === \"\\\"\")) {\n        throw new dataError_1.DataError(\"The trytes do not represent an object\");\n      }\n\n      var decoded = stringHelper_1.StringHelper.decodeNonASCII(ascii);\n      var obj;\n\n      try {\n        obj = JSON.parse(decoded);\n      } catch (err) {\n        throw new dataError_1.DataError(\"There was a problem converting the object from JSON\", {\n          err: err\n        });\n      }\n\n      return obj;\n    }\n  }]);\n\n  return ObjectTrytesConverter;\n}();\n\nexports.ObjectTrytesConverter = ObjectTrytesConverter;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-data/dist/converters/objectTrytesConverter.js?");

/***/ }),

/***/ "../iota-pico-data/dist/data/address.js":
/*!**********************************************!*\
  !*** ../iota-pico-data/dist/data/address.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar dataError_1 = __webpack_require__(/*! ../error/dataError */ \"../iota-pico-data/dist/error/dataError.js\");\n\nvar trytes_1 = __webpack_require__(/*! ./trytes */ \"../iota-pico-data/dist/data/trytes.js\");\n/**\r\n * A class for handling addresses.\r\n */\n\n\nvar Address =\n/*#__PURE__*/\nfunction () {\n  /* @internal */\n  function Address(addressTrytes, checksumTrytes) {\n    _classCallCheck(this, Address);\n\n    this._addressTrytes = addressTrytes;\n    this._checksumTrytes = checksumTrytes;\n  }\n  /**\r\n   * Create address from trytes.\r\n   * @param address The trytes to create the address from.\r\n   * @returns An instance of Address.\r\n   */\n\n\n  _createClass(Address, [{\n    key: \"toTrytes\",\n\n    /**\r\n     * Convert the address to trytes with no checksum.\r\n     * @returns Trytes version of the address with no checksum.\r\n     */\n    value: function toTrytes() {\n      return trytes_1.Trytes.fromString(this._addressTrytes);\n    }\n    /**\r\n     * Convert the address to trytes with a checksum, creating a blank one if needed.\r\n     * @returns Trytes version of the address with checksu,.\r\n     */\n\n  }, {\n    key: \"toTrytesWithChecksum\",\n    value: function toTrytesWithChecksum() {\n      if (!objectHelper_1.ObjectHelper.isEmpty(this._checksumTrytes)) {\n        return trytes_1.Trytes.fromString(this._addressTrytes + this._checksumTrytes);\n      } else {\n        throw new dataError_1.DataError(\"This address has no checksum calculated for it\");\n      }\n    }\n    /**\r\n     * Get the string view of the object.\r\n     * @returns string of the trytes.\r\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      if (!objectHelper_1.ObjectHelper.isEmpty(this._checksumTrytes)) {\n        return this._addressTrytes + this._checksumTrytes;\n      } else {\n        return this._addressTrytes;\n      }\n    }\n  }], [{\n    key: \"fromTrytes\",\n    value: function fromTrytes(address) {\n      if (!objectHelper_1.ObjectHelper.isType(address, trytes_1.Trytes)) {\n        throw new dataError_1.DataError(\"The address should be a valid Trytes object\");\n      }\n\n      var trytesString = address.toString();\n\n      if (trytesString.length !== Address.LENGTH && trytesString.length !== Address.LENGTH_WITH_CHECKSUM) {\n        throw new dataError_1.DataError(\"The address should either be \".concat(Address.LENGTH, \" or \").concat(Address.LENGTH_WITH_CHECKSUM, \" characters in length\"), {\n          length: trytesString.length\n        });\n      }\n\n      var addressTrytes = trytesString.substr(0, Address.LENGTH);\n      var checksumTrytes;\n\n      if (trytesString.length === Address.LENGTH_WITH_CHECKSUM) {\n        checksumTrytes = trytesString.substr(Address.LENGTH);\n      }\n\n      return new Address(addressTrytes, checksumTrytes);\n    }\n  }]);\n\n  return Address;\n}();\n/**\r\n * The length for a valid address without checksum (81).\r\n */\n\n\nAddress.LENGTH = 81;\n/**\r\n * The length for an address checksum (9).\r\n */\n\nAddress.LENGTH_CHECKSUM = 9;\n/**\r\n * The length for valid address with checksum (90).\r\n */\n\nAddress.LENGTH_WITH_CHECKSUM = Address.LENGTH + Address.LENGTH_CHECKSUM;\nexports.Address = Address;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-data/dist/data/address.js?");

/***/ }),

/***/ "../iota-pico-data/dist/data/addressSecurity.js":
/*!******************************************************!*\
  !*** ../iota-pico-data/dist/data/addressSecurity.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Represents an enum for the address security values.\r\n */\n\nvar AddressSecurity;\n\n(function (AddressSecurity) {\n  AddressSecurity[AddressSecurity[\"low\"] = 1] = \"low\";\n  AddressSecurity[AddressSecurity[\"medium\"] = 2] = \"medium\";\n  AddressSecurity[AddressSecurity[\"high\"] = 3] = \"high\";\n})(AddressSecurity = exports.AddressSecurity || (exports.AddressSecurity = {}));\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-data/dist/data/addressSecurity.js?");

/***/ }),

/***/ "../iota-pico-data/dist/data/bundle.js":
/*!*********************************************!*\
  !*** ../iota-pico-data/dist/data/bundle.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar dataError_1 = __webpack_require__(/*! ../error/dataError */ \"../iota-pico-data/dist/error/dataError.js\");\n\nvar hash_1 = __webpack_require__(/*! ./hash */ \"../iota-pico-data/dist/data/hash.js\");\n\nvar signatureMessageFragment_1 = __webpack_require__(/*! ./signatureMessageFragment */ \"../iota-pico-data/dist/data/signatureMessageFragment.js\");\n\nvar tag_1 = __webpack_require__(/*! ./tag */ \"../iota-pico-data/dist/data/tag.js\");\n\nvar transaction_1 = __webpack_require__(/*! ./transaction */ \"../iota-pico-data/dist/data/transaction.js\");\n\nvar tryteNumber_1 = __webpack_require__(/*! ./tryteNumber */ \"../iota-pico-data/dist/data/tryteNumber.js\");\n/**\r\n * A class for handling bundles.\r\n */\n\n\nvar Bundle =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * Create a new instance of Bundle.\r\n   */\n  function Bundle() {\n    _classCallCheck(this, Bundle);\n\n    this.transactions = [];\n  }\n  /**\r\n   * Add new transactions to the bundle.\r\n   * @param signatureMessageLength The number of transactions to add.\r\n   * @param address The address for the transactions.\r\n   * @param value The value for the first of the transactions.\r\n   * @param tag The tag to include in the transactions.\r\n   * @param timestamp The timestamp for the transactions.\r\n   */\n\n\n  _createClass(Bundle, [{\n    key: \"addTransactions\",\n    value: function addTransactions(signatureMessageLength, address, value, tag, timestamp) {\n      for (var i = 0; i < signatureMessageLength; i++) {\n        this.transactions.push(transaction_1.Transaction.fromParams(undefined, address, i === 0 ? value : 0, tag, timestamp, undefined, undefined, undefined, undefined, undefined, tag, undefined, undefined, undefined, undefined));\n      }\n    }\n    /**\r\n     * Add signature fragments to the bundle.\r\n     * @param signatureMessageFragments The signature fragments to add to the bundle transactions.\r\n     */\n\n  }, {\n    key: \"addSignatureMessageFragments\",\n    value: function addSignatureMessageFragments(signatureMessageFragments) {\n      if (objectHelper_1.ObjectHelper.isEmpty(signatureMessageFragments)) {\n        throw new dataError_1.DataError(\"The signatureMessageFragments should be an array of SignatureMessageFragments\");\n      }\n\n      for (var i = 0; i < this.transactions.length; i++) {\n        this.transactions[i].signatureMessageFragment = signatureMessageFragments[i] || signatureMessageFragment_1.SignatureMessageFragment.EMPTY;\n        this.transactions[i].trunkTransaction = hash_1.Hash.EMPTY;\n        this.transactions[i].branchTransaction = hash_1.Hash.EMPTY;\n        this.transactions[i].attachmentTimestamp = tryteNumber_1.TryteNumber.EMPTY_9;\n        this.transactions[i].attachmentTimestampLowerBound = tryteNumber_1.TryteNumber.EMPTY_9;\n        this.transactions[i].attachmentTimestampUpperBound = tryteNumber_1.TryteNumber.EMPTY_9;\n        this.transactions[i].nonce = tag_1.Tag.EMPTY;\n      }\n    }\n  }]);\n\n  return Bundle;\n}();\n\nexports.Bundle = Bundle;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-data/dist/data/bundle.js?");

/***/ }),

/***/ "../iota-pico-data/dist/data/hash.js":
/*!*******************************************!*\
  !*** ../iota-pico-data/dist/data/hash.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar dataError_1 = __webpack_require__(/*! ../error/dataError */ \"../iota-pico-data/dist/error/dataError.js\");\n\nvar trytes_1 = __webpack_require__(/*! ./trytes */ \"../iota-pico-data/dist/data/trytes.js\");\n/**\r\n * A class for handling hashes.\r\n */\n\n\nvar Hash =\n/*#__PURE__*/\nfunction () {\n  /* @internal */\n  function Hash(trytes) {\n    _classCallCheck(this, Hash);\n\n    this._trytes = trytes;\n  }\n  /**\r\n   * Create hash from trytes.\r\n   * @param hash The trytes to create the hash from.\r\n   * @returns An instance of Hash.\r\n   */\n\n\n  _createClass(Hash, [{\n    key: \"toTrytes\",\n\n    /**\r\n     * Convert the hash to trytes.\r\n     * @returns Trytes version of the hash.\r\n     */\n    value: function toTrytes() {\n      return this._trytes;\n    }\n    /**\r\n     * Get the string view of the object.\r\n     * @returns string of the trytes.\r\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this._trytes.toString();\n    }\n  }], [{\n    key: \"fromTrytes\",\n    value: function fromTrytes(hash) {\n      if (!objectHelper_1.ObjectHelper.isType(hash, trytes_1.Trytes)) {\n        throw new dataError_1.DataError(\"The hash should be a valid Trytes object\");\n      }\n\n      var length = hash.length();\n\n      if (length !== Hash.LENGTH) {\n        throw new dataError_1.DataError(\"The hash should be \".concat(Hash.LENGTH, \" characters in length\"), {\n          length: length\n        });\n      }\n\n      return new Hash(hash);\n    }\n  }]);\n\n  return Hash;\n}();\n/**\r\n * The length for a valid hash (81).\r\n */\n\n\nHash.LENGTH = 81;\n/**\r\n * An empty hash all 9s.\r\n */\n\nHash.EMPTY = Hash.fromTrytes(trytes_1.Trytes.fromString(\"9\".repeat(Hash.LENGTH)));\nexports.Hash = Hash;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-data/dist/data/hash.js?");

/***/ }),

/***/ "../iota-pico-data/dist/data/input.js":
/*!********************************************!*\
  !*** ../iota-pico-data/dist/data/input.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ \"../iota-pico-core/dist/helpers/numberHelper.js\");\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar dataError_1 = __webpack_require__(/*! ../error/dataError */ \"../iota-pico-data/dist/error/dataError.js\");\n\nvar address_1 = __webpack_require__(/*! ./address */ \"../iota-pico-data/dist/data/address.js\");\n\nvar addressSecurity_1 = __webpack_require__(/*! ./addressSecurity */ \"../iota-pico-data/dist/data/addressSecurity.js\");\n/**\r\n * A class for handling inputs.\r\n */\n\n\nvar Input =\n/*#__PURE__*/\nfunction () {\n  /* @internal */\n  function Input() {\n    _classCallCheck(this, Input);\n  }\n  /**\r\n   * Create instance of input from parameters.\r\n   * @param address The address.\r\n   * @param security The address security.\r\n   * @param keyIndex The key index.\r\n   * @param balance The balance of the address.\r\n   * @return New instance of Input.\r\n   */\n\n\n  _createClass(Input, null, [{\n    key: \"fromParams\",\n    value: function fromParams(address, security, keyIndex, balance) {\n      if (!objectHelper_1.ObjectHelper.isType(address, address_1.Address)) {\n        throw new dataError_1.DataError(\"The address should be a valid Address object\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(security) || security < addressSecurity_1.AddressSecurity.low || security > addressSecurity_1.AddressSecurity.high) {\n        throw new dataError_1.DataError(\"The security should be a number between \".concat(addressSecurity_1.AddressSecurity.low, \" and \").concat(addressSecurity_1.AddressSecurity.high));\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(keyIndex) || keyIndex < 0) {\n        throw new dataError_1.DataError(\"The keyIndex should be a number >= 0\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(balance) || balance < 0) {\n        throw new dataError_1.DataError(\"The balance should be a number >= 0\");\n      }\n\n      var input = new Input();\n      input.address = address;\n      input.security = security;\n      input.keyIndex = keyIndex;\n      input.balance = balance;\n      return input;\n    }\n  }]);\n\n  return Input;\n}();\n\nexports.Input = Input;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-data/dist/data/input.js?");

/***/ }),

/***/ "../iota-pico-data/dist/data/signatureMessageFragment.js":
/*!***************************************************************!*\
  !*** ../iota-pico-data/dist/data/signatureMessageFragment.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar dataError_1 = __webpack_require__(/*! ../error/dataError */ \"../iota-pico-data/dist/error/dataError.js\");\n\nvar trytes_1 = __webpack_require__(/*! ./trytes */ \"../iota-pico-data/dist/data/trytes.js\");\n/**\r\n * A class for handling signature message fragments.\r\n */\n\n\nvar SignatureMessageFragment =\n/*#__PURE__*/\nfunction () {\n  /* @internal */\n  function SignatureMessageFragment(trytes) {\n    _classCallCheck(this, SignatureMessageFragment);\n\n    this._trytes = trytes;\n  }\n  /**\r\n   * Create signature fragment from trytes.\r\n   * @param signatureMessageFragment The trytes to create the signature fragment from.\r\n   * @returns An instance of SignatureMessageFragment.\r\n   */\n\n\n  _createClass(SignatureMessageFragment, [{\n    key: \"toTrytes\",\n\n    /**\r\n     * Convert the signature fragment to trytes.\r\n     * @returns Trytes version of the signature fragment.\r\n     */\n    value: function toTrytes() {\n      return this._trytes;\n    }\n    /**\r\n     * Get the string view of the object.\r\n     * @returns string of the trytes.\r\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this._trytes.toString();\n    }\n  }], [{\n    key: \"fromTrytes\",\n    value: function fromTrytes(signatureMessageFragment) {\n      if (!objectHelper_1.ObjectHelper.isType(signatureMessageFragment, trytes_1.Trytes)) {\n        throw new dataError_1.DataError(\"The signatureMessageFragment should be a valid Trytes object\");\n      }\n\n      var length = signatureMessageFragment.length();\n\n      if (length !== SignatureMessageFragment.LENGTH) {\n        throw new dataError_1.DataError(\"The signatureMessageFragment should be \".concat(SignatureMessageFragment.LENGTH, \" characters in length\"), {\n          length: length\n        });\n      }\n\n      return new SignatureMessageFragment(signatureMessageFragment);\n    }\n  }]);\n\n  return SignatureMessageFragment;\n}();\n/**\r\n * The length of a valid signature message fragment (2187)\r\n */\n\n\nSignatureMessageFragment.LENGTH = 2187;\n/**\r\n * An empty signature message fragment all 9s.\r\n */\n\nSignatureMessageFragment.EMPTY = SignatureMessageFragment.fromTrytes(trytes_1.Trytes.fromString(\"9\".repeat(SignatureMessageFragment.LENGTH)));\nexports.SignatureMessageFragment = SignatureMessageFragment;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-data/dist/data/signatureMessageFragment.js?");

/***/ }),

/***/ "../iota-pico-data/dist/data/tag.js":
/*!******************************************!*\
  !*** ../iota-pico-data/dist/data/tag.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar dataError_1 = __webpack_require__(/*! ../error/dataError */ \"../iota-pico-data/dist/error/dataError.js\");\n\nvar trytes_1 = __webpack_require__(/*! ./trytes */ \"../iota-pico-data/dist/data/trytes.js\");\n/**\r\n * A class for handling tags.\r\n */\n\n\nvar Tag =\n/*#__PURE__*/\nfunction () {\n  /* @internal */\n  function Tag(trytes) {\n    _classCallCheck(this, Tag);\n\n    this._trytes = trytes;\n  }\n  /**\r\n   * Create tag from trytes.\r\n   * @param tag The trytes to create the tag from.\r\n   * @returns An instance of Tag.\r\n   */\n\n\n  _createClass(Tag, [{\n    key: \"toTrytes\",\n\n    /**\r\n     * Convert the tag to trytes.\r\n     * @returns Trytes version of the tag.\r\n     */\n    value: function toTrytes() {\n      return trytes_1.Trytes.fromString(this._trytes);\n    }\n    /**\r\n     * Get the string view of the object.\r\n     * @returns string of the trytes.\r\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this._trytes;\n    }\n  }], [{\n    key: \"fromTrytes\",\n    value: function fromTrytes(tag) {\n      if (!objectHelper_1.ObjectHelper.isType(tag, trytes_1.Trytes)) {\n        throw new dataError_1.DataError(\"The tag should be a valid Trytes object\");\n      }\n\n      var trytesString = tag.toString();\n\n      if (trytesString.length > Tag.LENGTH) {\n        throw new dataError_1.DataError(\"The tag should be at most \".concat(Tag.LENGTH, \" characters in length\"), {\n          length: trytesString.length\n        });\n      }\n\n      while (trytesString.length < Tag.LENGTH) {\n        trytesString += \"9\";\n      }\n\n      return new Tag(trytesString);\n    }\n  }]);\n\n  return Tag;\n}();\n/**\r\n * The length of a valid tag (27).\r\n */\n\n\nTag.LENGTH = 27;\n/**\r\n * An empty tag all 9s.\r\n */\n\nTag.EMPTY = Tag.fromTrytes(trytes_1.Trytes.fromString(\"9\".repeat(Tag.LENGTH)));\nexports.Tag = Tag;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-data/dist/data/tag.js?");

/***/ }),

/***/ "../iota-pico-data/dist/data/transaction.js":
/*!**************************************************!*\
  !*** ../iota-pico-data/dist/data/transaction.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar dataError_1 = __webpack_require__(/*! ../error/dataError */ \"../iota-pico-data/dist/error/dataError.js\");\n\nvar address_1 = __webpack_require__(/*! ./address */ \"../iota-pico-data/dist/data/address.js\");\n\nvar hash_1 = __webpack_require__(/*! ./hash */ \"../iota-pico-data/dist/data/hash.js\");\n\nvar signatureMessageFragment_1 = __webpack_require__(/*! ./signatureMessageFragment */ \"../iota-pico-data/dist/data/signatureMessageFragment.js\");\n\nvar tag_1 = __webpack_require__(/*! ./tag */ \"../iota-pico-data/dist/data/tag.js\");\n\nvar tryteNumber_1 = __webpack_require__(/*! ./tryteNumber */ \"../iota-pico-data/dist/data/tryteNumber.js\");\n\nvar trytes_1 = __webpack_require__(/*! ./trytes */ \"../iota-pico-data/dist/data/trytes.js\");\n/**\r\n * A class for handling transactions.\r\n */\n\n\nvar Transaction =\n/*#__PURE__*/\nfunction () {\n  /* @internal */\n  function Transaction() {\n    _classCallCheck(this, Transaction);\n  }\n  /**\r\n   * Create instance of transaction from parameters.\r\n   * @param signatureMessageFragment The signature message fragment.\r\n   * @param address The address.\r\n   * @param value The value.\r\n   * @param obsoleteTag Obsolete transaction tag.\r\n   * @param timestamp The timestamp.\r\n   * @param currentIndex The current index.\r\n   * @param lastIndex The last index.\r\n   * @param bundle The bundle.\r\n   * @param trunkTransaction The trunk transaction.\r\n   * @param branchTransaction The branch transaction.\r\n   * @param tag The tag.\r\n   * @param attachmentTimestamp The attachment timestamp.\r\n   * @param attachmentTimestampLowerBound The attachment timestamp lower bound.\r\n   * @param attachmentTimestampUpperBound  The attachment timestamp upper bound.\r\n   * @param nonce The nonce.\r\n   * @return New instance of transaction.\r\n   */\n\n\n  _createClass(Transaction, [{\n    key: \"toTrytes\",\n\n    /**\r\n     * Convert the transaction to trytes.\r\n     * @return The transaction as trytes.\r\n     */\n    value: function toTrytes() {\n      return trytes_1.Trytes.fromString(this.toString());\n    }\n    /**\r\n     * Get the string view of the object.\r\n     * @returns string of the trytes.\r\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      if (!objectHelper_1.ObjectHelper.isType(this.signatureMessageFragment, signatureMessageFragment_1.SignatureMessageFragment)) {\n        throw new dataError_1.DataError(\"The signatureMessageFragment must be set to create transaction trytes\", {\n          signatureMessageFragment: this.signatureMessageFragment\n        });\n      }\n\n      if (!objectHelper_1.ObjectHelper.isType(this.address, address_1.Address)) {\n        throw new dataError_1.DataError(\"The address must be set to create transaction trytes\", {\n          address: this.address\n        });\n      }\n\n      if (!objectHelper_1.ObjectHelper.isType(this.obsoleteTag, tag_1.Tag)) {\n        throw new dataError_1.DataError(\"The obsoleteTag must be set to create transaction trytes\", {\n          obsoleteTag: this.obsoleteTag\n        });\n      }\n\n      if (!objectHelper_1.ObjectHelper.isType(this.bundle, hash_1.Hash)) {\n        throw new dataError_1.DataError(\"The bundle must be set to create transaction trytes\", {\n          bundle: this.bundle\n        });\n      }\n\n      if (!objectHelper_1.ObjectHelper.isType(this.trunkTransaction, hash_1.Hash)) {\n        throw new dataError_1.DataError(\"The trunkTransaction must be set to create transaction trytes\", {\n          trunkTransaction: this.trunkTransaction\n        });\n      }\n\n      if (!objectHelper_1.ObjectHelper.isType(this.branchTransaction, hash_1.Hash)) {\n        throw new dataError_1.DataError(\"The branchTransaction must be set to create transaction trytes\", {\n          branchTransaction: this.branchTransaction\n        });\n      }\n\n      if (!objectHelper_1.ObjectHelper.isType(this.nonce, tag_1.Tag)) {\n        throw new dataError_1.DataError(\"The nonce must be set to create transaction trytes\", {\n          nonce: this.nonce\n        });\n      }\n\n      var trytes = this.signatureMessageFragment.toTrytes().toString() + this.address.toTrytes().toString() + (this.value || Transaction.EMPTY_11).toTrytes().toString() + Transaction.CHECK_VALUE + this.obsoleteTag.toTrytes().toString() + (this.timestamp || tryteNumber_1.TryteNumber.EMPTY_9).toTrytes().toString() + (this.currentIndex || tryteNumber_1.TryteNumber.EMPTY_9).toTrytes().toString() + (this.lastIndex || tryteNumber_1.TryteNumber.EMPTY_9).toTrytes().toString() + this.bundle.toTrytes().toString() + this.trunkTransaction.toTrytes().toString() + this.branchTransaction.toTrytes().toString() + (this.tag || this.obsoleteTag).toTrytes().toString() + (this.attachmentTimestamp || tryteNumber_1.TryteNumber.EMPTY_9).toTrytes().toString() + (this.attachmentTimestampLowerBound || tryteNumber_1.TryteNumber.EMPTY_9).toTrytes().toString() + (this.attachmentTimestampUpperBound || tryteNumber_1.TryteNumber.EMPTY_9).toTrytes().toString() + this.nonce.toTrytes().toString();\n      var length = trytes.length;\n\n      if (length !== Transaction.LENGTH) {\n        throw new dataError_1.DataError(\"The trytes must be \".concat(Transaction.LENGTH, \" in length \").concat(length), {\n          length: length\n        });\n      }\n\n      return trytes;\n    }\n  }], [{\n    key: \"fromParams\",\n    value: function fromParams(signatureMessageFragment, address, value, obsoleteTag, timestamp, currentIndex, lastIndex, bundle, trunkTransaction, branchTransaction, tag, attachmentTimestamp, attachmentTimestampLowerBound, attachmentTimestampUpperBound, nonce) {\n      var tx = new Transaction();\n      tx.signatureMessageFragment = signatureMessageFragment;\n      tx.address = address;\n      tx.value = tryteNumber_1.TryteNumber.fromNumber(value, 11);\n      tx.obsoleteTag = obsoleteTag;\n      tx.timestamp = tryteNumber_1.TryteNumber.fromNumber(timestamp);\n      tx.currentIndex = tryteNumber_1.TryteNumber.fromNumber(currentIndex);\n      tx.lastIndex = tryteNumber_1.TryteNumber.fromNumber(lastIndex);\n      tx.bundle = bundle;\n      tx.trunkTransaction = trunkTransaction;\n      tx.branchTransaction = branchTransaction;\n      tx.tag = tag;\n      tx.attachmentTimestamp = tryteNumber_1.TryteNumber.fromNumber(attachmentTimestamp);\n      tx.attachmentTimestampLowerBound = tryteNumber_1.TryteNumber.fromNumber(attachmentTimestampLowerBound);\n      tx.attachmentTimestampUpperBound = tryteNumber_1.TryteNumber.fromNumber(attachmentTimestampUpperBound);\n      tx.nonce = nonce;\n      return tx;\n    }\n    /**\r\n     * Create instance of transaction from trytes.\r\n     * @param trytes The trytes for the this.\r\n     * @returns An instance of this.\r\n     */\n\n  }, {\n    key: \"fromTrytes\",\n    value: function fromTrytes(trytes) {\n      if (!objectHelper_1.ObjectHelper.isType(trytes, trytes_1.Trytes)) {\n        throw new dataError_1.DataError(\"The trytes should be a valid Trytes object\");\n      }\n\n      var length = trytes.length();\n\n      if (length !== Transaction.LENGTH) {\n        throw new dataError_1.DataError(\"The trytes must be \".concat(Transaction.LENGTH, \" in length\"), {\n          length: length\n        });\n      }\n\n      var checkIndexStart = 2279;\n      var checkIndexLength = 16;\n      var check = trytes.sub(checkIndexStart, checkIndexLength).toString();\n\n      if (check !== Transaction.CHECK_VALUE) {\n        throw new dataError_1.DataError(\"The trytes between \".concat(checkIndexStart, \" and \").concat(checkIndexStart + checkIndexLength, \" should be all 9s\"), {\n          check: check\n        });\n      }\n\n      var tx = new Transaction();\n      var startPos = 0;\n      tx.signatureMessageFragment = signatureMessageFragment_1.SignatureMessageFragment.fromTrytes(trytes.sub(startPos, signatureMessageFragment_1.SignatureMessageFragment.LENGTH));\n      startPos += signatureMessageFragment_1.SignatureMessageFragment.LENGTH;\n      tx.address = address_1.Address.fromTrytes(trytes.sub(startPos, address_1.Address.LENGTH));\n      startPos += address_1.Address.LENGTH;\n      tx.value = tryteNumber_1.TryteNumber.fromTrytes(trytes.sub(startPos, 11), 11);\n      startPos += 11;\n      startPos += Transaction.CHECK_VALUE_LENGTH;\n      tx.obsoleteTag = tag_1.Tag.fromTrytes(trytes.sub(startPos, tag_1.Tag.LENGTH));\n      startPos += tag_1.Tag.LENGTH;\n      tx.timestamp = tryteNumber_1.TryteNumber.fromTrytes(trytes.sub(startPos, tryteNumber_1.TryteNumber.LENGTH_9));\n      startPos += tryteNumber_1.TryteNumber.LENGTH_9;\n      tx.currentIndex = tryteNumber_1.TryteNumber.fromTrytes(trytes.sub(startPos, tryteNumber_1.TryteNumber.LENGTH_9));\n      startPos += tryteNumber_1.TryteNumber.LENGTH_9;\n      tx.lastIndex = tryteNumber_1.TryteNumber.fromTrytes(trytes.sub(startPos, tryteNumber_1.TryteNumber.LENGTH_9));\n      startPos += tryteNumber_1.TryteNumber.LENGTH_9;\n      tx.bundle = hash_1.Hash.fromTrytes(trytes.sub(startPos, hash_1.Hash.LENGTH));\n      startPos += hash_1.Hash.LENGTH;\n      tx.trunkTransaction = hash_1.Hash.fromTrytes(trytes.sub(startPos, hash_1.Hash.LENGTH));\n      startPos += hash_1.Hash.LENGTH;\n      tx.branchTransaction = hash_1.Hash.fromTrytes(trytes.sub(startPos, hash_1.Hash.LENGTH));\n      startPos += hash_1.Hash.LENGTH;\n      tx.tag = tag_1.Tag.fromTrytes(trytes.sub(startPos, tag_1.Tag.LENGTH));\n      startPos += tag_1.Tag.LENGTH;\n      tx.attachmentTimestamp = tryteNumber_1.TryteNumber.fromTrytes(trytes.sub(startPos, tryteNumber_1.TryteNumber.LENGTH_9));\n      startPos += tryteNumber_1.TryteNumber.LENGTH_9;\n      tx.attachmentTimestampLowerBound = tryteNumber_1.TryteNumber.fromTrytes(trytes.sub(startPos, tryteNumber_1.TryteNumber.LENGTH_9));\n      startPos += tryteNumber_1.TryteNumber.LENGTH_9;\n      tx.attachmentTimestampUpperBound = tryteNumber_1.TryteNumber.fromTrytes(trytes.sub(startPos, tryteNumber_1.TryteNumber.LENGTH_9));\n      startPos += tryteNumber_1.TryteNumber.LENGTH_9;\n      tx.nonce = tag_1.Tag.fromTrytes(trytes.sub(startPos, tag_1.Tag.LENGTH));\n      return tx;\n    }\n  }]);\n\n  return Transaction;\n}();\n/**\r\n * The length of a valid transaction (2673).\r\n */\n\n\nTransaction.LENGTH = 2673;\n/**\r\n * The length of a valid check value (16).\r\n */\n\nTransaction.CHECK_VALUE_LENGTH = 16;\n/**\r\n * The check value for bundles all 9s.\r\n */\n\nTransaction.CHECK_VALUE = \"9\".repeat(Transaction.CHECK_VALUE_LENGTH);\n/* @internal */\n\nTransaction.EMPTY_11 = tryteNumber_1.TryteNumber.fromNumber(0, 11);\nexports.Transaction = Transaction;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-data/dist/data/transaction.js?");

/***/ }),

/***/ "../iota-pico-data/dist/data/transfer.js":
/*!***********************************************!*\
  !*** ../iota-pico-data/dist/data/transfer.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ \"../iota-pico-core/dist/helpers/numberHelper.js\");\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar dataError_1 = __webpack_require__(/*! ../error/dataError */ \"../iota-pico-data/dist/error/dataError.js\");\n\nvar address_1 = __webpack_require__(/*! ./address */ \"../iota-pico-data/dist/data/address.js\");\n\nvar tag_1 = __webpack_require__(/*! ./tag */ \"../iota-pico-data/dist/data/tag.js\");\n\nvar trytes_1 = __webpack_require__(/*! ./trytes */ \"../iota-pico-data/dist/data/trytes.js\");\n/**\r\n * A class for handling transfers.\r\n */\n\n\nvar Transfer =\n/*#__PURE__*/\nfunction () {\n  /* @internal */\n  function Transfer() {\n    _classCallCheck(this, Transfer);\n  }\n  /**\r\n   * Create instance of transfer from parameters.\r\n   * @param address The address.\r\n   * @param value The value.\r\n   * @param messsage The message for the transfer.\r\n   * @param tag The tag.\r\n   * @return New instance of Transfer.\r\n   */\n\n\n  _createClass(Transfer, null, [{\n    key: \"fromParams\",\n    value: function fromParams(address, value, message, tag) {\n      if (!objectHelper_1.ObjectHelper.isType(address, address_1.Address)) {\n        throw new dataError_1.DataError(\"The address should be a valid Address object\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(value) || value < 0) {\n        throw new dataError_1.DataError(\"The value should be a number >= 0\");\n      }\n\n      if (!objectHelper_1.ObjectHelper.isEmpty(message) && !objectHelper_1.ObjectHelper.isType(message, trytes_1.Trytes)) {\n        throw new dataError_1.DataError(\"The message should be a valid Trytes object\");\n      }\n\n      if (!objectHelper_1.ObjectHelper.isEmpty(tag) && !objectHelper_1.ObjectHelper.isType(tag, tag_1.Tag)) {\n        throw new dataError_1.DataError(\"The tag should be a valid Tag object\");\n      }\n\n      var transfer = new Transfer();\n      transfer.address = address;\n      transfer.value = value;\n      transfer.message = message;\n      transfer.tag = tag;\n      return transfer;\n    }\n  }]);\n\n  return Transfer;\n}();\n\nexports.Transfer = Transfer;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-data/dist/data/transfer.js?");

/***/ }),

/***/ "../iota-pico-data/dist/data/trits.js":
/*!********************************************!*\
  !*** ../iota-pico-data/dist/data/trits.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar arrayHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/arrayHelper */ \"../iota-pico-core/dist/helpers/arrayHelper.js\");\n\nvar numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ \"../iota-pico-core/dist/helpers/numberHelper.js\");\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar dataError_1 = __webpack_require__(/*! ../error/dataError */ \"../iota-pico-data/dist/error/dataError.js\");\n\nvar trytes_1 = __webpack_require__(/*! ./trytes */ \"../iota-pico-data/dist/data/trytes.js\");\n/**\r\n * A class for handling trits.\r\n */\n\n\nvar Trits =\n/*#__PURE__*/\nfunction () {\n  /* @internal */\n  function Trits(trits) {\n    _classCallCheck(this, Trits);\n\n    this._trits = trits;\n  }\n  /**\r\n   * Create instance of trits from Int8Array array.\r\n   * @param value Trytes used to create trits.\r\n   * @returns An instance of Trits.\r\n   */\n\n\n  _createClass(Trits, [{\n    key: \"toArray\",\n\n    /**\r\n     * Get the value of the trits array.\r\n     * @returns Array representation of the trits.\r\n     */\n    value: function toArray() {\n      return this._trits;\n    }\n    /**\r\n     * Get the value of the trits array as a number array.\r\n     * @returns Array representation of the trits.\r\n     */\n\n  }, {\n    key: \"toNumberArray\",\n    value: function toNumberArray() {\n      return Array.from(this._trits);\n    }\n    /**\r\n     * Get the trits as trytes.\r\n     * @returns Instance of Trytes.\r\n     */\n\n  }, {\n    key: \"toTrytes\",\n    value: function toTrytes() {\n      var trytes = \"\";\n\n      for (var i = 0; i < this._trits.length; i += 3) {\n        // Iterate over all possible tryte values to find correct trit representation\n        for (var j = 0; j < trytes_1.Trytes.ALPHABET.length; j++) {\n          if (Trits.TRYTES_TRITS[j][0] === this._trits[i] && Trits.TRYTES_TRITS[j][1] === this._trits[i + 1] && Trits.TRYTES_TRITS[j][2] === this._trits[i + 2]) {\n            trytes += trytes_1.Trytes.ALPHABET.charAt(j);\n            break;\n          }\n        }\n      }\n\n      return trytes_1.Trytes.fromString(trytes);\n    }\n    /**\r\n     * Get the trits as a number.\r\n     * @returns The trits converted to a number.\r\n     */\n\n  }, {\n    key: \"toNumber\",\n    value: function toNumber() {\n      var returnValue = 0;\n\n      for (var i = this._trits.length - 1; i >= 0; i--) {\n        returnValue = returnValue * 3 + this._trits[i];\n      }\n\n      return returnValue;\n    }\n    /**\r\n     * What is the length of the trits.\r\n     * @returns Length of the trits.\r\n     */\n\n  }, {\n    key: \"length\",\n    value: function length() {\n      return this._trits.length;\n    }\n    /**\r\n     * Get a sub of the trits.\r\n     * @param start The start position to get the sub.\r\n     * @param length The length of the sub.\r\n     * @returns The trits sub.\r\n     */\n\n  }, {\n    key: \"sub\",\n    value: function sub(start, length) {\n      if (!numberHelper_1.NumberHelper.isInteger(start) || start < 0) {\n        throw new dataError_1.DataError(\"The start must be a number >= 0\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(length) || start + length > this._trits.length) {\n        throw new dataError_1.DataError(\"The start + length must <= \".concat(this._trits.length));\n      }\n\n      return Trits.fromArray(this._trits.slice(start, start + length));\n    }\n  }], [{\n    key: \"fromArray\",\n    value: function fromArray(value) {\n      if (!objectHelper_1.ObjectHelper.isType(value, Int8Array)) {\n        throw new dataError_1.DataError(\"The value does not contain valid trits\");\n      }\n\n      return new Trits(value);\n    }\n    /**\r\n     * Create instance of trits from number array.\r\n     * @param value Trytes used to create trits.\r\n     * @returns An instance of Trits.\r\n     */\n\n  }, {\n    key: \"fromNumberArray\",\n    value: function fromNumberArray(value) {\n      if (!arrayHelper_1.ArrayHelper.isTyped(value, Number)) {\n        throw new dataError_1.DataError(\"The value does not contain valid trits\");\n      }\n\n      return new Trits(new Int8Array(value));\n    }\n    /**\r\n     * Create instance of trits from trytes.\r\n     * @param value Trytes used to create trits.\r\n     * @returns An instance of Trits.\r\n     */\n\n  }, {\n    key: \"fromTrytes\",\n    value: function fromTrytes(value) {\n      if (!objectHelper_1.ObjectHelper.isType(value, trytes_1.Trytes)) {\n        throw new dataError_1.DataError(\"The value should be a valid Trytes object\");\n      }\n\n      var trytesString = value.toString();\n      var trits = new Int8Array(trytesString.length * 3);\n\n      for (var i = 0; i < trytesString.length; i++) {\n        var idx = trytes_1.Trytes.ALPHABET.indexOf(trytesString.charAt(i));\n        trits[i * 3] = Trits.TRYTES_TRITS[idx][0];\n        trits[i * 3 + 1] = Trits.TRYTES_TRITS[idx][1];\n        trits[i * 3 + 2] = Trits.TRYTES_TRITS[idx][2];\n      }\n\n      return new Trits(trits);\n    }\n    /**\r\n     * Create instance of trits from number\r\n     * @param value Number used to create trits.\r\n     * @returns An instance of Trits.\r\n     */\n\n  }, {\n    key: \"fromNumber\",\n    value: function fromNumber(value) {\n      if (!numberHelper_1.NumberHelper.isInteger(value)) {\n        throw new dataError_1.DataError(\"The value is not an integer\");\n      }\n\n      var trits = [];\n      var absoluteValue = value < 0 ? -value : value;\n\n      while (absoluteValue > 0) {\n        var remainder = absoluteValue % 3;\n        absoluteValue = Math.floor(absoluteValue / 3);\n\n        if (remainder > 1) {\n          remainder = -1;\n          absoluteValue++;\n        }\n\n        trits[trits.length] = remainder;\n      }\n\n      if (value < 0) {\n        for (var i = 0; i < trits.length; i++) {\n          trits[i] = -trits[i];\n        }\n      }\n\n      return new Trits(new Int8Array(trits));\n    }\n    /**\r\n     * Add two trits together.\r\n     * @param first The first trit.\r\n     * @param second The second trit.\r\n     * @return New trit which is the addition of the a + b.\r\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(first, second) {\n      if (!objectHelper_1.ObjectHelper.isType(first, Trits)) {\n        throw new dataError_1.DataError(\"The first should be a valid Trits object\");\n      }\n\n      if (!objectHelper_1.ObjectHelper.isType(second, Trits)) {\n        throw new dataError_1.DataError(\"The seconds should be a valid Trits object\");\n      }\n\n      var out = new Int8Array(Math.max(first._trits.length, second._trits.length));\n      var carry = 0;\n      var iA;\n      var iB;\n\n      for (var i = 0; i < out.length; i++) {\n        iA = i < first._trits.length ? first._trits[i] : 0;\n        iB = i < second._trits.length ? second._trits[i] : 0;\n        var fA = Trits.fullAdd(iA, iB, carry);\n        out[i] = fA[0];\n        carry = fA[1];\n      }\n\n      return Trits.fromArray(out);\n    }\n    /* @internal */\n\n  }, {\n    key: \"fullAdd\",\n    value: function fullAdd(a, b, c) {\n      var sA = Trits.sum(a, b);\n      var cA = Trits.cons(a, b);\n      var cB = Trits.cons(sA, c);\n      var cOut = Trits.any(cA, cB);\n      var sOUt = Trits.sum(sA, c);\n      return new Int8Array([sOUt, cOut]);\n    }\n    /* @internal */\n\n  }, {\n    key: \"sum\",\n    value: function sum(a, b) {\n      var s = a + b;\n\n      switch (s) {\n        case 2:\n          return -1;\n\n        case -2:\n          return 1;\n\n        default:\n          return s;\n      }\n    }\n    /* @internal */\n\n  }, {\n    key: \"cons\",\n    value: function cons(a, b) {\n      if (a === b) {\n        return a;\n      }\n\n      return 0;\n    }\n    /* @internal */\n\n  }, {\n    key: \"any\",\n    value: function any(a, b) {\n      var s = a + b;\n\n      if (s > 0) {\n        return 1;\n      } else if (s < 0) {\n        return -1;\n      }\n\n      return 0;\n    }\n  }]);\n\n  return Trits;\n}();\n/* @internal */\n\n\nTrits.TRYTES_TRITS = [new Int8Array([0, 0, 0]), new Int8Array([1, 0, 0]), new Int8Array([-1, 1, 0]), new Int8Array([0, 1, 0]), new Int8Array([1, 1, 0]), new Int8Array([-1, -1, 1]), new Int8Array([0, -1, 1]), new Int8Array([1, -1, 1]), new Int8Array([-1, 0, 1]), new Int8Array([0, 0, 1]), new Int8Array([1, 0, 1]), new Int8Array([-1, 1, 1]), new Int8Array([0, 1, 1]), new Int8Array([1, 1, 1]), new Int8Array([-1, -1, -1]), new Int8Array([0, -1, -1]), new Int8Array([1, -1, -1]), new Int8Array([-1, 0, -1]), new Int8Array([0, 0, -1]), new Int8Array([1, 0, -1]), new Int8Array([-1, 1, -1]), new Int8Array([0, 1, -1]), new Int8Array([1, 1, -1]), new Int8Array([-1, -1, 0]), new Int8Array([0, -1, 0]), new Int8Array([1, -1, 0]), new Int8Array([-1, 0, 0])];\nexports.Trits = Trits;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-data/dist/data/trits.js?");

/***/ }),

/***/ "../iota-pico-data/dist/data/tryteNumber.js":
/*!**************************************************!*\
  !*** ../iota-pico-data/dist/data/tryteNumber.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ \"../iota-pico-core/dist/helpers/numberHelper.js\");\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar dataError_1 = __webpack_require__(/*! ../error/dataError */ \"../iota-pico-data/dist/error/dataError.js\");\n\nvar trits_1 = __webpack_require__(/*! ./trits */ \"../iota-pico-data/dist/data/trits.js\");\n\nvar trytes_1 = __webpack_require__(/*! ./trytes */ \"../iota-pico-data/dist/data/trytes.js\");\n/**\r\n * A class for handling tryte number.\r\n */\n\n\nvar TryteNumber =\n/*#__PURE__*/\nfunction () {\n  /* @internal */\n  function TryteNumber(trytes) {\n    _classCallCheck(this, TryteNumber);\n\n    this._trytes = trytes;\n  }\n  /**\r\n   * Create tryte number from number.\r\n   * @param value The number value to create the object from.\r\n   * @param length The tryte length to pad the number with.\r\n   * @returns An instance of TryteNumber.\r\n   */\n\n\n  _createClass(TryteNumber, [{\n    key: \"toTrytes\",\n\n    /**\r\n     * Convert the tryte number to trytes.\r\n     * @returns Trytes version of the tryte number.\r\n     */\n    value: function toTrytes() {\n      return trytes_1.Trytes.fromString(this._trytes);\n    }\n    /**\r\n     * Convert the tryte number to number.\r\n     * @returns number value of the tryte number.\r\n     */\n\n  }, {\n    key: \"toNumber\",\n    value: function toNumber() {\n      return trits_1.Trits.fromTrytes(trytes_1.Trytes.fromString(this._trytes)).toNumber();\n    }\n    /**\r\n     * Get the string view of the object.\r\n     * @returns string of the trytes.\r\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.toNumber().toString();\n    }\n    /**\r\n     * Get the value of the object.\r\n     * @returns string of the trytes.\r\n     */\n\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      return this.toNumber();\n    }\n  }], [{\n    key: \"fromNumber\",\n    value: function fromNumber(value) {\n      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TryteNumber.LENGTH_9;\n      var trytes;\n\n      if (!numberHelper_1.NumberHelper.isInteger(length) || length <= 0) {\n        throw new dataError_1.DataError(\"The length should be a number > 0\", {\n          length: length\n        });\n      }\n\n      if (objectHelper_1.ObjectHelper.isEmpty(value)) {\n        trytes = \"9\".repeat(length);\n      } else {\n        if (!numberHelper_1.NumberHelper.isInteger(value)) {\n          throw new dataError_1.DataError(\"The value is not an integer\", {\n            value: value\n          });\n        }\n\n        var trits = trits_1.Trits.fromNumber(value).toNumberArray();\n\n        while (trits.length < length * 3) {\n          trits.push(0);\n        }\n\n        trytes = trits_1.Trits.fromNumberArray(trits).toTrytes().toString();\n      }\n\n      return new TryteNumber(trytes);\n    }\n    /**\r\n     * Create tryte number from trytes.\r\n     * @param value The number value to create the object from.\r\n     * @param length The tryte length to pad the number with.\r\n     * @returns An instance of TryteNumber.\r\n     */\n\n  }, {\n    key: \"fromTrytes\",\n    value: function fromTrytes(value) {\n      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TryteNumber.LENGTH_9;\n\n      if (!objectHelper_1.ObjectHelper.isType(value, trytes_1.Trytes)) {\n        throw new dataError_1.DataError(\"The value should be a valid Trytes object\");\n      }\n\n      var tryteString = value.toString();\n\n      if (!numberHelper_1.NumberHelper.isInteger(length) || length <= 0) {\n        throw new dataError_1.DataError(\"The length should be a number > 0\", {\n          length: length\n        });\n      }\n\n      if (tryteString.length > length) {\n        throw new dataError_1.DataError(\"The value contains too many characters\", {\n          length: tryteString.length\n        });\n      }\n\n      while (tryteString.length < length) {\n        tryteString += \"9\";\n      }\n\n      return new TryteNumber(tryteString);\n    }\n  }]);\n\n  return TryteNumber;\n}();\n/**\r\n * Length of a number that uses 9 trytes.\r\n */\n\n\nTryteNumber.LENGTH_9 = 9;\n/**\r\n * An emnpty 9 length tryte number.\r\n */\n\nTryteNumber.EMPTY_9 = TryteNumber.fromNumber(0, TryteNumber.LENGTH_9);\nexports.TryteNumber = TryteNumber;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-data/dist/data/tryteNumber.js?");

/***/ }),

/***/ "../iota-pico-data/dist/data/trytes.js":
/*!*********************************************!*\
  !*** ../iota-pico-data/dist/data/trytes.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ \"../iota-pico-core/dist/helpers/numberHelper.js\");\n\nvar stringHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/stringHelper */ \"../iota-pico-core/dist/helpers/stringHelper.js\");\n\nvar dataError_1 = __webpack_require__(/*! ../error/dataError */ \"../iota-pico-data/dist/error/dataError.js\");\n/**\r\n * A class for handling trytes.\r\n */\n\n\nvar Trytes =\n/*#__PURE__*/\nfunction () {\n  /* @internal */\n  function Trytes(trytes) {\n    _classCallCheck(this, Trytes);\n\n    this._trytes = trytes;\n  }\n  /**\r\n   * Create trytes from a string.\r\n   * @param value A string to create the trytes from.\r\n   * @param length An optional validation length for the trytes, 0 means ignore length.\r\n   * @returns An instance of Trytes.\r\n   */\n\n\n  _createClass(Trytes, [{\n    key: \"toString\",\n\n    /**\r\n     * Convert the trytes to a string.\r\n     * @returns String representation of the trytes.\r\n     */\n    value: function toString() {\n      return this._trytes;\n    }\n    /**\r\n     * Get the length of the trytes.\r\n     * @returns The length of the trytes.\r\n     */\n\n  }, {\n    key: \"length\",\n    value: function length() {\n      return this._trytes.length;\n    }\n    /**\r\n     * Get a sub of the trytes.\r\n     * @param start The start position to get the sub.\r\n     * @param length The length of the sub.\r\n     * @returns The trytes sub.\r\n     */\n\n  }, {\n    key: \"sub\",\n    value: function sub(start, length) {\n      if (!numberHelper_1.NumberHelper.isInteger(start) || start < 0) {\n        throw new dataError_1.DataError(\"The start must be a number >= 0\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(length) || start + length > this._trytes.length) {\n        throw new dataError_1.DataError(\"The start + length must <= \".concat(this._trytes.length));\n      }\n\n      return Trytes.fromString(this._trytes.substr(start, length));\n    }\n  }], [{\n    key: \"fromString\",\n    value: function fromString(value) {\n      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n      if (!stringHelper_1.StringHelper.isString(value)) {\n        throw new dataError_1.DataError(\"The value must be a non empty string\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(length) || length < 0) {\n        throw new dataError_1.DataError(\"The length must be >= 0\");\n      }\n\n      if (!Trytes.isValid(value, length)) {\n        throw new dataError_1.DataError(\"The value and length do not contain valid trytes\", {\n          value: value,\n          length: length\n        });\n      }\n\n      return new Trytes(value);\n    }\n    /**\r\n     * Does the value contain valid trytes.\r\n     * @param value A string to validate as trytes.\r\n     * @param length An optional validation length for the trytes, 0 means ignore length.\r\n     * @returns True if the input was valid trytes.\r\n     */\n\n  }, {\n    key: \"isValid\",\n    value: function isValid(value) {\n      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n      if (!stringHelper_1.StringHelper.isString(value)) {\n        return false;\n      } else {\n        return new RegExp(\"^[9A-Z]{\".concat(length ? length : \"0,\", \"}$\")).test(value);\n      }\n    }\n  }]);\n\n  return Trytes;\n}();\n/**\r\n * All the characters that can be used in trytes.\r\n */\n\n\nTrytes.ALPHABET = \"9ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nexports.Trytes = Trytes;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-data/dist/data/trytes.js?");

/***/ }),

/***/ "../iota-pico-data/dist/error/dataError.js":
/*!*************************************************!*\
  !*** ../iota-pico-data/dist/error/dataError.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar coreError_1 = __webpack_require__(/*! @iota-pico/core/dist/error/coreError */ \"../iota-pico-core/dist/error/coreError.js\");\n/**\r\n * A data implementation of an error.\r\n */\n\n\nvar DataError =\n/*#__PURE__*/\nfunction (_coreError_1$CoreErro) {\n  _inherits(DataError, _coreError_1$CoreErro);\n\n  function DataError() {\n    _classCallCheck(this, DataError);\n\n    return _possibleConstructorReturn(this, (DataError.__proto__ || Object.getPrototypeOf(DataError)).apply(this, arguments));\n  }\n\n  return DataError;\n}(coreError_1.CoreError);\n\nexports.DataError = DataError;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-data/dist/error/dataError.js?");

/***/ }),

/***/ "../iota-pico-data/dist/index.js":
/*!***************************************!*\
  !*** ../iota-pico-data/dist/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function __export(m) {\n  for (var p in m) {\n    if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n  }\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Combined index of all the modules.\r\n */\n\n__export(__webpack_require__(/*! ./converters/asciiTrytesConverter */ \"../iota-pico-data/dist/converters/asciiTrytesConverter.js\"));\n\n__export(__webpack_require__(/*! ./converters/objectTrytesConverter */ \"../iota-pico-data/dist/converters/objectTrytesConverter.js\"));\n\n__export(__webpack_require__(/*! ./data/address */ \"../iota-pico-data/dist/data/address.js\"));\n\n__export(__webpack_require__(/*! ./data/addressSecurity */ \"../iota-pico-data/dist/data/addressSecurity.js\"));\n\n__export(__webpack_require__(/*! ./data/bundle */ \"../iota-pico-data/dist/data/bundle.js\"));\n\n__export(__webpack_require__(/*! ./data/hash */ \"../iota-pico-data/dist/data/hash.js\"));\n\n__export(__webpack_require__(/*! ./data/input */ \"../iota-pico-data/dist/data/input.js\"));\n\n__export(__webpack_require__(/*! ./data/signatureMessageFragment */ \"../iota-pico-data/dist/data/signatureMessageFragment.js\"));\n\n__export(__webpack_require__(/*! ./data/tag */ \"../iota-pico-data/dist/data/tag.js\"));\n\n__export(__webpack_require__(/*! ./data/transaction */ \"../iota-pico-data/dist/data/transaction.js\"));\n\n__export(__webpack_require__(/*! ./data/transfer */ \"../iota-pico-data/dist/data/transfer.js\"));\n\n__export(__webpack_require__(/*! ./data/trits */ \"../iota-pico-data/dist/data/trits.js\"));\n\n__export(__webpack_require__(/*! ./data/tryteNumber */ \"../iota-pico-data/dist/data/tryteNumber.js\"));\n\n__export(__webpack_require__(/*! ./data/trytes */ \"../iota-pico-data/dist/data/trytes.js\"));\n\n__export(__webpack_require__(/*! ./error/dataError */ \"../iota-pico-data/dist/error/dataError.js\"));\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-data/dist/index.js?");

/***/ }),

/***/ "../iota-pico-pal-nodejs/dist/index.js":
/*!*********************************************!*\
  !*** ../iota-pico-pal-nodejs/dist/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function __export(m) {\n  for (var p in m) {\n    if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n  }\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Combined index of all the modules.\r\n */\n\n__export(__webpack_require__(/*! ./pal */ \"../iota-pico-pal-nodejs/dist/pal.js\"));\n\n__export(__webpack_require__(/*! ./network/networkClient */ \"../iota-pico-pal-nodejs/dist/network/networkClient.js\"));\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pal-nodejs/dist/index.js?");

/***/ }),

/***/ "../iota-pico-pal-nodejs/dist/network/networkClient.js":
/*!*************************************************************!*\
  !*** ../iota-pico-pal-nodejs/dist/network/networkClient.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ \"../iota-pico-pal-nodejs/node_modules/@babel/runtime/regenerator/index.js\");\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _next(value) { step(\"next\", value); } function _throw(err) { step(\"throw\", err); } _next(); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar coreError_1 = __webpack_require__(/*! @iota-pico/core/dist/error/coreError */ \"../iota-pico-core/dist/error/coreError.js\");\n\nvar numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ \"../iota-pico-core/dist/helpers/numberHelper.js\");\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar stringHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/stringHelper */ \"../iota-pico-core/dist/helpers/stringHelper.js\");\n\nvar nullLogger_1 = __webpack_require__(/*! @iota-pico/core/dist/loggers/nullLogger */ \"../iota-pico-core/dist/loggers/nullLogger.js\");\n\nvar http = __importStar(__webpack_require__(/*! http */ \"http\"));\n\nvar https = __importStar(__webpack_require__(/*! https */ \"https\"));\n/**\r\n * Implementation of a node client for use in NodeJS.\r\n */\n\n\nvar NetworkClient =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * Create an instance of NetworkClient.\r\n   * @param networkEndPoint The endpoint to use for the client.\r\n   * @param logger Logger to send communication info to.\r\n   * @param timeoutMs The timeout in ms before aborting.\r\n   */\n  function NetworkClient(networkEndPoint, logger) {\n    var timeoutMs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var httpClientRequest = arguments.length > 3 ? arguments[3] : undefined;\n\n    _classCallCheck(this, NetworkClient);\n\n    if (objectHelper_1.ObjectHelper.isEmpty(networkEndPoint)) {\n      throw new coreError_1.CoreError(\"The networkEndPoint must be defined\");\n    }\n\n    if (!numberHelper_1.NumberHelper.isInteger(timeoutMs) || timeoutMs < 0) {\n      throw new coreError_1.CoreError(\"The timeoutMs must be >= 0\");\n    }\n\n    this._networkEndPoint = networkEndPoint;\n    this._timeoutMs = timeoutMs;\n    this._logger = logger || new nullLogger_1.NullLogger();\n    this._httpClientRequest = httpClientRequest || (networkEndPoint.getProtocol() === \"http\" ? http.request : https.request);\n\n    this._logger.banner(\"Network Client\", {\n      endPoint: this._networkEndPoint\n    });\n  }\n  /**\r\n   * Get data asynchronously.\r\n   * @param additionalPath An additional path append to the endpoint path.\r\n   * @param additionalHeaders Extra headers to send with the request.\r\n   * @returns Promise which resolves to the object returned or rejects with error.\r\n   */\n\n\n  _createClass(NetworkClient, [{\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(additionalPath, additionalHeaders) {\n        var resp;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this._logger.info(\"===> GET Send\");\n\n                _context.next = 3;\n                return this.doRequest(\"GET\", undefined, additionalPath, additionalHeaders);\n\n              case 3:\n                resp = _context.sent;\n\n                this._logger.info(\"<=== GET Received\", resp);\n\n                return _context.abrupt(\"return\", resp);\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      return function get(_x, _x2) {\n        return _get.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Post data asynchronously.\r\n     * @param additionalPath An additional path append to the endpoint path.\r\n     * @param data The data to send.\r\n     * @param additionalHeaders Extra headers to send with the request.\r\n     * @returns Promise which resolves to the object returned or rejects with error.\r\n     */\n\n  }, {\n    key: \"post\",\n    value: function () {\n      var _post = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(data, additionalPath, additionalHeaders) {\n        var resp;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                this._logger.info(\"===> POST Send\", data);\n\n                _context2.next = 3;\n                return this.doRequest(\"POST\", data, additionalPath, additionalHeaders);\n\n              case 3:\n                resp = _context2.sent;\n\n                this._logger.info(\"<=== POST Received\", resp);\n\n                return _context2.abrupt(\"return\", resp);\n\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      return function post(_x3, _x4, _x5) {\n        return _post.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Get data as JSON asynchronously.\r\n     * @typeparam U The generic type for the returned object.\r\n     * @param additionalPath An additional path append to the endpoint path.\r\n     * @param additionalHeaders Extra headers to send with the request.\r\n     * @returns Promise which resolves to the object returned or rejects with error.\r\n     */\n\n  }, {\n    key: \"getJson\",\n    value: function () {\n      var _getJson = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3(additionalPath, additionalHeaders) {\n        var _this = this;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                this._logger.info(\"===> GET Send\");\n\n                return _context3.abrupt(\"return\", this.doRequest(\"GET\", undefined, additionalPath, additionalHeaders).then(function (responseData) {\n                  try {\n                    var response = JSON.parse(responseData);\n\n                    _this._logger.info(\"===> GET Received\", response);\n\n                    return response;\n                  } catch (err) {\n                    _this._logger.info(\"===> GET Parse Failed\", responseData);\n\n                    throw new coreError_1.CoreError(\"Failed GET request, unable to parse response\", {\n                      endPoint: _this._networkEndPoint.getUri(),\n                      response: responseData\n                    });\n                  }\n                }));\n\n              case 2:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      return function getJson(_x6, _x7) {\n        return _getJson.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Post data as JSON asynchronously.\r\n     * @typeparam T The generic type for the object to send.\r\n     * @typeparam U The generic type for the returned object.\r\n     * @param data The data to send.\r\n     * @param additionalPath An additional path append to the endpoint path.\r\n     * @param additionalHeaders Extra headers to send with the request.\r\n     * @returns Promise which resolves to the object returned or rejects with error.\r\n     */\n\n  }, {\n    key: \"postJson\",\n    value: function () {\n      var _postJson = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee4(data, additionalPath, additionalHeaders) {\n        var _this2 = this;\n\n        var headers;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                this._logger.info(\"===> POST Send\");\n\n                headers = additionalHeaders || {};\n                headers[\"Content-Type\"] = \"application/json\";\n                return _context4.abrupt(\"return\", this.doRequest(\"POST\", JSON.stringify(data), additionalPath, headers).then(function (responseData) {\n                  try {\n                    var response = JSON.parse(responseData);\n\n                    _this2._logger.info(\"===> POST Received\", response);\n\n                    return response;\n                  } catch (err) {\n                    _this2._logger.info(\"===> GET Parse Failed\", responseData);\n\n                    throw new coreError_1.CoreError(\"Failed POST request, unable to parse response\", {\n                      endPoint: _this2._networkEndPoint.getUri(),\n                      response: responseData\n                    });\n                  }\n                }));\n\n              case 4:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      return function postJson(_x8, _x9, _x10) {\n        return _postJson.apply(this, arguments);\n      };\n    }()\n    /* @internal */\n\n  }, {\n    key: \"doRequest\",\n    value: function () {\n      var _doRequest = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee5(method, data, additionalPath, additionalHeaders) {\n        var _this3 = this;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                return _context5.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  var headers = additionalHeaders || {};\n\n                  var uri = _this3._networkEndPoint.getUri();\n\n                  var path = _this3._networkEndPoint.getRootPath();\n\n                  if (!stringHelper_1.StringHelper.isEmpty(additionalPath)) {\n                    var stripped = \"/\".concat(additionalPath.replace(/^\\/*/, \"\"));\n                    path += stripped;\n                    uri += stripped;\n                  }\n\n                  var options = {\n                    protocol: \"\".concat(_this3._networkEndPoint.getProtocol(), \":\"),\n                    hostname: _this3._networkEndPoint.getHost(),\n                    port: _this3._networkEndPoint.getPort(),\n                    path: path,\n                    method: method,\n                    headers: headers,\n                    timeout: _this3._timeoutMs > 0 ? _this3._timeoutMs : undefined\n                  };\n\n                  var req = _this3._httpClientRequest(options, function (res) {\n                    var responseData = \"\";\n                    res.setEncoding(\"utf8\");\n                    res.on(\"data\", function (responseBody) {\n                      responseData += responseBody;\n                    });\n                    res.on(\"end\", function () {\n                      if (res.statusCode === 200) {\n                        _this3._logger.info(\"<=== Received\", {\n                          data: responseData\n                        });\n\n                        resolve(responseData);\n                      } else {\n                        _this3._logger.info(\"<=== Received Fail\", {\n                          code: res.statusCode,\n                          data: responseData\n                        });\n\n                        reject(new coreError_1.CoreError(\"Failed \".concat(method, \" request\"), {\n                          endPoint: uri,\n                          errorResponseCode: res.statusCode,\n                          errorResponse: responseData || res.statusMessage\n                        }));\n                      }\n                    });\n                  });\n\n                  req.on(\"error\", function (err) {\n                    _this3._logger.error(\"<=== Errored\");\n\n                    reject(new coreError_1.CoreError(\"Failed \".concat(method, \" request\"), {\n                      endPoint: uri,\n                      errorResponse: err\n                    }));\n                  });\n                  req.on(\"timeout\", function (err) {\n                    _this3._logger.error(\"<=== Timed Out\");\n\n                    reject(new coreError_1.CoreError(\"Failed \".concat(method, \" request, timed out\"), {\n                      endPoint: uri\n                    }));\n                  });\n\n                  if (!objectHelper_1.ObjectHelper.isEmpty(data)) {\n                    req.write(data);\n                  }\n\n                  req.end();\n                }));\n\n              case 1:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      return function doRequest(_x11, _x12, _x13, _x14) {\n        return _doRequest.apply(this, arguments);\n      };\n    }()\n  }]);\n\n  return NetworkClient;\n}();\n\nexports.NetworkClient = NetworkClient;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pal-nodejs/dist/network/networkClient.js?");

/***/ }),

/***/ "../iota-pico-pal-nodejs/dist/pal.js":
/*!*******************************************!*\
  !*** ../iota-pico-pal-nodejs/dist/pal.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ \"../iota-pico-pal-nodejs/node_modules/@babel/runtime/regenerator/index.js\");\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _next(value) { step(\"next\", value); } function _throw(err) { step(\"throw\", err); } _next(); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar networkClientFactory_1 = __webpack_require__(/*! @iota-pico/core/dist/factories/networkClientFactory */ \"../iota-pico-core/dist/factories/networkClientFactory.js\");\n\nvar networkClient_1 = __webpack_require__(/*! ./network/networkClient */ \"../iota-pico-pal-nodejs/dist/network/networkClient.js\");\n/**\r\n * Platform abstraction layer for NodeJS.\r\n */\n\n\nvar PAL =\n/*#__PURE__*/\nfunction () {\n  function PAL() {\n    _classCallCheck(this, PAL);\n  }\n\n  _createClass(PAL, null, [{\n    key: \"initialize\",\n\n    /**\r\n     * Perform any initialization for the PAL.\r\n     */\n    value: function () {\n      var _initialize = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!PAL._isInitialized) {\n                  PAL._isInitialized = true;\n                  networkClientFactory_1.NetworkClientFactory.instance().register(\"default\", function (networkEndpoint) {\n                    return new networkClient_1.NetworkClient(networkEndpoint);\n                  });\n                }\n\n                return _context.abrupt(\"return\", Promise.resolve());\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      return function initialize() {\n        return _initialize.apply(this, arguments);\n      };\n    }()\n  }]);\n\n  return PAL;\n}();\n/* @internal */\n\n\nPAL._isInitialized = false;\nexports.PAL = PAL;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pal-nodejs/dist/pal.js?");

/***/ }),

/***/ "../iota-pico-pal-nodejs/node_modules/@babel/runtime/regenerator/index.js":
/*!********************************************************************************!*\
  !*** ../iota-pico-pal-nodejs/node_modules/@babel/runtime/regenerator/index.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! regenerator-runtime */ \"../iota-pico-pal-nodejs/node_modules/regenerator-runtime/runtime-module.js\");\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pal-nodejs/node_modules/@babel/runtime/regenerator/index.js?");

/***/ }),

/***/ "../iota-pico-pal-nodejs/node_modules/regenerator-runtime/runtime-module.js":
/*!**********************************************************************************!*\
  !*** ../iota-pico-pal-nodejs/node_modules/regenerator-runtime/runtime-module.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\nvar g = (function() { return this })() || Function(\"return this\")();\n\n// Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\nvar hadRuntime = g.regeneratorRuntime &&\n  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;\n\n// Save the old regeneratorRuntime in case it needs to be restored later.\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\n// Force reevalutation of runtime.js.\ng.regeneratorRuntime = undefined;\n\nmodule.exports = __webpack_require__(/*! ./runtime */ \"../iota-pico-pal-nodejs/node_modules/regenerator-runtime/runtime.js\");\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch(e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pal-nodejs/node_modules/regenerator-runtime/runtime-module.js?");

/***/ }),

/***/ "../iota-pico-pal-nodejs/node_modules/regenerator-runtime/runtime.js":
/*!***************************************************************************!*\
  !*** ../iota-pico-pal-nodejs/node_modules/regenerator-runtime/runtime.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // In sloppy mode, unbound `this` refers to the global object, fallback to\n  // Function constructor if we're in global strict mode. That is sadly a form\n  // of indirect eval which violates Content Security Policy.\n  (function() { return this })() || Function(\"return this\")()\n);\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pal-nodejs/node_modules/regenerator-runtime/runtime.js?");

/***/ }),

/***/ "../iota-pico-pow-box/dist/index.js":
/*!******************************************!*\
  !*** ../iota-pico-pow-box/dist/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function __export(m) {\n  for (var p in m) {\n    if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n  }\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Combined index of all the modules.\r\n */\n\n__export(__webpack_require__(/*! ./proofOfWorkBox */ \"../iota-pico-pow-box/dist/proofOfWorkBox.js\"));\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-box/dist/index.js?");

/***/ }),

/***/ "../iota-pico-pow-box/dist/proofOfWorkBox.js":
/*!***************************************************!*\
  !*** ../iota-pico-pow-box/dist/proofOfWorkBox.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ \"../iota-pico-pow-box/node_modules/@babel/runtime/regenerator/index.js\");\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _next(value) { step(\"next\", value); } function _throw(err) { step(\"throw\", err); } _next(); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar arrayHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/arrayHelper */ \"../iota-pico-core/dist/helpers/arrayHelper.js\");\n\nvar numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ \"../iota-pico-core/dist/helpers/numberHelper.js\");\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar stringHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/stringHelper */ \"../iota-pico-core/dist/helpers/stringHelper.js\");\n\nvar cryptoError_1 = __webpack_require__(/*! @iota-pico/crypto/dist/error/cryptoError */ \"../iota-pico-crypto/dist/error/cryptoError.js\");\n\nvar hash_1 = __webpack_require__(/*! @iota-pico/data/dist/data/hash */ \"../iota-pico-data/dist/data/hash.js\");\n\nvar trytes_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trytes */ \"../iota-pico-data/dist/data/trytes.js\");\n/**\r\n * ProofOfWork implementation using Remote PowBox.\r\n */\n\n\nvar ProofOfWorkBox =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * Create an instance of ProofOfWork.\r\n   * @param networkClient The network client to communicate through.\r\n   * @param apiKey The API key to access the pow box.\r\n   */\n  function ProofOfWorkBox(networkClient, apiKey) {\n    var pollIntervalMs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1000;\n\n    _classCallCheck(this, ProofOfWorkBox);\n\n    if (objectHelper_1.ObjectHelper.isEmpty(networkClient)) {\n      throw new cryptoError_1.CryptoError(\"The networkClient must be defined\");\n    }\n\n    if (stringHelper_1.StringHelper.isEmpty(apiKey)) {\n      throw new cryptoError_1.CryptoError(\"The apiKey must not be empty\");\n    }\n\n    if (!numberHelper_1.NumberHelper.isInteger(pollIntervalMs) || pollIntervalMs <= 0) {\n      throw new cryptoError_1.CryptoError(\"The pollIntervalMs must be > 0\");\n    }\n\n    this._networkClient = networkClient;\n    this._apiKey = apiKey;\n    this._pollIntervalMs = pollIntervalMs;\n  }\n  /**\r\n   * Allow the proof of work to perform any initialization.\r\n   * Will throw an exception if the implementation is not supported.\r\n   */\n\n\n  _createClass(ProofOfWorkBox, [{\n    key: \"initialize\",\n    value: function () {\n      var _initialize = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", Promise.resolve());\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      return function initialize() {\n        return _initialize.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Performs single conversion per pow call.\r\n     * @returns True if pow only does one conversion.\r\n     */\n\n  }, {\n    key: \"performsSingle\",\n    value: function performsSingle() {\n      return false;\n    }\n    /**\r\n     * Perform a proof of work on the data.\r\n     * @param trunkTransaction The trunkTransaction to use for the pow.\r\n     * @param branchTransaction The branchTransaction to use for the pow.\r\n     * @param trytes The trytes to perform the pow on.\r\n     * @param minWeightMagnitude The minimum weight magnitude.\r\n     * @returns The trytes produced by the proof of work.\r\n     */\n\n  }, {\n    key: \"pow\",\n    value: function () {\n      var _pow = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(trunkTransaction, branchTransaction, trytes, minWeightMagnitude) {\n        var attachToTangleRequest, additionalHeaders, attachToTangleResponse;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (objectHelper_1.ObjectHelper.isType(trunkTransaction, hash_1.Hash)) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                throw new cryptoError_1.CryptoError(\"The trunkTransaction must be an object of type Hash\");\n\n              case 2:\n                if (objectHelper_1.ObjectHelper.isType(branchTransaction, hash_1.Hash)) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                throw new cryptoError_1.CryptoError(\"The branchTransaction must be an object of type Hash\");\n\n              case 4:\n                if (arrayHelper_1.ArrayHelper.isTyped(trytes, trytes_1.Trytes)) {\n                  _context2.next = 6;\n                  break;\n                }\n\n                throw new cryptoError_1.CryptoError(\"The trytes must be an array of type Trytes\");\n\n              case 6:\n                if (!(!numberHelper_1.NumberHelper.isInteger(minWeightMagnitude) || minWeightMagnitude <= 0)) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                throw new cryptoError_1.CryptoError(\"The minWeightMagnitude must be > 0\");\n\n              case 8:\n                attachToTangleRequest = {\n                  command: \"attachToTangle\",\n                  trunkTransaction: trunkTransaction.toTrytes().toString(),\n                  branchTransaction: branchTransaction.toTrytes().toString(),\n                  minWeightMagnitude: minWeightMagnitude,\n                  trytes: trytes.map(function (t) {\n                    return t.toString();\n                  })\n                };\n                additionalHeaders = {\n                  Authorization: this._apiKey\n                };\n                _context2.next = 12;\n                return this._networkClient.postJson(attachToTangleRequest, \"commands\", additionalHeaders);\n\n              case 12:\n                attachToTangleResponse = _context2.sent;\n\n                if (!(objectHelper_1.ObjectHelper.isEmpty(attachToTangleResponse) || stringHelper_1.StringHelper.isEmpty(attachToTangleResponse.jobId))) {\n                  _context2.next = 17;\n                  break;\n                }\n\n                throw new cryptoError_1.CryptoError(\"The attachToTangleRequest did not return a jobId\");\n\n              case 17:\n                return _context2.abrupt(\"return\", this.waitForJobCompletion(attachToTangleResponse.jobId, trytes));\n\n              case 18:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      return function pow(_x, _x2, _x3, _x4) {\n        return _pow.apply(this, arguments);\n      };\n    }()\n    /* @internal */\n\n  }, {\n    key: \"waitForJobCompletion\",\n    value: function () {\n      var _waitForJobCompletion = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee4(jobId, sourceTrytes) {\n        var _this = this;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                return _context4.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  var intervalId = setInterval(\n                  /*#__PURE__*/\n                  _asyncToGenerator(\n                  /*#__PURE__*/\n                  _regeneratorRuntime.mark(function _callee3() {\n                    var jobResponse;\n                    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                      while (1) {\n                        switch (_context3.prev = _context3.next) {\n                          case 0:\n                            _context3.prev = 0;\n                            _context3.next = 3;\n                            return _this._networkClient.getJson(\"jobs/\".concat(jobId));\n\n                          case 3:\n                            jobResponse = _context3.sent;\n\n                            if (jobResponse.error) {\n                              clearInterval(intervalId);\n                              reject(new cryptoError_1.CryptoError(jobResponse.errorMessage));\n                            } else if (jobResponse.progress === \"100\") {\n                              clearInterval(intervalId);\n\n                              if (jobResponse && jobResponse.response && jobResponse.response.trytes && jobResponse.response.trytes.length === sourceTrytes.length) {\n                                resolve(jobResponse.response.trytes.map(function (t) {\n                                  return trytes_1.Trytes.fromString(t);\n                                }));\n                              } else {\n                                reject(new cryptoError_1.CryptoError(\"The response did not contain enough trytes\"));\n                              }\n                            }\n\n                            _context3.next = 11;\n                            break;\n\n                          case 7:\n                            _context3.prev = 7;\n                            _context3.t0 = _context3[\"catch\"](0);\n                            clearInterval(intervalId);\n                            reject(_context3.t0);\n\n                          case 11:\n                          case \"end\":\n                            return _context3.stop();\n                        }\n                      }\n                    }, _callee3, this, [[0, 7]]);\n                  })), _this._pollIntervalMs);\n                }));\n\n              case 1:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      return function waitForJobCompletion(_x5, _x6) {\n        return _waitForJobCompletion.apply(this, arguments);\n      };\n    }()\n  }]);\n\n  return ProofOfWorkBox;\n}();\n\nexports.ProofOfWorkBox = ProofOfWorkBox;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-box/dist/proofOfWorkBox.js?");

/***/ }),

/***/ "../iota-pico-pow-box/node_modules/@babel/runtime/regenerator/index.js":
/*!*****************************************************************************!*\
  !*** ../iota-pico-pow-box/node_modules/@babel/runtime/regenerator/index.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! regenerator-runtime */ \"../iota-pico-pow-box/node_modules/regenerator-runtime/runtime-module.js\");\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-box/node_modules/@babel/runtime/regenerator/index.js?");

/***/ }),

/***/ "../iota-pico-pow-box/node_modules/regenerator-runtime/runtime-module.js":
/*!*******************************************************************************!*\
  !*** ../iota-pico-pow-box/node_modules/regenerator-runtime/runtime-module.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\nvar g = (function() { return this })() || Function(\"return this\")();\n\n// Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\nvar hadRuntime = g.regeneratorRuntime &&\n  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;\n\n// Save the old regeneratorRuntime in case it needs to be restored later.\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\n// Force reevalutation of runtime.js.\ng.regeneratorRuntime = undefined;\n\nmodule.exports = __webpack_require__(/*! ./runtime */ \"../iota-pico-pow-box/node_modules/regenerator-runtime/runtime.js\");\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch(e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-box/node_modules/regenerator-runtime/runtime-module.js?");

/***/ }),

/***/ "../iota-pico-pow-box/node_modules/regenerator-runtime/runtime.js":
/*!************************************************************************!*\
  !*** ../iota-pico-pow-box/node_modules/regenerator-runtime/runtime.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // In sloppy mode, unbound `this` refers to the global object, fallback to\n  // Function constructor if we're in global strict mode. That is sadly a form\n  // of indirect eval which violates Content Security Policy.\n  (function() { return this })() || Function(\"return this\")()\n);\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-box/node_modules/regenerator-runtime/runtime.js?");

/***/ }),

/***/ "../iota-pico-pow-js/dist/index.js":
/*!*****************************************!*\
  !*** ../iota-pico-pow-js/dist/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function __export(m) {\n  for (var p in m) {\n    if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n  }\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Combined index of all the modules.\r\n */\n\n__export(__webpack_require__(/*! ./proofOfWorkJs */ \"../iota-pico-pow-js/dist/proofOfWorkJs.js\"));\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-js/dist/index.js?");

/***/ }),

/***/ "../iota-pico-pow-js/dist/pearlDiver/pearlDiver.js":
/*!*********************************************************!*\
  !*** ../iota-pico-pow-js/dist/pearlDiver/pearlDiver.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar spongeFactory_1 = __webpack_require__(/*! @iota-pico/crypto/dist/factories/spongeFactory */ \"../iota-pico-crypto/dist/factories/spongeFactory.js\");\n\nvar trits_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trits */ \"../iota-pico-data/dist/data/trits.js\"); // tslint:disable-next-line:import-name\n\n\nvar big_integer_1 = __importDefault(__webpack_require__(/*! big-integer */ \"big-integer\"));\n/**\r\n * PearlDiver implementation in plain JavaScript.\r\n */\n\n\nvar PearlDiver =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * Create a new instance of PearlDiver.\r\n   */\n  function PearlDiver() {\n    _classCallCheck(this, PearlDiver);\n\n    var curl = spongeFactory_1.SpongeFactory.instance().create(\"curl\");\n    var curlConstants = curl.getConstants();\n    this._hashLength = curlConstants.HASH_LENGTH;\n    this._stateLength = curlConstants.STATE_LENGTH;\n    this._numberRounds = curlConstants.NUMBER_OF_ROUNDS;\n    this._transactionLength = this._hashLength * 33;\n    this._nonceLength = this._hashLength / 3;\n    this._nonceStart = this._hashLength - this._nonceLength;\n    var OFFSET_LENGTH = 4;\n    this._nonceInitStart = this._nonceStart + OFFSET_LENGTH;\n    var INT_LENGTH = this._nonceLength / 3;\n    this._nonceIncrementStart = this._nonceInitStart + INT_LENGTH;\n  }\n  /**\r\n   * Perform a proof of work on the data.\r\n   * @param trytes The trytes to perform the pow on.\r\n   * @param minWeightMagnitude The minimum weight magnitude.\r\n   * @returns The trytes produced by the proof of work.\r\n   */\n\n\n  _createClass(PearlDiver, [{\n    key: \"searchWithTrytes\",\n    value: function searchWithTrytes(trytes, minWeightMagnitude) {\n      var curlState = this.prepare(trytes);\n      var searchStates = this.searchInit(curlState);\n      return this.search(searchStates, minWeightMagnitude);\n    }\n  }, {\n    key: \"search\",\n    value: function search(searchStates, minWeightMagnitude) {\n      var searching = true;\n      var trits = new Int8Array(this._hashLength);\n      var midStateCopy = {\n        low: searchStates.low.slice(),\n        high: searchStates.high.slice()\n      };\n\n      while (searching) {\n        this.increment(midStateCopy, this._nonceIncrementStart, this._hashLength);\n        var state = {\n          low: midStateCopy.low.slice(),\n          high: midStateCopy.high.slice()\n        };\n        this.transform(state);\n        var nonceProbe = this.isFoundFast(state, minWeightMagnitude);\n\n        if (nonceProbe.toJSNumber() === 0) {\n          continue;\n        }\n\n        var nonceOutput = big_integer_1.default(1); // Bit scan forward\n\n        while (nonceOutput.and(nonceProbe).toJSNumber() === 0) {\n          nonceOutput = nonceOutput.shiftLeft(1);\n        }\n\n        searching = false;\n\n        for (var i = 0; i < this._hashLength; i++) {\n          trits[i] = midStateCopy.low[i].and(nonceOutput).toJSNumber() === 0 ? 1 : midStateCopy.high[i].and(nonceOutput).toJSNumber() === 0 ? -1 : 0;\n        }\n      }\n\n      return trits_1.Trits.fromArray(trits).toTrytes();\n    }\n  }, {\n    key: \"transform\",\n    value: function transform(searchStates) {\n      var curlScratchpadIndex = 0;\n\n      for (var round = 0; round < this._numberRounds; round++) {\n        var curlScratchpad = {\n          low: searchStates.low.slice(),\n          high: searchStates.high.slice()\n        };\n\n        for (var stateIndex = 0; stateIndex < this._stateLength; stateIndex++) {\n          var alpha = curlScratchpad.low[curlScratchpadIndex];\n          var beta = curlScratchpad.high[curlScratchpadIndex];\n\n          if (curlScratchpadIndex < 365) {\n            curlScratchpadIndex += 364;\n          } else {\n            curlScratchpadIndex += -365;\n          }\n\n          var gamma = curlScratchpad.high[curlScratchpadIndex];\n          var lowXorBeta = curlScratchpad.low[curlScratchpadIndex].xor(beta);\n          var notGamma = gamma.not();\n          var alphaOrNotGamma = alpha.or(notGamma);\n          var delta = alphaOrNotGamma.and(lowXorBeta);\n          searchStates.low[stateIndex] = delta.not();\n          var alphaXorGamma = alpha.xor(gamma);\n          searchStates.high[stateIndex] = alphaXorGamma.or(delta);\n        }\n      }\n    }\n  }, {\n    key: \"increment\",\n    value: function increment(searchStates, fromIndex, toIndex) {\n      for (var i = fromIndex; i < toIndex; i++) {\n        if (searchStates.low[i].toJSNumber() === PearlDiver.LOW_BITS) {\n          searchStates.low[i] = big_integer_1.default(PearlDiver.HIGH_BITS);\n          searchStates.high[i] = big_integer_1.default(PearlDiver.LOW_BITS);\n        } else {\n          if (searchStates.high[i].toJSNumber() === PearlDiver.LOW_BITS) {\n            searchStates.high[i] = big_integer_1.default(PearlDiver.HIGH_BITS);\n          } else {\n            searchStates.low[i] = big_integer_1.default(PearlDiver.LOW_BITS);\n          }\n\n          break;\n        }\n      }\n    }\n  }, {\n    key: \"prepare\",\n    value: function prepare(transactionTrytes) {\n      var curl = spongeFactory_1.SpongeFactory.instance().create(\"curl\");\n      curl.initialize();\n      var transactionTrits = trits_1.Trits.fromTrytes(transactionTrytes).toArray();\n      curl.absorb(transactionTrits, 0, this._transactionLength - this._hashLength);\n      var curlState = curl.getState();\n      transactionTrits.slice(this._transactionLength - this._hashLength, this._transactionLength).forEach(function (value, index) {\n        curlState[index] = value;\n      });\n      return curlState;\n    }\n  }, {\n    key: \"searchInit\",\n    value: function searchInit(curlState) {\n      var states = {\n        low: [],\n        high: []\n      };\n      curlState.forEach(function (trit, index) {\n        switch (trit) {\n          case 0:\n            states.low[index] = big_integer_1.default(PearlDiver.HIGH_BITS);\n            states.high[index] = big_integer_1.default(PearlDiver.HIGH_BITS);\n            break;\n\n          case 1:\n            states.low[index] = big_integer_1.default(PearlDiver.LOW_BITS);\n            states.high[index] = big_integer_1.default(PearlDiver.HIGH_BITS);\n            break;\n\n          default:\n            states.low[index] = big_integer_1.default(PearlDiver.HIGH_BITS);\n            states.high[index] = big_integer_1.default(PearlDiver.LOW_BITS);\n        }\n      });\n      this.searchOffset(states, this._nonceStart);\n      return states;\n    }\n  }, {\n    key: \"searchOffset\",\n    value: function searchOffset(states, offset) {\n      states.low[offset + 0] = big_integer_1.default(\"-2635249153387078803\", 10);\n      states.high[offset + 0] = big_integer_1.default(\"-5270498306774157605\", 10);\n      states.low[offset + 1] = big_integer_1.default(\"-1010780497189564473\", 10);\n      states.high[offset + 1] = big_integer_1.default(\"-8086243977516515777\", 10);\n      states.low[offset + 2] = big_integer_1.default(\"9223336921201902079\", 10);\n      states.high[offset + 2] = big_integer_1.default(\"-17979214271348737\", 10);\n      states.low[offset + 3] = big_integer_1.default(\"-18014398375264257\", 10);\n      states.high[offset + 3] = big_integer_1.default(\"18014398509481983\", 10);\n    }\n  }, {\n    key: \"isFoundFast\",\n    value: function isFoundFast(searchStates, minWeightMagnitude) {\n      var lastMeasurement = big_integer_1.default(PearlDiver.HIGH_BITS);\n\n      for (var i = minWeightMagnitude - 1; i >= 0; i--) {\n        var low = searchStates.low[this._hashLength - 1 - i];\n        var high = searchStates.high[this._hashLength - 1 - i];\n        var lowXorHigh = low.xor(high);\n        var notLowXorHigh = lowXorHigh.not();\n        lastMeasurement = lastMeasurement.and(notLowXorHigh);\n\n        if (lastMeasurement.toJSNumber() === 0) {\n          break;\n        }\n      }\n\n      return lastMeasurement;\n    }\n  }]);\n\n  return PearlDiver;\n}();\n/* @internal */\n\n\nPearlDiver.HIGH_BITS = -1;\n/* @internal */\n\nPearlDiver.LOW_BITS = 0;\nexports.PearlDiver = PearlDiver;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-js/dist/pearlDiver/pearlDiver.js?");

/***/ }),

/***/ "../iota-pico-pow-js/dist/proofOfWorkJs.js":
/*!*************************************************!*\
  !*** ../iota-pico-pow-js/dist/proofOfWorkJs.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ \"../iota-pico-pow-js/node_modules/@babel/runtime/regenerator/index.js\");\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _next(value) { step(\"next\", value); } function _throw(err) { step(\"throw\", err); } _next(); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar arrayHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/arrayHelper */ \"../iota-pico-core/dist/helpers/arrayHelper.js\");\n\nvar numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ \"../iota-pico-core/dist/helpers/numberHelper.js\");\n\nvar cryptoError_1 = __webpack_require__(/*! @iota-pico/crypto/dist/error/cryptoError */ \"../iota-pico-crypto/dist/error/cryptoError.js\");\n\nvar trytes_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trytes */ \"../iota-pico-data/dist/data/trytes.js\");\n\nvar pearlDiver_1 = __webpack_require__(/*! ./pearlDiver/pearlDiver */ \"../iota-pico-pow-js/dist/pearlDiver/pearlDiver.js\");\n/**\r\n * ProofOfWork implementation using JavaScript.\r\n */\n\n\nvar ProofOfWorkJs =\n/*#__PURE__*/\nfunction () {\n  function ProofOfWorkJs() {\n    _classCallCheck(this, ProofOfWorkJs);\n  }\n\n  _createClass(ProofOfWorkJs, [{\n    key: \"initialize\",\n\n    /**\r\n     * Allow the proof of work to perform any initialization.\r\n     * Will throw an exception if the implementation is not supported.\r\n     */\n    value: function () {\n      var _initialize = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", Promise.resolve());\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      return function initialize() {\n        return _initialize.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Performs single conversion per pow call.\r\n     * @returns True if pow only does one conversion.\r\n     */\n\n  }, {\n    key: \"performsSingle\",\n    value: function performsSingle() {\n      return true;\n    }\n    /**\r\n     * Perform a proof of work on the data.\r\n     * @param trunkTransaction The trunkTransaction to use for the pow.\r\n     * @param branchTransaction The branchTransaction to use for the pow.\r\n     * @param trytes The trytes to perform the pow on.\r\n     * @param minWeightMagnitude The minimum weight magnitude.\r\n     * @returns The trytes produced by the proof of work.\r\n     */\n\n  }, {\n    key: \"pow\",\n    value: function () {\n      var _pow = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(trunkTransaction, branchTransaction, trytes, minWeightMagnitude) {\n        var nonce, nonceString, trytesString;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (arrayHelper_1.ArrayHelper.isTyped(trytes, trytes_1.Trytes)) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                throw new cryptoError_1.CryptoError(\"The trytes must be an array of type Trytes\");\n\n              case 2:\n                if (!(!numberHelper_1.NumberHelper.isInteger(minWeightMagnitude) || minWeightMagnitude <= 0)) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                throw new cryptoError_1.CryptoError(\"The minWeightMagnitude must be > 0\");\n\n              case 4:\n                nonce = new pearlDiver_1.PearlDiver().searchWithTrytes(trytes[0], minWeightMagnitude);\n                nonceString = nonce.toString();\n                trytesString = trytes.toString();\n                return _context2.abrupt(\"return\", [trytes_1.Trytes.fromString(trytesString.substr(0, trytesString.length - nonceString.length) + nonceString)]);\n\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      return function pow(_x, _x2, _x3, _x4) {\n        return _pow.apply(this, arguments);\n      };\n    }()\n  }]);\n\n  return ProofOfWorkJs;\n}();\n\nexports.ProofOfWorkJs = ProofOfWorkJs;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-js/dist/proofOfWorkJs.js?");

/***/ }),

/***/ "../iota-pico-pow-js/node_modules/@babel/runtime/regenerator/index.js":
/*!****************************************************************************!*\
  !*** ../iota-pico-pow-js/node_modules/@babel/runtime/regenerator/index.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! regenerator-runtime */ \"../iota-pico-pow-js/node_modules/regenerator-runtime/runtime-module.js\");\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-js/node_modules/@babel/runtime/regenerator/index.js?");

/***/ }),

/***/ "../iota-pico-pow-js/node_modules/regenerator-runtime/runtime-module.js":
/*!******************************************************************************!*\
  !*** ../iota-pico-pow-js/node_modules/regenerator-runtime/runtime-module.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\nvar g = (function() { return this })() || Function(\"return this\")();\n\n// Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\nvar hadRuntime = g.regeneratorRuntime &&\n  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;\n\n// Save the old regeneratorRuntime in case it needs to be restored later.\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\n// Force reevalutation of runtime.js.\ng.regeneratorRuntime = undefined;\n\nmodule.exports = __webpack_require__(/*! ./runtime */ \"../iota-pico-pow-js/node_modules/regenerator-runtime/runtime.js\");\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch(e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-js/node_modules/regenerator-runtime/runtime-module.js?");

/***/ }),

/***/ "../iota-pico-pow-js/node_modules/regenerator-runtime/runtime.js":
/*!***********************************************************************!*\
  !*** ../iota-pico-pow-js/node_modules/regenerator-runtime/runtime.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // In sloppy mode, unbound `this` refers to the global object, fallback to\n  // Function constructor if we're in global strict mode. That is sadly a form\n  // of indirect eval which violates Content Security Policy.\n  (function() { return this })() || Function(\"return this\")()\n);\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-js/node_modules/regenerator-runtime/runtime.js?");

/***/ }),

/***/ "../iota-pico-pow-nodejs/dist/index.js":
/*!*********************************************!*\
  !*** ../iota-pico-pow-nodejs/dist/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function __export(m) {\n  for (var p in m) {\n    if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n  }\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Combined index of all the modules.\r\n */\n\n__export(__webpack_require__(/*! ./proofOfWorkNodeJs */ \"../iota-pico-pow-nodejs/dist/proofOfWorkNodeJs.js\"));\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-nodejs/dist/index.js?");

/***/ }),

/***/ "../iota-pico-pow-nodejs/dist/proofOfWorkNodeJs.js":
/*!*********************************************************!*\
  !*** ../iota-pico-pow-nodejs/dist/proofOfWorkNodeJs.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ \"../iota-pico-pow-nodejs/node_modules/@babel/runtime/regenerator/index.js\");\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _next(value) { step(\"next\", value); } function _throw(err) { step(\"throw\", err); } _next(); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar arrayHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/arrayHelper */ \"../iota-pico-core/dist/helpers/arrayHelper.js\");\n\nvar numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ \"../iota-pico-core/dist/helpers/numberHelper.js\");\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar cryptoError_1 = __webpack_require__(/*! @iota-pico/crypto/dist/error/cryptoError */ \"../iota-pico-crypto/dist/error/cryptoError.js\");\n\nvar trytes_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trytes */ \"../iota-pico-data/dist/data/trytes.js\");\n\nvar ffi = __importStar(__webpack_require__(/*! ffi */ \"ffi\"));\n\nvar fs = __importStar(__webpack_require__(/*! fs */ \"fs\"));\n\nvar os = __importStar(__webpack_require__(/*! os */ \"os\"));\n\nvar path = __importStar(__webpack_require__(/*! path */ \"path\"));\n\nvar util = __importStar(__webpack_require__(/*! util */ \"util\"));\n/**\r\n * ProofOfWork implementation using NodeJS.\r\n */\n\n\nvar ProofOfWorkNodeJs =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * Create a new instance of ProofOfWork.\r\n   * @param nodePlatform Provides platform specific functions, optional mostly used for testing.\r\n   */\n  function ProofOfWorkNodeJs(nodePlatform) {\n    _classCallCheck(this, ProofOfWorkNodeJs);\n\n    if (objectHelper_1.ObjectHelper.isEmpty(nodePlatform)) {\n      this._nodePlatform = {\n        pathResolve: path.resolve,\n        pathJoin: path.join,\n        platform: os.platform,\n        lstat: fs.lstat,\n        loadLibrary: ffi.Library\n      };\n    } else {\n      this._nodePlatform = nodePlatform;\n    }\n  }\n  /**\r\n   * Allow the proof of work to perform any initialization.\r\n   * Will throw an exception if the implementation is not supported.\r\n   */\n\n\n  _createClass(ProofOfWorkNodeJs, [{\n    key: \"initialize\",\n    value: function () {\n      var _initialize = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        var fullPath, platform, libFile, stat;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                fullPath = this._nodePlatform.pathJoin(path.join(__dirname, \"../binaries/\"));\n                platform = this._nodePlatform.platform();\n                libFile = this._nodePlatform.pathJoin(fullPath, platform, \"libccurl\");\n                _context.t0 = platform;\n                _context.next = _context.t0 === \"darwin\" ? 6 : _context.t0 === \"win32\" ? 8 : 10;\n                break;\n\n              case 6:\n                libFile += \".dylib\";\n                return _context.abrupt(\"break\", 11);\n\n              case 8:\n                libFile += \".dll\";\n                return _context.abrupt(\"break\", 11);\n\n              case 10:\n                libFile += \".so\";\n\n              case 11:\n                _context.next = 13;\n                return util.promisify(this._nodePlatform.lstat)(libFile);\n\n              case 13:\n                stat = _context.sent;\n\n                if (!stat.isFile()) {\n                  _context.next = 18;\n                  break;\n                }\n\n                this._library = this._nodePlatform.loadLibrary(libFile, {\n                  ccurl_pow: [\"string\", [\"string\", \"int\"]]\n                });\n                _context.next = 19;\n                break;\n\n              case 18:\n                throw new cryptoError_1.CryptoError(\"Library files does not exist\", {\n                  libFile: libFile\n                });\n\n              case 19:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      return function initialize() {\n        return _initialize.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Performs single conversion per pow call.\r\n     * @returns True if pow only does one conversion.\r\n     */\n\n  }, {\n    key: \"performsSingle\",\n    value: function performsSingle() {\n      return true;\n    }\n    /**\r\n     * Perform a proof of work on the data.\r\n     * @param trunkTransaction The trunkTransaction to use for the pow.\r\n     * @param branchTransaction The branchTransaction to use for the pow.\r\n     * @param trytes The trytes to perform the pow on.\r\n     * @param minWeightMagnitude The minimum weight magnitude.\r\n     * @returns The trytes produced by the proof of work.\r\n     */\n\n  }, {\n    key: \"pow\",\n    value: function () {\n      var _pow = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(trunkTransaction, branchTransaction, trytes, minWeightMagnitude) {\n        var _this = this;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  if (objectHelper_1.ObjectHelper.isEmpty(_this._library)) {\n                    throw new cryptoError_1.CryptoError(\"Library not loaded, have you called initialize\");\n                  }\n\n                  if (!arrayHelper_1.ArrayHelper.isTyped(trytes, trytes_1.Trytes)) {\n                    throw new cryptoError_1.CryptoError(\"The trytes must be an array of type Trytes\");\n                  }\n\n                  if (!numberHelper_1.NumberHelper.isInteger(minWeightMagnitude) || minWeightMagnitude <= 0) {\n                    throw new cryptoError_1.CryptoError(\"The minWeightMagnitude must be > 0\");\n                  }\n\n                  _this._library.ccurl_pow.async(trytes[0].toString(), minWeightMagnitude, function (error, returnedTrytes) {\n                    if (error) {\n                      reject(error);\n                    } else {\n                      resolve([trytes_1.Trytes.fromString(returnedTrytes)]);\n                    }\n                  });\n                }));\n\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      return function pow(_x, _x2, _x3, _x4) {\n        return _pow.apply(this, arguments);\n      };\n    }()\n  }]);\n\n  return ProofOfWorkNodeJs;\n}();\n\nexports.ProofOfWorkNodeJs = ProofOfWorkNodeJs;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-nodejs/dist/proofOfWorkNodeJs.js?");

/***/ }),

/***/ "../iota-pico-pow-nodejs/node_modules/@babel/runtime/regenerator/index.js":
/*!********************************************************************************!*\
  !*** ../iota-pico-pow-nodejs/node_modules/@babel/runtime/regenerator/index.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! regenerator-runtime */ \"../iota-pico-pow-nodejs/node_modules/regenerator-runtime/runtime-module.js\");\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-nodejs/node_modules/@babel/runtime/regenerator/index.js?");

/***/ }),

/***/ "../iota-pico-pow-nodejs/node_modules/regenerator-runtime/runtime-module.js":
/*!**********************************************************************************!*\
  !*** ../iota-pico-pow-nodejs/node_modules/regenerator-runtime/runtime-module.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\nvar g = (function() { return this })() || Function(\"return this\")();\n\n// Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\nvar hadRuntime = g.regeneratorRuntime &&\n  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;\n\n// Save the old regeneratorRuntime in case it needs to be restored later.\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\n// Force reevalutation of runtime.js.\ng.regeneratorRuntime = undefined;\n\nmodule.exports = __webpack_require__(/*! ./runtime */ \"../iota-pico-pow-nodejs/node_modules/regenerator-runtime/runtime.js\");\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch(e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-nodejs/node_modules/regenerator-runtime/runtime-module.js?");

/***/ }),

/***/ "../iota-pico-pow-nodejs/node_modules/regenerator-runtime/runtime.js":
/*!***************************************************************************!*\
  !*** ../iota-pico-pow-nodejs/node_modules/regenerator-runtime/runtime.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // In sloppy mode, unbound `this` refers to the global object, fallback to\n  // Function constructor if we're in global strict mode. That is sadly a form\n  // of indirect eval which violates Content Security Policy.\n  (function() { return this })() || Function(\"return this\")()\n);\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-nodejs/node_modules/regenerator-runtime/runtime.js?");

/***/ }),

/***/ "../iota-pico-pow-wasm/dist/index.js":
/*!*******************************************!*\
  !*** ../iota-pico-pow-wasm/dist/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function __export(m) {\n  for (var p in m) {\n    if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n  }\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Combined index of all the modules.\r\n */\n\n__export(__webpack_require__(/*! ./proofOfWorkWasm */ \"../iota-pico-pow-wasm/dist/proofOfWorkWasm.js\"));\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-wasm/dist/index.js?");

/***/ }),

/***/ "../iota-pico-pow-wasm/dist/proofOfWorkWasm.js":
/*!*****************************************************!*\
  !*** ../iota-pico-pow-wasm/dist/proofOfWorkWasm.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ \"../iota-pico-pow-wasm/node_modules/@babel/runtime/regenerator/index.js\");\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _next(value) { step(\"next\", value); } function _throw(err) { step(\"throw\", err); } _next(); }); }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); /// <reference types=\"emscripten\" />\n\nvar arrayHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/arrayHelper */ \"../iota-pico-core/dist/helpers/arrayHelper.js\");\n\nvar numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ \"../iota-pico-core/dist/helpers/numberHelper.js\");\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar cryptoError_1 = __webpack_require__(/*! @iota-pico/crypto/dist/error/cryptoError */ \"../iota-pico-crypto/dist/error/cryptoError.js\");\n\nvar trytes_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trytes */ \"../iota-pico-data/dist/data/trytes.js\"); // @ts-ignore\n\n\nvar iota_pico_pow_wasm_1 = __importDefault(__webpack_require__(/*! ../wasm/iota-pico-pow-wasm */ \"../iota-pico-pow-wasm/wasm/iota-pico-pow-wasm.js\"));\n/**\r\n * ProofOfWork implementation using WebAssembly.\r\n */\n\n\nvar ProofOfWorkWasm =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * Create a new instance of ProofOfWork.\r\n   * @param webPlatform Provides platform specific functions, optional mostly used for testing.\r\n   */\n  function ProofOfWorkWasm(webPlatform) {\n    _classCallCheck(this, ProofOfWorkWasm);\n\n    if (objectHelper_1.ObjectHelper.isEmpty(webPlatform)) {\n      this._webPlatform = {\n        webAssemblyType: typeof WebAssembly === \"undefined\" ? \"undefined\" : _typeof(WebAssembly),\n        wasmModuleLoader: iota_pico_pow_wasm_1.default\n      };\n    } else {\n      this._webPlatform = webPlatform;\n    }\n  }\n  /**\r\n   * Allow the proof of work to perform any initialization.\r\n   * Will throw an exception if the implementation is not supported.\r\n   */\n\n\n  _createClass(ProofOfWorkWasm, [{\n    key: \"initialize\",\n    value: function () {\n      var _initialize = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        var _this = this;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  if (objectHelper_1.ObjectHelper.isEmpty(_this._webPlatform.webAssemblyType) || _this._webPlatform.webAssemblyType === \"undefined\") {\n                    reject(new cryptoError_1.CryptoError(\"No WebAssembly support detected\"));\n                  }\n\n                  var module = {};\n\n                  module.onRuntimeInitialized = function () {\n                    _this._ccurlPow = module.cwrap(\"ccurl_pow\", \"string\", [\"string\", \"number\"]);\n                    resolve();\n                  };\n\n                  try {\n                    _this._webPlatform.wasmModuleLoader(module);\n                  } catch (err) {\n                    reject(new cryptoError_1.CryptoError(\"There was a problem intializing the WebAssembly Module\", undefined, err));\n                  }\n                }));\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      return function initialize() {\n        return _initialize.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Performs single conversion per pow call.\r\n     * @returns True if pow only does one conversion.\r\n     */\n\n  }, {\n    key: \"performsSingle\",\n    value: function performsSingle() {\n      return true;\n    }\n    /**\r\n     * Perform a proof of work on the data.\r\n     * @param trunkTransaction The trunkTransaction to use for the pow.\r\n     * @param branchTransaction The branchTransaction to use for the pow.\r\n     * @param trytes The trytes to perform the pow on.\r\n     * @param minWeightMagnitude The minimum weight magnitude.\r\n     * @returns The trytes produced by the proof of work.\r\n     */\n\n  }, {\n    key: \"pow\",\n    value: function () {\n      var _pow = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(trunkTransaction, branchTransaction, trytes, minWeightMagnitude) {\n        var _this2 = this;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  if (objectHelper_1.ObjectHelper.isEmpty(_this2._ccurlPow)) {\n                    throw new cryptoError_1.CryptoError(\"WebAssembly not loaded, have you called initialize\");\n                  }\n\n                  if (!arrayHelper_1.ArrayHelper.isTyped(trytes, trytes_1.Trytes)) {\n                    throw new cryptoError_1.CryptoError(\"The trytes must be an array of type Trytes\");\n                  }\n\n                  if (!numberHelper_1.NumberHelper.isInteger(minWeightMagnitude) || minWeightMagnitude <= 0) {\n                    throw new cryptoError_1.CryptoError(\"The minWeightMagnitude must be > 0\");\n                  }\n\n                  try {\n                    var result = _this2._ccurlPow(trytes[0].toString(), minWeightMagnitude);\n\n                    resolve([trytes_1.Trytes.fromString(result)]);\n                  } catch (err) {\n                    reject(err);\n                  }\n                }));\n\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      return function pow(_x, _x2, _x3, _x4) {\n        return _pow.apply(this, arguments);\n      };\n    }()\n  }]);\n\n  return ProofOfWorkWasm;\n}();\n\nexports.ProofOfWorkWasm = ProofOfWorkWasm;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-wasm/dist/proofOfWorkWasm.js?");

/***/ }),

/***/ "../iota-pico-pow-wasm/node_modules/@babel/runtime/regenerator/index.js":
/*!******************************************************************************!*\
  !*** ../iota-pico-pow-wasm/node_modules/@babel/runtime/regenerator/index.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! regenerator-runtime */ \"../iota-pico-pow-wasm/node_modules/regenerator-runtime/runtime-module.js\");\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-wasm/node_modules/@babel/runtime/regenerator/index.js?");

/***/ }),

/***/ "../iota-pico-pow-wasm/node_modules/regenerator-runtime/runtime-module.js":
/*!********************************************************************************!*\
  !*** ../iota-pico-pow-wasm/node_modules/regenerator-runtime/runtime-module.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\nvar g = (function() { return this })() || Function(\"return this\")();\n\n// Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\nvar hadRuntime = g.regeneratorRuntime &&\n  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;\n\n// Save the old regeneratorRuntime in case it needs to be restored later.\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\n// Force reevalutation of runtime.js.\ng.regeneratorRuntime = undefined;\n\nmodule.exports = __webpack_require__(/*! ./runtime */ \"../iota-pico-pow-wasm/node_modules/regenerator-runtime/runtime.js\");\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch(e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-wasm/node_modules/regenerator-runtime/runtime-module.js?");

/***/ }),

/***/ "../iota-pico-pow-wasm/node_modules/regenerator-runtime/runtime.js":
/*!*************************************************************************!*\
  !*** ../iota-pico-pow-wasm/node_modules/regenerator-runtime/runtime.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // In sloppy mode, unbound `this` refers to the global object, fallback to\n  // Function constructor if we're in global strict mode. That is sadly a form\n  // of indirect eval which violates Content Security Policy.\n  (function() { return this })() || Function(\"return this\")()\n);\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-wasm/node_modules/regenerator-runtime/runtime.js?");

/***/ }),

/***/ "../iota-pico-pow-wasm/wasm/iota-pico-pow-wasm.js":
/*!********************************************************!*\
  !*** ../iota-pico-pow-wasm/wasm/iota-pico-pow-wasm.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar Module = function Module(_Module) {\n  _Module = _Module || {}; // The Module object: Our interface to the outside world. We import\n  // and export values on it. There are various ways Module can be used:\n  // 1. Not defined. We create it here\n  // 2. A function parameter, function(Module) { ..generated code.. }\n  // 3. pre-run appended it, var Module = {}; ..generated code..\n  // 4. External script tag defines var Module.\n  // We need to check if Module already exists (e.g. case 3 above).\n  // Substitution will be replaced with actual code on later stage of the build,\n  // this way Closure Compiler will not mangle it (e.g. case 4. above).\n  // Note that if you want to run closure, and also to use Module\n  // after the generated code, you will need to define   var Module = {};\n  // before the code. Then that object will be used in the code, and you\n  // can continue to use Module afterwards as well.\n\n  var _Module = typeof _Module !== 'undefined' ? _Module : {}; // --pre-jses are emitted after the Module integration code, so that they can\n  // refer to Module (if they choose; they can also define Module)\n  // {{PRE_JSES}}\n  // Sometimes an existing Module object exists with properties\n  // meant to overwrite the default module functionality. Here\n  // we collect those properties and reapply _after_ we configure\n  // the current environment's defaults to avoid having to be so\n  // defensive during initialization.\n\n\n  var moduleOverrides = {};\n  var key;\n\n  for (key in _Module) {\n    if (_Module.hasOwnProperty(key)) {\n      moduleOverrides[key] = _Module[key];\n    }\n  }\n\n  _Module['arguments'] = [];\n  _Module['thisProgram'] = './this.program';\n\n  _Module['quit'] = function (status, toThrow) {\n    throw toThrow;\n  };\n\n  _Module['preRun'] = [];\n  _Module['postRun'] = []; // The environment setup code below is customized to use Module.\n  // *** Environment setup code ***\n\n  var ENVIRONMENT_IS_WEB = false;\n  var ENVIRONMENT_IS_WORKER = false;\n  var ENVIRONMENT_IS_NODE = false;\n  var ENVIRONMENT_IS_SHELL = false; // Three configurations we can be running in:\n  // 1) We could be the application main() thread running in the main JS UI thread. (ENVIRONMENT_IS_WORKER == false and ENVIRONMENT_IS_PTHREAD == false)\n  // 2) We could be the application main() thread proxied to worker. (with Emscripten -s PROXY_TO_WORKER=1) (ENVIRONMENT_IS_WORKER == true, ENVIRONMENT_IS_PTHREAD == false)\n  // 3) We could be an application pthread running in a worker. (ENVIRONMENT_IS_WORKER == true and ENVIRONMENT_IS_PTHREAD == true)\n\n  if (_Module['ENVIRONMENT']) {\n    if (_Module['ENVIRONMENT'] === 'WEB') {\n      ENVIRONMENT_IS_WEB = true;\n    } else if (_Module['ENVIRONMENT'] === 'WORKER') {\n      ENVIRONMENT_IS_WORKER = true;\n    } else if (_Module['ENVIRONMENT'] === 'NODE') {\n      ENVIRONMENT_IS_NODE = true;\n    } else if (_Module['ENVIRONMENT'] === 'SHELL') {\n      ENVIRONMENT_IS_SHELL = true;\n    } else {\n      throw new Error('Module[\\'ENVIRONMENT\\'] value is not valid. must be one of: WEB|WORKER|NODE|SHELL.');\n    }\n  } else {\n    ENVIRONMENT_IS_WEB = (typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === 'object';\n    ENVIRONMENT_IS_WORKER = typeof importScripts === 'function';\n    ENVIRONMENT_IS_NODE = (typeof process === \"undefined\" ? \"undefined\" : _typeof(process)) === 'object' && \"function\" === 'function' && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER;\n    ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\n  }\n\n  if (ENVIRONMENT_IS_NODE) {\n    // Expose functionality in the same simple way that the shells work\n    // Note that we pollute the global namespace here, otherwise we break in node\n    var nodeFS;\n    var nodePath;\n\n    _Module['read'] = function shell_read(filename, binary) {\n      var ret;\n      ret = tryParseAsDataURI(filename);\n\n      if (!ret) {\n        if (!nodeFS) nodeFS = __webpack_require__(/*! fs */ \"fs\");\n        if (!nodePath) nodePath = __webpack_require__(/*! path */ \"path\");\n        filename = nodePath['normalize'](filename);\n        ret = nodeFS['readFileSync'](filename);\n      }\n\n      return binary ? ret : ret.toString();\n    };\n\n    _Module['readBinary'] = function readBinary(filename) {\n      var ret = _Module['read'](filename, true);\n\n      if (!ret.buffer) {\n        ret = new Uint8Array(ret);\n      }\n\n      assert(ret.buffer);\n      return ret;\n    };\n\n    if (process['argv'].length > 1) {\n      _Module['thisProgram'] = process['argv'][1].replace(/\\\\/g, '/');\n    }\n\n    _Module['arguments'] = process['argv'].slice(2); // MODULARIZE will export the module in the proper place outside, we don't need to export here\n\n    process['on']('uncaughtException', function (ex) {\n      // suppress ExitStatus exceptions from showing an error\n      if (!(ex instanceof ExitStatus)) {\n        throw ex;\n      }\n    }); // Currently node will swallow unhandled rejections, but this behavior is\n    // deprecated, and in the future it will exit with error status.\n\n    process['on']('unhandledRejection', function (reason, p) {\n      _Module['printErr']('node.js exiting due to unhandled promise rejection');\n\n      process['exit'](1);\n    });\n\n    _Module['inspect'] = function () {\n      return '[Emscripten Module object]';\n    };\n  } else if (ENVIRONMENT_IS_SHELL) {\n    if (typeof read != 'undefined') {\n      _Module['read'] = function shell_read(f) {\n        var data = tryParseAsDataURI(f);\n\n        if (data) {\n          return intArrayToString(data);\n        }\n\n        return read(f);\n      };\n    }\n\n    _Module['readBinary'] = function readBinary(f) {\n      var data;\n      data = tryParseAsDataURI(f);\n\n      if (data) {\n        return data;\n      }\n\n      if (typeof readbuffer === 'function') {\n        return new Uint8Array(readbuffer(f));\n      }\n\n      data = read(f, 'binary');\n      assert(_typeof(data) === 'object');\n      return data;\n    };\n\n    if (typeof scriptArgs != 'undefined') {\n      _Module['arguments'] = scriptArgs;\n    } else if (typeof arguments != 'undefined') {\n      _Module['arguments'] = arguments;\n    }\n\n    if (typeof quit === 'function') {\n      _Module['quit'] = function (status, toThrow) {\n        quit(status);\n      };\n    }\n  } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n    _Module['read'] = function shell_read(url) {\n      try {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', url, false);\n        xhr.send(null);\n        return xhr.responseText;\n      } catch (err) {\n        var data = tryParseAsDataURI(url);\n\n        if (data) {\n          return intArrayToString(data);\n        }\n\n        throw err;\n      }\n    };\n\n    if (ENVIRONMENT_IS_WORKER) {\n      _Module['readBinary'] = function readBinary(url) {\n        try {\n          var xhr = new XMLHttpRequest();\n          xhr.open('GET', url, false);\n          xhr.responseType = 'arraybuffer';\n          xhr.send(null);\n          return new Uint8Array(xhr.response);\n        } catch (err) {\n          var data = tryParseAsDataURI(url);\n\n          if (data) {\n            return data;\n          }\n\n          throw err;\n        }\n      };\n    }\n\n    _Module['readAsync'] = function readAsync(url, onload, onerror) {\n      var xhr = new XMLHttpRequest();\n      xhr.open('GET', url, true);\n      xhr.responseType = 'arraybuffer';\n\n      xhr.onload = function xhr_onload() {\n        if (xhr.status == 200 || xhr.status == 0 && xhr.response) {\n          // file URLs can return 0\n          onload(xhr.response);\n          return;\n        }\n\n        var data = tryParseAsDataURI(url);\n\n        if (data) {\n          onload(data.buffer);\n          return;\n        }\n\n        onerror();\n      };\n\n      xhr.onerror = onerror;\n      xhr.send(null);\n    };\n\n    if (typeof arguments != 'undefined') {\n      _Module['arguments'] = arguments;\n    }\n\n    _Module['setWindowTitle'] = function (title) {\n      document.title = title;\n    };\n  } else {\n    // Unreachable because SHELL is dependent on the others\n    throw new Error('unknown runtime environment');\n  } // console.log is checked first, as 'print' on the web will open a print dialogue\n  // printErr is preferable to console.warn (works better in shells)\n\n\n  _Module['print'] = typeof console !== 'undefined' ? console.log : typeof print !== 'undefined' ? print : null;\n  _Module['printErr'] = typeof printErr !== 'undefined' ? printErr : typeof console !== 'undefined' && console.warn || _Module['print']; // *** Environment setup code ***\n  // Closure helpers\n\n  _Module.print = _Module['print'];\n  _Module.printErr = _Module['printErr']; // Merge back in the overrides\n\n  for (key in moduleOverrides) {\n    if (moduleOverrides.hasOwnProperty(key)) {\n      _Module[key] = moduleOverrides[key];\n    }\n  } // Free the object hierarchy contained in the overrides, this lets the GC\n  // reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.\n\n\n  moduleOverrides = undefined; // {{PREAMBLE_ADDITIONS}}\n\n  var STACK_ALIGN = 16; // stack management, and other functionality that is provided by the compiled code,\n  // should not be used before it is ready\n\n  _stackSave = _stackRestore = stackAlloc = setTempRet0 = getTempRet0 = function getTempRet0() {\n    abort('cannot use the stack before compiled code is ready to run, and has provided stack access');\n  };\n\n  function staticAlloc(size) {\n    assert(!staticSealed);\n    var ret = STATICTOP;\n    STATICTOP = STATICTOP + size + 15 & -16;\n    return ret;\n  }\n\n  function dynamicAlloc(size) {\n    assert(DYNAMICTOP_PTR);\n    var ret = HEAP32[DYNAMICTOP_PTR >> 2];\n    var end = ret + size + 15 & -16;\n    HEAP32[DYNAMICTOP_PTR >> 2] = end;\n\n    if (end >= TOTAL_MEMORY) {\n      var success = enlargeMemory();\n\n      if (!success) {\n        HEAP32[DYNAMICTOP_PTR >> 2] = ret;\n        return 0;\n      }\n    }\n\n    return ret;\n  }\n\n  function alignMemory(size, factor) {\n    if (!factor) factor = STACK_ALIGN; // stack alignment (16-byte) by default\n\n    var ret = size = Math.ceil(size / factor) * factor;\n    return ret;\n  }\n\n  function getNativeTypeSize(type) {\n    switch (type) {\n      case 'i1':\n      case 'i8':\n        return 1;\n\n      case 'i16':\n        return 2;\n\n      case 'i32':\n        return 4;\n\n      case 'i64':\n        return 8;\n\n      case 'float':\n        return 4;\n\n      case 'double':\n        return 8;\n\n      default:\n        {\n          if (type[type.length - 1] === '*') {\n            return 4; // A pointer\n          } else if (type[0] === 'i') {\n            var bits = parseInt(type.substr(1));\n            assert(bits % 8 === 0);\n            return bits / 8;\n          } else {\n            return 0;\n          }\n        }\n    }\n  }\n\n  function warnOnce(text) {\n    if (!warnOnce.shown) warnOnce.shown = {};\n\n    if (!warnOnce.shown[text]) {\n      warnOnce.shown[text] = 1;\n\n      _Module.printErr(text);\n    }\n  }\n\n  var functionPointers = new Array(0);\n\n  function addFunction(func) {\n    for (var i = 0; i < functionPointers.length; i++) {\n      if (!functionPointers[i]) {\n        functionPointers[i] = func;\n        return 1 + i;\n      }\n    }\n\n    throw 'Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS.';\n  }\n\n  function removeFunction(index) {\n    functionPointers[index - 1] = null;\n  }\n\n  var funcWrappers = {};\n\n  function getFuncWrapper(func, sig) {\n    if (!func) return; // on null pointer, return undefined\n\n    assert(sig);\n\n    if (!funcWrappers[sig]) {\n      funcWrappers[sig] = {};\n    }\n\n    var sigCache = funcWrappers[sig];\n\n    if (!sigCache[func]) {\n      // optimize away arguments usage in common cases\n      if (sig.length === 1) {\n        sigCache[func] = function dynCall_wrapper() {\n          return dynCall(sig, func);\n        };\n      } else if (sig.length === 2) {\n        sigCache[func] = function dynCall_wrapper(arg) {\n          return dynCall(sig, func, [arg]);\n        };\n      } else {\n        // general case\n        sigCache[func] = function dynCall_wrapper() {\n          return dynCall(sig, func, Array.prototype.slice.call(arguments));\n        };\n      }\n    }\n\n    return sigCache[func];\n  }\n\n  function makeBigInt(low, high, unsigned) {\n    return unsigned ? +(low >>> 0) + +(high >>> 0) * 4294967296.0 : +(low >>> 0) + +(high | 0) * 4294967296.0;\n  }\n\n  function dynCall(sig, ptr, args) {\n    if (args && args.length) {\n      assert(args.length == sig.length - 1);\n      assert('dynCall_' + sig in _Module, 'bad function pointer type - no table for sig \\'' + sig + '\\'');\n      return _Module['dynCall_' + sig].apply(null, [ptr].concat(args));\n    } else {\n      assert(sig.length == 1);\n      assert('dynCall_' + sig in _Module, 'bad function pointer type - no table for sig \\'' + sig + '\\'');\n      return _Module['dynCall_' + sig].call(null, ptr);\n    }\n  }\n\n  function getCompilerSetting(name) {\n    throw 'You must build with -s RETAIN_COMPILER_SETTINGS=1 for getCompilerSetting or emscripten_get_compiler_setting to work';\n  }\n\n  var Runtime = {\n    // FIXME backwards compatibility layer for ports. Support some Runtime.*\n    //       for now, fix it there, then remove it from here. That way we\n    //       can minimize any period of breakage.\n    dynCall: dynCall,\n    // for SDL2 port\n    // helpful errors\n    getTempRet0: function getTempRet0() {\n      abort('getTempRet0() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"');\n    },\n    staticAlloc: function staticAlloc() {\n      abort('staticAlloc() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"');\n    },\n    stackAlloc: function stackAlloc() {\n      abort('stackAlloc() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"');\n    }\n  }; // The address globals begin at. Very low in memory, for code size and optimization opportunities.\n  // Above 0 is static memory, starting with globals.\n  // Then the stack.\n  // Then 'dynamic' memory for sbrk.\n\n  var GLOBAL_BASE = 1024; // === Preamble library stuff ===\n  // Documentation for the public APIs defined in this file must be updated in:\n  //    site/source/docs/api_reference/preamble.js.rst\n  // A prebuilt local version of the documentation is available at:\n  //    site/build/text/docs/api_reference/preamble.js.txt\n  // You can also build docs locally as HTML or other formats in site/\n  // An online HTML version (which may be of a different version of Emscripten)\n  //    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\n  //========================================\n  // Runtime essentials\n  //========================================\n\n  var ABORT = 0; // whether we are quitting the application. no code should run after this. set in exit() and abort()\n\n  var EXITSTATUS = 0;\n  /** @type {function(*, string=)} */\n\n  function assert(condition, text) {\n    if (!condition) {\n      abort('Assertion failed: ' + text);\n    }\n  }\n\n  var globalScope = this; // Returns the C function with a specified identifier (for C++, you need to do manual name mangling)\n\n  function getCFunc(ident) {\n    var func = _Module['_' + ident]; // closure exported function\n\n    assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');\n    return func;\n  }\n\n  var JSfuncs = {\n    // Helpers for cwrap -- it can't refer to Runtime directly because it might\n    // be renamed by closure, instead it calls JSfuncs['stackSave'].body to find\n    // out what the minified function name is.\n    'stackSave': function stackSave() {\n      _stackSave();\n    },\n    'stackRestore': function stackRestore() {\n      _stackRestore();\n    },\n    // type conversion from js to c\n    'arrayToC': function arrayToC(arr) {\n      var ret = stackAlloc(arr.length);\n      writeArrayToMemory(arr, ret);\n      return ret;\n    },\n    'stringToC': function stringToC(str) {\n      var ret = 0;\n\n      if (str !== null && str !== undefined && str !== 0) {\n        // null string\n        // at most 4 bytes per UTF-8 code point, +1 for the trailing '\\0'\n        var len = (str.length << 2) + 1;\n        ret = stackAlloc(len);\n        stringToUTF8(str, ret, len);\n      }\n\n      return ret;\n    }\n  }; // For fast lookup of conversion functions\n\n  var toC = {\n    'string': JSfuncs['stringToC'],\n    'array': JSfuncs['arrayToC']\n  }; // C calling interface.\n\n  function ccall(ident, returnType, argTypes, args, opts) {\n    var func = getCFunc(ident);\n    var cArgs = [];\n    var stack = 0;\n    assert(returnType !== 'array', 'Return type should not be \"array\".');\n\n    if (args) {\n      for (var i = 0; i < args.length; i++) {\n        var converter = toC[argTypes[i]];\n\n        if (converter) {\n          if (stack === 0) stack = _stackSave();\n          cArgs[i] = converter(args[i]);\n        } else {\n          cArgs[i] = args[i];\n        }\n      }\n    }\n\n    var ret = func.apply(null, cArgs);\n    if (returnType === 'string') ret = Pointer_stringify(ret);\n\n    if (stack !== 0) {\n      _stackRestore(stack);\n    }\n\n    return ret;\n  }\n\n  function cwrap(ident, returnType, argTypes) {\n    argTypes = argTypes || [];\n    var cfunc = getCFunc(ident); // When the function takes numbers and returns a number, we can just return\n    // the original function\n\n    var numericArgs = argTypes.every(function (type) {\n      return type === 'number';\n    });\n    var numericRet = returnType !== 'string';\n\n    if (numericRet && numericArgs) {\n      return cfunc;\n    }\n\n    return function () {\n      return ccall(ident, returnType, argTypes, arguments);\n    };\n  }\n  /** @type {function(number, number, string, boolean=)} */\n\n\n  function setValue(ptr, value, type, noSafe) {\n    type = type || 'i8';\n    if (type.charAt(type.length - 1) === '*') type = 'i32'; // pointers are 32-bit\n\n    switch (type) {\n      case 'i1':\n        HEAP8[ptr >> 0] = value;\n        break;\n\n      case 'i8':\n        HEAP8[ptr >> 0] = value;\n        break;\n\n      case 'i16':\n        HEAP16[ptr >> 1] = value;\n        break;\n\n      case 'i32':\n        HEAP32[ptr >> 2] = value;\n        break;\n\n      case 'i64':\n        tempI64 = [value >>> 0, (tempDouble = value, +Math_abs(tempDouble) >= 1.0 ? tempDouble > 0.0 ? (Math_min(+Math_floor(tempDouble / 4294967296.0), 4294967295.0) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0) >>> 0 : 0)], HEAP32[ptr >> 2] = tempI64[0], HEAP32[ptr + 4 >> 2] = tempI64[1];\n        break;\n\n      case 'float':\n        HEAPF32[ptr >> 2] = value;\n        break;\n\n      case 'double':\n        HEAPF64[ptr >> 3] = value;\n        break;\n\n      default:\n        abort('invalid type for setValue: ' + type);\n    }\n  }\n  /** @type {function(number, string, boolean=)} */\n\n\n  function getValue(ptr, type, noSafe) {\n    type = type || 'i8';\n    if (type.charAt(type.length - 1) === '*') type = 'i32'; // pointers are 32-bit\n\n    switch (type) {\n      case 'i1':\n        return HEAP8[ptr >> 0];\n\n      case 'i8':\n        return HEAP8[ptr >> 0];\n\n      case 'i16':\n        return HEAP16[ptr >> 1];\n\n      case 'i32':\n        return HEAP32[ptr >> 2];\n\n      case 'i64':\n        return HEAP32[ptr >> 2];\n\n      case 'float':\n        return HEAPF32[ptr >> 2];\n\n      case 'double':\n        return HEAPF64[ptr >> 3];\n\n      default:\n        abort('invalid type for getValue: ' + type);\n    }\n\n    return null;\n  }\n\n  var ALLOC_NORMAL = 0; // Tries to use _malloc()\n\n  var ALLOC_STACK = 1; // Lives for the duration of the current function call\n\n  var ALLOC_STATIC = 2; // Cannot be freed\n\n  var ALLOC_DYNAMIC = 3; // Cannot be freed except through sbrk\n\n  var ALLOC_NONE = 4; // Do not allocate\n  // allocate(): This is for internal use. You can use it yourself as well, but the interface\n  //             is a little tricky (see docs right below). The reason is that it is optimized\n  //             for multiple syntaxes to save space in generated code. So you should\n  //             normally not use allocate(), and instead allocate memory using _malloc(),\n  //             initialize it with setValue(), and so forth.\n  // @slab: An array of data, or a number. If a number, then the size of the block to allocate,\n  //        in *bytes* (note that this is sometimes confusing: the next parameter does not\n  //        affect this!)\n  // @types: Either an array of types, one for each byte (or 0 if no type at that position),\n  //         or a single type which is used for the entire block. This only matters if there\n  //         is initial data - if @slab is a number, then this does not matter at all and is\n  //         ignored.\n  // @allocator: How to allocate memory, see ALLOC_*\n\n  /** @type {function((TypedArray|Array<number>|number), string, number, number=)} */\n\n  function allocate(slab, types, allocator, ptr) {\n    var zeroinit, size;\n\n    if (typeof slab === 'number') {\n      zeroinit = true;\n      size = slab;\n    } else {\n      zeroinit = false;\n      size = slab.length;\n    }\n\n    var singleType = typeof types === 'string' ? types : null;\n    var ret;\n\n    if (allocator == ALLOC_NONE) {\n      ret = ptr;\n    } else {\n      ret = [typeof _malloc === 'function' ? _malloc : staticAlloc, stackAlloc, staticAlloc, dynamicAlloc][allocator === undefined ? ALLOC_STATIC : allocator](Math.max(size, singleType ? 1 : types.length));\n    }\n\n    if (zeroinit) {\n      var stop;\n      ptr = ret;\n      assert((ret & 3) == 0);\n      stop = ret + (size & ~3);\n\n      for (; ptr < stop; ptr += 4) {\n        HEAP32[ptr >> 2] = 0;\n      }\n\n      stop = ret + size;\n\n      while (ptr < stop) {\n        HEAP8[ptr++ >> 0] = 0;\n      }\n\n      return ret;\n    }\n\n    if (singleType === 'i8') {\n      if (slab.subarray || slab.slice) {\n        HEAPU8.set(\n        /** @type {!Uint8Array} */\n        slab, ret);\n      } else {\n        HEAPU8.set(new Uint8Array(slab), ret);\n      }\n\n      return ret;\n    }\n\n    var i = 0,\n        type,\n        typeSize,\n        previousType;\n\n    while (i < size) {\n      var curr = slab[i];\n      type = singleType || types[i];\n\n      if (type === 0) {\n        i++;\n        continue;\n      }\n\n      assert(type, 'Must know what type to store in allocate!');\n      if (type == 'i64') type = 'i32'; // special case: we have one i32 here, and one i32 later\n\n      setValue(ret + i, curr, type); // no need to look up size unless type changes, so cache it\n\n      if (previousType !== type) {\n        typeSize = getNativeTypeSize(type);\n        previousType = type;\n      }\n\n      i += typeSize;\n    }\n\n    return ret;\n  } // Allocate memory during any stage of startup - static memory early on, dynamic memory later, malloc when ready\n\n\n  function getMemory(size) {\n    if (!staticSealed) return staticAlloc(size);\n    if (!runtimeInitialized) return dynamicAlloc(size);\n    return _malloc(size);\n  }\n  /** @type {function(number, number=)} */\n\n\n  function Pointer_stringify(ptr, length) {\n    if (length === 0 || !ptr) return ''; // TODO: use TextDecoder\n    // Find the length, and check for UTF while doing so\n\n    var hasUtf = 0;\n    var t;\n    var i = 0;\n\n    while (1) {\n      assert(ptr + i < TOTAL_MEMORY);\n      t = HEAPU8[ptr + i >> 0];\n      hasUtf |= t;\n      if (t == 0 && !length) break;\n      i++;\n      if (length && i == length) break;\n    }\n\n    if (!length) length = i;\n    var ret = '';\n\n    if (hasUtf < 128) {\n      var MAX_CHUNK = 1024; // split up into chunks, because .apply on a huge string can overflow the stack\n\n      var curr;\n\n      while (length > 0) {\n        curr = String.fromCharCode.apply(String, HEAPU8.subarray(ptr, ptr + Math.min(length, MAX_CHUNK)));\n        ret = ret ? ret + curr : curr;\n        ptr += MAX_CHUNK;\n        length -= MAX_CHUNK;\n      }\n\n      return ret;\n    }\n\n    return UTF8ToString(ptr);\n  } // Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns\n  // a copy of that string as a Javascript String object.\n\n\n  function AsciiToString(ptr) {\n    var str = '';\n\n    while (1) {\n      var ch = HEAP8[ptr++ >> 0];\n      if (!ch) return str;\n      str += String.fromCharCode(ch);\n    }\n  } // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n  // null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.\n\n\n  function stringToAscii(str, outPtr) {\n    return writeAsciiToMemory(str, outPtr, false);\n  } // Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns\n  // a copy of that string as a Javascript String object.\n\n\n  var UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined;\n\n  function UTF8ArrayToString(u8Array, idx) {\n    var endPtr = idx; // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\n    // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\n\n    while (u8Array[endPtr]) {\n      ++endPtr;\n    }\n\n    if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {\n      return UTF8Decoder.decode(u8Array.subarray(idx, endPtr));\n    } else {\n      var u0, u1, u2, u3, u4, u5;\n      var str = '';\n\n      while (1) {\n        // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629\n        u0 = u8Array[idx++];\n        if (!u0) return str;\n\n        if (!(u0 & 0x80)) {\n          str += String.fromCharCode(u0);\n          continue;\n        }\n\n        u1 = u8Array[idx++] & 63;\n\n        if ((u0 & 0xE0) == 0xC0) {\n          str += String.fromCharCode((u0 & 31) << 6 | u1);\n          continue;\n        }\n\n        u2 = u8Array[idx++] & 63;\n\n        if ((u0 & 0xF0) == 0xE0) {\n          u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n        } else {\n          u3 = u8Array[idx++] & 63;\n\n          if ((u0 & 0xF8) == 0xF0) {\n            u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | u3;\n          } else {\n            u4 = u8Array[idx++] & 63;\n\n            if ((u0 & 0xFC) == 0xF8) {\n              u0 = (u0 & 3) << 24 | u1 << 18 | u2 << 12 | u3 << 6 | u4;\n            } else {\n              u5 = u8Array[idx++] & 63;\n              u0 = (u0 & 1) << 30 | u1 << 24 | u2 << 18 | u3 << 12 | u4 << 6 | u5;\n            }\n          }\n        }\n\n        if (u0 < 0x10000) {\n          str += String.fromCharCode(u0);\n        } else {\n          var ch = u0 - 0x10000;\n          str += String.fromCharCode(0xD800 | ch >> 10, 0xDC00 | ch & 0x3FF);\n        }\n      }\n    }\n  } // Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns\n  // a copy of that string as a Javascript String object.\n\n\n  function UTF8ToString(ptr) {\n    return UTF8ArrayToString(HEAPU8, ptr);\n  } // Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',\n  // encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.\n  // Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\n  // Parameters:\n  //   str: the Javascript string to copy.\n  //   outU8Array: the array to copy to. Each index in this array is assumed to be one 8-byte element.\n  //   outIdx: The starting offset in the array to begin the copying.\n  //   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\n  //                    terminator, i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.\n  //                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.\n  // Returns the number of bytes written, EXCLUDING the null terminator.\n\n\n  function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {\n    if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.\n      return 0;\n    var startIdx = outIdx;\n    var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.\n\n    for (var i = 0; i < str.length; ++i) {\n      // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\n      // See http://unicode.org/faq/utf_bom.html#utf16-3\n      // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629\n      var u = str.charCodeAt(i); // possibly a lead surrogate\n\n      if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | str.charCodeAt(++i) & 0x3FF;\n\n      if (u <= 0x7F) {\n        if (outIdx >= endIdx) break;\n        outU8Array[outIdx++] = u;\n      } else if (u <= 0x7FF) {\n        if (outIdx + 1 >= endIdx) break;\n        outU8Array[outIdx++] = 0xC0 | u >> 6;\n        outU8Array[outIdx++] = 0x80 | u & 63;\n      } else if (u <= 0xFFFF) {\n        if (outIdx + 2 >= endIdx) break;\n        outU8Array[outIdx++] = 0xE0 | u >> 12;\n        outU8Array[outIdx++] = 0x80 | u >> 6 & 63;\n        outU8Array[outIdx++] = 0x80 | u & 63;\n      } else if (u <= 0x1FFFFF) {\n        if (outIdx + 3 >= endIdx) break;\n        outU8Array[outIdx++] = 0xF0 | u >> 18;\n        outU8Array[outIdx++] = 0x80 | u >> 12 & 63;\n        outU8Array[outIdx++] = 0x80 | u >> 6 & 63;\n        outU8Array[outIdx++] = 0x80 | u & 63;\n      } else if (u <= 0x3FFFFFF) {\n        if (outIdx + 4 >= endIdx) break;\n        outU8Array[outIdx++] = 0xF8 | u >> 24;\n        outU8Array[outIdx++] = 0x80 | u >> 18 & 63;\n        outU8Array[outIdx++] = 0x80 | u >> 12 & 63;\n        outU8Array[outIdx++] = 0x80 | u >> 6 & 63;\n        outU8Array[outIdx++] = 0x80 | u & 63;\n      } else {\n        if (outIdx + 5 >= endIdx) break;\n        outU8Array[outIdx++] = 0xFC | u >> 30;\n        outU8Array[outIdx++] = 0x80 | u >> 24 & 63;\n        outU8Array[outIdx++] = 0x80 | u >> 18 & 63;\n        outU8Array[outIdx++] = 0x80 | u >> 12 & 63;\n        outU8Array[outIdx++] = 0x80 | u >> 6 & 63;\n        outU8Array[outIdx++] = 0x80 | u & 63;\n      }\n    } // Null-terminate the pointer to the buffer.\n\n\n    outU8Array[outIdx] = 0;\n    return outIdx - startIdx;\n  } // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n  // null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.\n  // Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\n  // Returns the number of bytes written, EXCLUDING the null terminator.\n\n\n  function stringToUTF8(str, outPtr, maxBytesToWrite) {\n    assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\n    return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n  } // Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.\n\n\n  function lengthBytesUTF8(str) {\n    var len = 0;\n\n    for (var i = 0; i < str.length; ++i) {\n      // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\n      // See http://unicode.org/faq/utf_bom.html#utf16-3\n      var u = str.charCodeAt(i); // possibly a lead surrogate\n\n      if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | str.charCodeAt(++i) & 0x3FF;\n\n      if (u <= 0x7F) {\n        ++len;\n      } else if (u <= 0x7FF) {\n        len += 2;\n      } else if (u <= 0xFFFF) {\n        len += 3;\n      } else if (u <= 0x1FFFFF) {\n        len += 4;\n      } else if (u <= 0x3FFFFFF) {\n        len += 5;\n      } else {\n        len += 6;\n      }\n    }\n\n    return len;\n  } // Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns\n  // a copy of that string as a Javascript String object.\n\n\n  var UTF16Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-16le') : undefined;\n\n  function UTF16ToString(ptr) {\n    assert(ptr % 2 == 0, 'Pointer passed to UTF16ToString must be aligned to two bytes!');\n    var endPtr = ptr; // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\n    // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\n\n    var idx = endPtr >> 1;\n\n    while (HEAP16[idx]) {\n      ++idx;\n    }\n\n    endPtr = idx << 1;\n\n    if (endPtr - ptr > 32 && UTF16Decoder) {\n      return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\n    } else {\n      var i = 0;\n      var str = '';\n\n      while (1) {\n        var codeUnit = HEAP16[ptr + i * 2 >> 1];\n        if (codeUnit == 0) return str;\n        ++i; // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.\n\n        str += String.fromCharCode(codeUnit);\n      }\n    }\n  } // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n  // null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.\n  // Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.\n  // Parameters:\n  //   str: the Javascript string to copy.\n  //   outPtr: Byte address in Emscripten HEAP where to write the string to.\n  //   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\n  //                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.\n  //                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.\n  // Returns the number of bytes written, EXCLUDING the null terminator.\n\n\n  function stringToUTF16(str, outPtr, maxBytesToWrite) {\n    assert(outPtr % 2 == 0, 'Pointer passed to stringToUTF16 must be aligned to two bytes!');\n    assert(typeof maxBytesToWrite == 'number', 'stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!'); // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n\n    if (maxBytesToWrite === undefined) {\n      maxBytesToWrite = 0x7FFFFFFF;\n    }\n\n    if (maxBytesToWrite < 2) return 0;\n    maxBytesToWrite -= 2; // Null terminator.\n\n    var startPtr = outPtr;\n    var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;\n\n    for (var i = 0; i < numCharsToWrite; ++i) {\n      // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.\n      var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n\n      HEAP16[outPtr >> 1] = codeUnit;\n      outPtr += 2;\n    } // Null-terminate the pointer to the HEAP.\n\n\n    HEAP16[outPtr >> 1] = 0;\n    return outPtr - startPtr;\n  } // Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\n\n\n  function lengthBytesUTF16(str) {\n    return str.length * 2;\n  }\n\n  function UTF32ToString(ptr) {\n    assert(ptr % 4 == 0, 'Pointer passed to UTF32ToString must be aligned to four bytes!');\n    var i = 0;\n    var str = '';\n\n    while (1) {\n      var utf32 = HEAP32[ptr + i * 4 >> 2];\n      if (utf32 == 0) return str;\n      ++i; // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.\n      // See http://unicode.org/faq/utf_bom.html#utf16-3\n\n      if (utf32 >= 0x10000) {\n        var ch = utf32 - 0x10000;\n        str += String.fromCharCode(0xD800 | ch >> 10, 0xDC00 | ch & 0x3FF);\n      } else {\n        str += String.fromCharCode(utf32);\n      }\n    }\n  } // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n  // null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.\n  // Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.\n  // Parameters:\n  //   str: the Javascript string to copy.\n  //   outPtr: Byte address in Emscripten HEAP where to write the string to.\n  //   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\n  //                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.\n  //                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.\n  // Returns the number of bytes written, EXCLUDING the null terminator.\n\n\n  function stringToUTF32(str, outPtr, maxBytesToWrite) {\n    assert(outPtr % 4 == 0, 'Pointer passed to stringToUTF32 must be aligned to four bytes!');\n    assert(typeof maxBytesToWrite == 'number', 'stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!'); // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n\n    if (maxBytesToWrite === undefined) {\n      maxBytesToWrite = 0x7FFFFFFF;\n    }\n\n    if (maxBytesToWrite < 4) return 0;\n    var startPtr = outPtr;\n    var endPtr = startPtr + maxBytesToWrite - 4;\n\n    for (var i = 0; i < str.length; ++i) {\n      // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\n      // See http://unicode.org/faq/utf_bom.html#utf16-3\n      var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n\n      if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {\n        var trailSurrogate = str.charCodeAt(++i);\n        codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | trailSurrogate & 0x3FF;\n      }\n\n      HEAP32[outPtr >> 2] = codeUnit;\n      outPtr += 4;\n      if (outPtr + 4 > endPtr) break;\n    } // Null-terminate the pointer to the HEAP.\n\n\n    HEAP32[outPtr >> 2] = 0;\n    return outPtr - startPtr;\n  } // Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\n\n\n  function lengthBytesUTF32(str) {\n    var len = 0;\n\n    for (var i = 0; i < str.length; ++i) {\n      // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\n      // See http://unicode.org/faq/utf_bom.html#utf16-3\n      var codeUnit = str.charCodeAt(i);\n      if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.\n\n      len += 4;\n    }\n\n    return len;\n  } // Allocate heap space for a JS string, and write it there.\n  // It is the responsibility of the caller to free() that memory.\n\n\n  function allocateUTF8(str) {\n    var size = lengthBytesUTF8(str) + 1;\n\n    var ret = _malloc(size);\n\n    if (ret) stringToUTF8Array(str, HEAP8, ret, size);\n    return ret;\n  } // Allocate stack space for a JS string, and write it there.\n\n\n  function allocateUTF8OnStack(str) {\n    var size = lengthBytesUTF8(str) + 1;\n    var ret = stackAlloc(size);\n    stringToUTF8Array(str, HEAP8, ret, size);\n    return ret;\n  }\n\n  function demangle(func) {\n    warnOnce('warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling');\n    return func;\n  }\n\n  function demangleAll(text) {\n    var regex = /__Z[\\w\\d_]+/g;\n    return text.replace(regex, function (x) {\n      var y = demangle(x);\n      return x === y ? x : x + ' [' + y + ']';\n    });\n  }\n\n  function jsStackTrace() {\n    var err = new Error();\n\n    if (!err.stack) {\n      // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,\n      // so try that as a special-case.\n      try {\n        throw new Error(0);\n      } catch (e) {\n        err = e;\n      }\n\n      if (!err.stack) {\n        return '(no stack trace available)';\n      }\n    }\n\n    return err.stack.toString();\n  }\n\n  function stackTrace() {\n    var js = jsStackTrace();\n    if (_Module['extraStackTrace']) js += '\\n' + _Module['extraStackTrace']();\n    return demangleAll(js);\n  } // Memory management\n\n\n  var PAGE_SIZE = 16384;\n  var WASM_PAGE_SIZE = 65536;\n  var ASMJS_PAGE_SIZE = 16777216;\n  var MIN_TOTAL_MEMORY = 16777216;\n\n  function alignUp(x, multiple) {\n    if (x % multiple > 0) {\n      x += multiple - x % multiple;\n    }\n\n    return x;\n  }\n\n  var HEAP,\n  /** @type {ArrayBuffer} */\n  buffer,\n  /** @type {Int8Array} */\n  HEAP8,\n  /** @type {Uint8Array} */\n  HEAPU8,\n  /** @type {Int16Array} */\n  HEAP16,\n  /** @type {Uint16Array} */\n  HEAPU16,\n  /** @type {Int32Array} */\n  HEAP32,\n  /** @type {Uint32Array} */\n  HEAPU32,\n  /** @type {Float32Array} */\n  HEAPF32,\n  /** @type {Float64Array} */\n  HEAPF64;\n\n  function updateGlobalBuffer(buf) {\n    _Module['buffer'] = buffer = buf;\n  }\n\n  function updateGlobalBufferViews() {\n    _Module['HEAP8'] = HEAP8 = new Int8Array(buffer);\n    _Module['HEAP16'] = HEAP16 = new Int16Array(buffer);\n    _Module['HEAP32'] = HEAP32 = new Int32Array(buffer);\n    _Module['HEAPU8'] = HEAPU8 = new Uint8Array(buffer);\n    _Module['HEAPU16'] = HEAPU16 = new Uint16Array(buffer);\n    _Module['HEAPU32'] = HEAPU32 = new Uint32Array(buffer);\n    _Module['HEAPF32'] = HEAPF32 = new Float32Array(buffer);\n    _Module['HEAPF64'] = HEAPF64 = new Float64Array(buffer);\n  }\n\n  var STATIC_BASE, STATICTOP, staticSealed; // static area\n\n  var STACK_BASE, STACKTOP, STACK_MAX; // stack area\n\n  var DYNAMIC_BASE, DYNAMICTOP_PTR; // dynamic area handled by sbrk\n\n  STATIC_BASE = STATICTOP = STACK_BASE = STACKTOP = STACK_MAX = DYNAMIC_BASE = DYNAMICTOP_PTR = 0;\n  staticSealed = false; // Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.\n\n  function writeStackCookie() {\n    assert((STACK_MAX & 3) == 0);\n    HEAPU32[(STACK_MAX >> 2) - 1] = 0x02135467;\n    HEAPU32[(STACK_MAX >> 2) - 2] = 0x89BACDFE;\n  }\n\n  function checkStackCookie() {\n    if (HEAPU32[(STACK_MAX >> 2) - 1] != 0x02135467 || HEAPU32[(STACK_MAX >> 2) - 2] != 0x89BACDFE) {\n      abort('Stack overflow! Stack cookie has been overwritten, expected hex dwords 0x89BACDFE and 0x02135467, but received 0x' + HEAPU32[(STACK_MAX >> 2) - 2].toString(16) + ' ' + HEAPU32[(STACK_MAX >> 2) - 1].toString(16));\n    } // Also test the global address 0 for integrity. This check is not compatible with SAFE_SPLIT_MEMORY though, since that mode already tests all address 0 accesses on its own.\n\n\n    if (HEAP32[0] !== 0x63736d65\n    /* 'emsc' */\n    ) throw 'Runtime error: The application has corrupted its heap memory area (address zero)!';\n  }\n\n  function abortStackOverflow(allocSize) {\n    abort('Stack overflow! Attempted to allocate ' + allocSize + ' bytes on the stack, but stack has only ' + (STACK_MAX - _stackSave() + allocSize) + ' bytes available!');\n  }\n\n  function abortOnCannotGrowMemory() {\n    abort('Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value ' + TOTAL_MEMORY + ', (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ');\n  }\n\n  function enlargeMemory() {\n    abortOnCannotGrowMemory();\n  }\n\n  var TOTAL_STACK = _Module['TOTAL_STACK'] || 5242880;\n  var TOTAL_MEMORY = _Module['TOTAL_MEMORY'] || 16777216;\n  if (TOTAL_MEMORY < TOTAL_STACK) _Module.printErr('TOTAL_MEMORY should be larger than TOTAL_STACK, was ' + TOTAL_MEMORY + '! (TOTAL_STACK=' + TOTAL_STACK + ')'); // Initialize the runtime's memory\n  // check for full engine support (use string 'subarray' to avoid closure compiler confusion)\n\n  assert(typeof Int32Array !== 'undefined' && typeof Float64Array !== 'undefined' && Int32Array.prototype.subarray !== undefined && Int32Array.prototype.set !== undefined, 'JS engine does not provide full typed array support'); // Use a provided buffer, if there is one, or else allocate a new one\n\n  if (_Module['buffer']) {\n    buffer = _Module['buffer'];\n    assert(buffer.byteLength === TOTAL_MEMORY, 'provided buffer should be ' + TOTAL_MEMORY + ' bytes, but it is ' + buffer.byteLength);\n  } else {\n    // Use a WebAssembly memory where available\n    if ((typeof WebAssembly === \"undefined\" ? \"undefined\" : _typeof(WebAssembly)) === 'object' && typeof WebAssembly.Memory === 'function') {\n      assert(TOTAL_MEMORY % WASM_PAGE_SIZE === 0);\n      _Module['wasmMemory'] = new WebAssembly.Memory({\n        'initial': TOTAL_MEMORY / WASM_PAGE_SIZE,\n        'maximum': TOTAL_MEMORY / WASM_PAGE_SIZE\n      });\n      buffer = _Module['wasmMemory'].buffer;\n    } else {\n      buffer = new ArrayBuffer(TOTAL_MEMORY);\n    }\n\n    assert(buffer.byteLength === TOTAL_MEMORY);\n    _Module['buffer'] = buffer;\n  }\n\n  updateGlobalBufferViews();\n\n  function getTotalMemory() {\n    return TOTAL_MEMORY;\n  } // Endianness check (note: assumes compiler arch was little-endian)\n\n\n  HEAP32[0] = 0x63736d65;\n  /* 'emsc' */\n\n  HEAP16[1] = 0x6373;\n  if (HEAPU8[2] !== 0x73 || HEAPU8[3] !== 0x63) throw 'Runtime error: expected the system to be little-endian!';\n\n  function callRuntimeCallbacks(callbacks) {\n    while (callbacks.length > 0) {\n      var callback = callbacks.shift();\n\n      if (typeof callback == 'function') {\n        callback();\n        continue;\n      }\n\n      var func = callback.func;\n\n      if (typeof func === 'number') {\n        if (callback.arg === undefined) {\n          _Module['dynCall_v'](func);\n        } else {\n          _Module['dynCall_vi'](func, callback.arg);\n        }\n      } else {\n        func(callback.arg === undefined ? null : callback.arg);\n      }\n    }\n  }\n\n  var __ATPRERUN__ = []; // functions called before the runtime is initialized\n\n  var __ATINIT__ = []; // functions called during startup\n\n  var __ATMAIN__ = []; // functions called when main() is to be run\n\n  var __ATEXIT__ = []; // functions called during shutdown\n\n  var __ATPOSTRUN__ = []; // functions called after the runtime has exited\n\n  var runtimeInitialized = false;\n  var runtimeExited = false;\n\n  function preRun() {\n    // compatibility - merge in anything from Module['preRun'] at this time\n    if (_Module['preRun']) {\n      if (typeof _Module['preRun'] == 'function') _Module['preRun'] = [_Module['preRun']];\n\n      while (_Module['preRun'].length) {\n        addOnPreRun(_Module['preRun'].shift());\n      }\n    }\n\n    callRuntimeCallbacks(__ATPRERUN__);\n  }\n\n  function ensureInitRuntime() {\n    checkStackCookie();\n    if (runtimeInitialized) return;\n    runtimeInitialized = true;\n    callRuntimeCallbacks(__ATINIT__);\n  }\n\n  function preMain() {\n    checkStackCookie();\n    callRuntimeCallbacks(__ATMAIN__);\n  }\n\n  function exitRuntime() {\n    checkStackCookie();\n    callRuntimeCallbacks(__ATEXIT__);\n    runtimeExited = true;\n  }\n\n  function postRun() {\n    checkStackCookie(); // compatibility - merge in anything from Module['postRun'] at this time\n\n    if (_Module['postRun']) {\n      if (typeof _Module['postRun'] == 'function') _Module['postRun'] = [_Module['postRun']];\n\n      while (_Module['postRun'].length) {\n        addOnPostRun(_Module['postRun'].shift());\n      }\n    }\n\n    callRuntimeCallbacks(__ATPOSTRUN__);\n  }\n\n  function addOnPreRun(cb) {\n    __ATPRERUN__.unshift(cb);\n  }\n\n  function addOnInit(cb) {\n    __ATINIT__.unshift(cb);\n  }\n\n  function addOnPreMain(cb) {\n    __ATMAIN__.unshift(cb);\n  }\n\n  function addOnExit(cb) {\n    __ATEXIT__.unshift(cb);\n  }\n\n  function addOnPostRun(cb) {\n    __ATPOSTRUN__.unshift(cb);\n  } // Deprecated: This function should not be called because it is unsafe and does not provide\n  // a maximum length limit of how many bytes it is allowed to write. Prefer calling the\n  // function stringToUTF8Array() instead, which takes in a maximum length that can be used\n  // to be secure from out of bounds writes.\n\n  /** @deprecated */\n\n\n  function writeStringToMemory(string, buffer, dontAddNull) {\n    warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');\n    var\n    /** @type {number} */\n    lastChar,\n    /** @type {number} */\n    end;\n\n    if (dontAddNull) {\n      // stringToUTF8Array always appends null. If we don't want to do that, remember the\n      // character that existed at the location where the null will be placed, and restore\n      // that after the write (below).\n      end = buffer + lengthBytesUTF8(string);\n      lastChar = HEAP8[end];\n    }\n\n    stringToUTF8(string, buffer, Infinity);\n    if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.\n  }\n\n  function writeArrayToMemory(array, buffer) {\n    assert(array.length >= 0, 'writeArrayToMemory array must have a length (should be an array or typed array)');\n    HEAP8.set(array, buffer);\n  }\n\n  function writeAsciiToMemory(str, buffer, dontAddNull) {\n    for (var i = 0; i < str.length; ++i) {\n      assert(str.charCodeAt(i) === str.charCodeAt(i) & 0xff);\n      HEAP8[buffer++ >> 0] = str.charCodeAt(i);\n    } // Null-terminate the pointer to the HEAP.\n\n\n    if (!dontAddNull) HEAP8[buffer >> 0] = 0;\n  }\n\n  function unSign(value, bits, ignore) {\n    if (value >= 0) {\n      return value;\n    }\n\n    return bits <= 32 ? 2 * Math.abs(1 << bits - 1) + value // Need some trickery, since if bits == 32, we are right at the limit of the bits JS uses in bitshifts\n    : Math.pow(2, bits) + value;\n  }\n\n  function reSign(value, bits, ignore) {\n    if (value <= 0) {\n      return value;\n    }\n\n    var half = bits <= 32 ? Math.abs(1 << bits - 1) // abs is needed if bits == 32\n    : Math.pow(2, bits - 1);\n\n    if (value >= half && (bits <= 32 || value > half)) {\n      // for huge values, we can hit the precision limit and always get true here. so don't do that\n      // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors\n      // TODO: In i64 mode 1, resign the two parts separately and safely\n      value = -2 * half + value; // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts\n    }\n\n    return value;\n  }\n\n  assert(Math['imul'] && Math['fround'] && Math['clz32'] && Math['trunc'], 'this is a legacy browser, build with LEGACY_VM_SUPPORT');\n  var Math_abs = Math.abs;\n  var Math_cos = Math.cos;\n  var Math_sin = Math.sin;\n  var Math_tan = Math.tan;\n  var Math_acos = Math.acos;\n  var Math_asin = Math.asin;\n  var Math_atan = Math.atan;\n  var Math_atan2 = Math.atan2;\n  var Math_exp = Math.exp;\n  var Math_log = Math.log;\n  var Math_sqrt = Math.sqrt;\n  var Math_ceil = Math.ceil;\n  var Math_floor = Math.floor;\n  var Math_pow = Math.pow;\n  var Math_imul = Math.imul;\n  var Math_fround = Math.fround;\n  var Math_round = Math.round;\n  var Math_min = Math.min;\n  var Math_max = Math.max;\n  var Math_clz32 = Math.clz32;\n  var Math_trunc = Math.trunc; // A counter of dependencies for calling run(). If we need to\n  // do asynchronous work before running, increment this and\n  // decrement it. Incrementing must happen in a place like\n  // PRE_RUN_ADDITIONS (used by emcc to add file preloading).\n  // Note that you can add dependencies in preRun, even though\n  // it happens right before run - run will be postponed until\n  // the dependencies are met.\n\n  var runDependencies = 0;\n  var runDependencyWatcher = null;\n  var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled\n\n  var runDependencyTracking = {};\n\n  function getUniqueRunDependency(id) {\n    var orig = id;\n\n    while (1) {\n      if (!runDependencyTracking[id]) return id;\n      id = orig + Math.random();\n    }\n\n    return id;\n  }\n\n  function addRunDependency(id) {\n    runDependencies++;\n\n    if (_Module['monitorRunDependencies']) {\n      _Module['monitorRunDependencies'](runDependencies);\n    }\n\n    if (id) {\n      assert(!runDependencyTracking[id]);\n      runDependencyTracking[id] = 1;\n\n      if (runDependencyWatcher === null && typeof setInterval !== 'undefined') {\n        // Check for missing dependencies every few seconds\n        runDependencyWatcher = setInterval(function () {\n          if (ABORT) {\n            clearInterval(runDependencyWatcher);\n            runDependencyWatcher = null;\n            return;\n          }\n\n          var shown = false;\n\n          for (var dep in runDependencyTracking) {\n            if (!shown) {\n              shown = true;\n\n              _Module.printErr('still waiting on run dependencies:');\n            }\n\n            _Module.printErr('dependency: ' + dep);\n          }\n\n          if (shown) {\n            _Module.printErr('(end of list)');\n          }\n        }, 10000);\n      }\n    } else {\n      _Module.printErr('warning: run dependency added without ID');\n    }\n  }\n\n  function removeRunDependency(id) {\n    runDependencies--;\n\n    if (_Module['monitorRunDependencies']) {\n      _Module['monitorRunDependencies'](runDependencies);\n    }\n\n    if (id) {\n      assert(runDependencyTracking[id]);\n      delete runDependencyTracking[id];\n    } else {\n      _Module.printErr('warning: run dependency removed without ID');\n    }\n\n    if (runDependencies == 0) {\n      if (runDependencyWatcher !== null) {\n        clearInterval(runDependencyWatcher);\n        runDependencyWatcher = null;\n      }\n\n      if (dependenciesFulfilled) {\n        var callback = dependenciesFulfilled;\n        dependenciesFulfilled = null;\n        callback(); // can add another dependenciesFulfilled\n      }\n    }\n  }\n\n  _Module[\"preloadedImages\"] = {}; // maps url to image data\n\n  _Module[\"preloadedAudios\"] = {}; // maps url to audio data\n\n  var memoryInitializer = null;\n  var\n  /* show errors on likely calls to FS when it was not included */\n  FS = {\n    error: function error() {\n      abort('Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with  -s FORCE_FILESYSTEM=1');\n    },\n    init: function init() {\n      FS.error();\n    },\n    createDataFile: function createDataFile() {\n      FS.error();\n    },\n    createPreloadedFile: function createPreloadedFile() {\n      FS.error();\n    },\n    createLazyFile: function createLazyFile() {\n      FS.error();\n    },\n    open: function open() {\n      FS.error();\n    },\n    mkdev: function mkdev() {\n      FS.error();\n    },\n    registerDevice: function registerDevice() {\n      FS.error();\n    },\n    analyzePath: function analyzePath() {\n      FS.error();\n    },\n    loadFilesFromDB: function loadFilesFromDB() {\n      FS.error();\n    },\n    ErrnoError: function ErrnoError() {\n      FS.error();\n    }\n  };\n  _Module['FS_createDataFile'] = FS.createDataFile;\n  _Module['FS_createPreloadedFile'] = FS.createPreloadedFile; // Prefix of data URIs emitted by SINGLE_FILE and related options.\n\n  var dataURIPrefix = 'data:application/octet-stream;base64,'; // Indicates whether filename is a base64 data URI.\n\n  function isDataURI(filename) {\n    return String.prototype.startsWith ? filename.startsWith(dataURIPrefix) : filename.indexOf(dataURIPrefix) === 0;\n  }\n\n  function integrateWasmJS() {\n    // wasm.js has several methods for creating the compiled code module here:\n    //  * 'native-wasm' : use native WebAssembly support in the browser\n    //  * 'interpret-s-expr': load s-expression code from a .wast and interpret\n    //  * 'interpret-binary': load binary wasm and interpret\n    //  * 'interpret-asm2wasm': load asm.js code, translate to wasm, and interpret\n    //  * 'asmjs': no wasm, just load the asm.js code and use that (good for testing)\n    // The method is set at compile time (BINARYEN_METHOD)\n    // The method can be a comma-separated list, in which case, we will try the\n    // options one by one. Some of them can fail gracefully, and then we can try\n    // the next.\n    // inputs\n    var method = 'native-wasm';\n    var wasmTextFile = '';\n    var wasmBinaryFile = 'data:application/octet-stream;base64,AGFzbQEAAAABchJgA39/fwF/YAF/AX9gAAF/YAF/AGACf38Bf2AEf39/fwF/YAJ/fwBgA39/fwBgBH9/f38AYAN/f38BfmAAAGAFf39/f38Bf2ADfn9/AX9gAn5/AX9gBX9/f39/AGAGf3x/f39/AX9gAXwBfmACfH8BfAKXBSEDZW52Bm1lbW9yeQIBgAKAAgNlbnYFdGFibGUBcAEQEANlbnYKbWVtb3J5QmFzZQN/AANlbnYJdGFibGVCYXNlA38AA2Vudg5EWU5BTUlDVE9QX1BUUgN/AANlbnYNdGVtcERvdWJsZVB0cgN/AANlbnYFQUJPUlQDfwADZW52CFNUQUNLVE9QA38AA2VudglTVEFDS19NQVgDfwADZW52B2N0dHpfaTgDfwAGZ2xvYmFsA05hTgN8AAZnbG9iYWwISW5maW5pdHkDfAADZW52DWVubGFyZ2VNZW1vcnkAAgNlbnYOZ2V0VG90YWxNZW1vcnkAAgNlbnYXYWJvcnRPbkNhbm5vdEdyb3dNZW1vcnkAAgNlbnYSYWJvcnRTdGFja092ZXJmbG93AAMDZW52C251bGxGdW5jX2lpAAMDZW52DW51bGxGdW5jX2lpaWkAAwNlbnYHX19fbG9jawADA2VudgtfX19zZXRFcnJObwADA2Vudg1fX19zeXNjYWxsMTQwAAQDZW52DV9fX3N5c2NhbGwxNDYABANlbnYMX19fc3lzY2FsbDU0AAQDZW52C19fX3N5c2NhbGw2AAQDZW52CV9fX3VubG9jawADA2VudiFfZW1zY3JpcHRlbl9oYXNfdGhyZWFkaW5nX3N1cHBvcnQAAgNlbnYWX2Vtc2NyaXB0ZW5fbWVtY3B5X2JpZwAAA2VudhJfbGx2bV9zdGFja3Jlc3RvcmUAAwNlbnYPX2xsdm1fc3RhY2tzYXZlAAIDZW52D19wdGhyZWFkX2NyZWF0ZQAFA2Vudg1fcHRocmVhZF9qb2luAAQDZW52E19wdGhyZWFkX211dGV4X2luaXQABANlbnYIX3N5c2NvbmYAAQNSUQECAwYGAwIEAwcDCAcBCAAICQQACgYBAwEAAAECAQAEAAsBAwcBBwwNDQEADgQPEBERAAICAgQEBAAEAAEEAQQEAgoBAQAKAQAAAQEBBAUBAAZyFH8BIwILfwEjAwt/ASMEC38BIwULfwEj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IQQgBA8L9BEDC38EfgV8Iw0hDCAAvSEPIA9CNIghECAQp0H//wNxIQkgCUH/D3EhCgJAAkACQAJAIApBEHRBEHVBAGsOgBAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAQILAkAgAEQAAAAAAAAAAGIhBCAEBEAgAEQAAAAAAADwQ6IhFCAUIAEQRiEVIAEoAgAhBSAFQUBqIQYgFSESIAYhCAUgACESQQAhCAsgASAINgIAIBIhEQwDAAsACwJAIAAhEQwCAAsACwJAIBCnIQcgB0H/D3EhAiACQYJ4aiEDIAEgAzYCACAPQv////////+HgH+DIQ0gDUKAgICAgICA8D+EIQ4gDr8hEyATIRELCyARDwvkBAE7fyMNIT0gAEEARiEYAkAgGARAQQEhAwUgAUGAAUkhIyAjBEAgAUH/AXEhLiAAIC46AABBASEDDAILEEghNyA3QbwBaiE4IDgoAgAhOSA5KAIAITogOkEARiEEIAQEQCABQYB/cSEFIAVBgL8DRiEGIAYEQCABQf8BcSEIIAAgCDoAAEEBIQMMAwUQMSEHIAdB1AA2AgBBfyEDDAMLAAsgAUGAEEkhCSAJBEAgAUEGdiEKIApBwAFyIQsgC0H/AXEhDCAAQQFqIQ0gACAMOgAAIAFBP3EhDiAOQYABciEPIA9B/wFxIRAgDSAQOgAAQQIhAwwCCyABQYCwA0khESABQYBAcSESIBJBgMADRiETIBEgE3IhOyA7BEAgAUEMdiEUIBRB4AFyIRUgFUH/AXEhFiAAQQFqIRcgACAWOgAAIAFBBnYhGSAZQT9xIRogGkGAAXIhGyAbQf8BcSEcIABBAmohHSAXIBw6AAAgAUE/cSEeIB5BgAFyIR8gH0H/AXEhICAdICA6AABBAyED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ADYCACAPQQA2AgAgAkEANgIAIAVBADYCACADQQA2AgBBACEBCyABDws3AQR/Iw0hBiMNQRBqJA0jDSMOTgRAQRAQAwsgBiEDIAMgAjYCACAAIAEgAxA1IQQgBiQNIAQPCwMAAQssACAAQf8BcUEYdCAAQQh1Qf8BcUEQdHIgAEEQdUH/AXFBCHRyIABBGHZyDwvkBAEEfyACQYDAAE4EQCAAIAEgAhAODwsgACEDIAAgAmohBiAAQQNxIAFBA3FGBEADQAJAIABBA3FFBEAMAQsCQCACQQBGBEAgAw8LIAAgASwAADoAACAAQQFqIQAgAUEBaiEBIAJBAWshAgsMAQsLIAZBfHEhBCAEQcAAayEFA0ACQCAAIAVMRQRADAELAkAgACABKAIANgIAIABBBGogAUEEaigCADYCACAAQQhqIAFBCGooAgA2AgAgAEEMaiABQQxqKAIANgIAIABBEGogAUEQaigCADYCACAAQRRqIAFBFGooAgA2AgAgAEEYaiABQRhqKAIANgIAIABBHGogAUEcaigCADYCACAAQSBqIAFBIGooAgA2AgAgAEEkaiABQSRqKAIANgIAIABBKGogAUEoaigCADYCACAAQSxqIAFBLGooAgA2AgAgAEEwaiABQTBqKAIANgIAIABBNGogAUE0aigCADYCACAAQThqIAFBOGooAgA2AgAgAEE8aiABQTxqKAIANgIAIABBwABqIQAgAUHAAGohAQsMAQsLA0ACQCAAIARIRQRADAELAkAgACABKAIANgIAIABBBGohACABQQRqIQELDAELCwUgBkEEayEEA0ACQCAAIARIRQRADAELAkAgACABLAAAOgAAIABBAWogAUEBaiwAADoAACAAQQJqIAFBAmosAAA6AAAgAEEDaiABQQNqLAAAOgAAIABBBGohACABQQRqIQELDAELCwsDQAJAIAAgBkhFBEAMAQsCQCAAIAEsAAA6AAAgAEEBaiEAIAFBAWohAQsMAQsLIAMPC/ECAQR/IAAgAmohAyABQf8BcSEBIAJBwwBOBEADQAJAIABBA3FBAEdFBEAMAQsCQCAAIAE6AAAgAEEBaiEACwwBCwsgA0F8cSEEIARBwABrIQUgASABQQh0ciABQRB0ciABQRh0ciEGA0ACQCAAIAVMRQRADAELAkAgACAGNgIAIABBBGogBjYCACAA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ExQVGggWBygkFxgJCg4bHyUjg4J9JiorPD0+P0NHSk1YWVpbXF1eX2BhY2RlZmdpamtscnN0eXp7fABJbGxlZ2FsIGJ5dGUgc2VxdWVuY2UARG9tYWluIGVycm9yAFJlc3VsdCBub3QgcmVwcmVzZW50YWJsZQBOb3QgYSB0dHkAUGVybWlzc2lvbiBkZW5pZWQAT3BlcmF0aW9uIG5vdCBwZXJtaXR0ZWQATm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeQBObyBzdWNoIHByb2Nlc3MARmlsZSBleGlzdHMAVmFsdWUgdG9vIGxhcmdlIGZvciBkYXRhIHR5cGUATm8gc3BhY2UgbGVmdCBvbiBkZXZpY2UAT3V0IG9mIG1lbW9yeQBSZXNvdXJjZSBidXN5AEludGVycnVwdGVkIHN5c3RlbSBjYWxsAFJlc291cmNlIHRlbXBvcmFyaWx5IHVuYXZhaWxhYmxlAEludmFsaWQgc2VlawBDcm9zcy1kZXZpY2UgbGluawBSZWFkLW9ubHkgZmlsZSBzeXN0ZW0ARGlyZWN0b3J5IG5vdCBlbXB0eQBDb25uZWN0aW9uIHJlc2V0IGJ5IHBlZXIAT3BlcmF0aW9uIHRpbWVkIG91dABDb25uZWN0aW9uIHJlZnVzZWQASG9zdCBpcyBkb3duAEhvc3QgaXMgdW5yZWFjaGFibGUAQWRkcmVzcyBpbiB1c2UAQnJva2VuIHBpcGUASS9PIGVycm9yAE5vIHN1Y2ggZGV2aWNlIG9yIGFkZHJlc3MAQmxvY2sgZGV2aWNlIHJlcXVpcmVkAE5vIHN1Y2ggZGV2aWNlAE5vdCBhIGRpcmVjdG9yeQBJcyBhIGRpcmVjdG9yeQBUZXh0IGZpbGUgYnVzeQBFeGVjIGZvcm1hdCBlcnJvcgBJbnZhbGlkIGFyZ3VtZW50AEFyZ3VtZW50IGxpc3QgdG9vIGxvbmcAU3ltYm9saWMgbGluayBsb29wAEZpbGVuYW1lIHRvbyBsb25nAFRvbyBtYW55IG9wZW4gZmlsZXMgaW4gc3lzdGVtAE5vIGZpbGUgZGVzY3JpcHRvcnMgYXZhaWxhYmxlAEJhZCBmaWxlIGRlc2NyaXB0b3IATm8gY2hpbGQgcHJvY2VzcwBCYWQgYWRkcmVzcwBGaWxlIHRvbyBsYXJnZQBUb28gbWFueSBsaW5rcwBObyBsb2NrcyBhdmFpbGFibGUAUmVzb3VyY2UgZGVhZGxvY2sgd291bGQgb2NjdXIAU3RhdGUgbm90IHJlY292ZXJhYmxlAFByZXZpb3VzIG93bmVyIGRpZWQAT3BlcmF0aW9uIGNhbmNlbGVkAEZ1bmN0aW9uIG5vdCBpbXBsZW1lbnRlZABObyBtZXNzYWdlIG9mIGRlc2lyZWQgdHlwZQBJZGVudGlmaWVyIHJlbW92ZWQARGV2aWNlIG5vdCBhIHN0cmVhbQBObyBkYXRhIGF2YWlsYWJsZQBEZXZpY2UgdGltZW91dABPdXQgb2Ygc3RyZWFtcyByZXNvdXJjZXMATGluayBoYXMgYmVlbiBzZXZlcmVkAFByb3RvY29sIGVycm9yAEJhZCBtZXNzYWdlAEZpbGUgZGVzY3JpcHRvciBpbiBiYWQgc3RhdGUATm90IGEgc29ja2V0AERlc3RpbmF0aW9uIGFkZHJlc3MgcmVxdWlyZWQATWVzc2FnZSB0b28gbGFyZ2UAUHJvdG9jb2wgd3JvbmcgdHlwZSBmb3Igc29ja2V0AFByb3RvY29sIG5vdCBhdmFpbGFibGUAUHJvdG9jb2wgbm90IHN1cHBvcnRlZABTb2NrZXQgdHlwZSBub3Qgc3VwcG9ydGVkAE5vdCBzdXBwb3J0ZWQAUHJvdG9jb2wgZmFtaWx5IG5vdCBzdXBwb3J0ZWQAQWRkcmVzcyBmYW1pbHkgbm90IHN1cHBvcnRlZCBieSBwcm90b2NvbABBZGRyZXNzIG5vdCBhdmFpbGFibGUATmV0d29yayBpcyBkb3duAE5ldHdvcmsgdW5yZWFjaGFibGUAQ29ubmVjdGlvbiByZXNldCBieSBuZXR3b3JrAENvbm5lY3Rpb24gYWJvcnRlZABObyBidWZmZXIgc3BhY2UgYXZhaWxhYmxlAFNvY2tldCBpcyBjb25uZWN0ZWQAU29ja2V0IG5vdCBjb25uZWN0ZWQAQ2Fubm90IHNlbmQgYWZ0ZXIgc29ja2V0IHNodXRkb3duAE9wZXJhdGlvbiBhbHJlYWR5IGluIHByb2dyZXNzAE9wZXJhdGlvbiBpbiBwcm9ncmVzcwBTdGFsZSBmaWxlIGhhbmRsZQBSZW1vdGUgSS9PIGVycm9yAFF1b3RhIGV4Y2VlZGVkAE5vIG1lZGl1bSBmb3VuZABXcm9uZyBtZWRpdW0gdHlwZQBObyBlcnJvciBpbmZvcm1hdGlvbg==';\n    var asmjsCodeFile = '';\n\n    if (typeof _Module['locateFile'] === 'function') {\n      if (!isDataURI(wasmTextFile)) {\n        wasmTextFile = _Module['locateFile'](wasmTextFile);\n      }\n\n      if (!isDataURI(wasmBinaryFile)) {\n        wasmBinaryFile = _Module['locateFile'](wasmBinaryFile);\n      }\n\n      if (!isDataURI(asmjsCodeFile)) {\n        asmjsCodeFile = _Module['locateFile'](asmjsCodeFile);\n      }\n    } // utilities\n\n\n    var wasmPageSize = 64 * 1024;\n    var info = {\n      'global': null,\n      'env': null,\n      'asm2wasm': {\n        // special asm2wasm imports\n        \"f64-rem\": function f64Rem(x, y) {\n          return x % y;\n        },\n        \"debugger\": function _debugger() {\n          debugger;\n        }\n      },\n      'parent': _Module // Module inside wasm-js.cpp refers to wasm-js.cpp; this allows access to the outside program.\n\n    };\n    var exports = null;\n\n    function mergeMemory(newBuffer) {\n      // The wasm instance creates its memory. But static init code might have written to\n      // buffer already, including the mem init file, and we must copy it over in a proper merge.\n      // TODO: avoid this copy, by avoiding such static init writes\n      // TODO: in shorter term, just copy up to the last static init write\n      var oldBuffer = _Module['buffer'];\n\n      if (newBuffer.byteLength < oldBuffer.byteLength) {\n        _Module['printErr']('the new buffer in mergeMemory is smaller than the previous one. in native wasm, we should grow memory here');\n      }\n\n      var oldView = new Int8Array(oldBuffer);\n      var newView = new Int8Array(newBuffer);\n      newView.set(oldView);\n      updateGlobalBuffer(newBuffer);\n      updateGlobalBufferViews();\n    }\n\n    function fixImports(imports) {\n      return imports;\n    }\n\n    function getBinary() {\n      try {\n        if (_Module['wasmBinary']) {\n          return new Uint8Array(_Module['wasmBinary']);\n        }\n\n        var binary = tryParseAsDataURI(wasmBinaryFile);\n\n        if (binary) {\n          return binary;\n        }\n\n        if (_Module['readBinary']) {\n          return _Module['readBinary'](wasmBinaryFile);\n        } else {\n          throw \"on the web, we need the wasm binary to be preloaded and set on Module['wasmBinary']. emcc.py will do that for you when generating HTML (but not JS)\";\n        }\n      } catch (err) {\n        abort(err);\n      }\n    }\n\n    function getBinaryPromise() {\n      // if we don't have the binary yet, and have the Fetch api, use that\n      // in some environments, like Electron's render process, Fetch api may be present, but have a different context than expected, let's only use it on the Web\n      if (!_Module['wasmBinary'] && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === 'function') {\n        return fetch(wasmBinaryFile, {\n          credentials: 'same-origin'\n        }).then(function (response) {\n          if (!response['ok']) {\n            throw \"failed to load wasm binary file at '\" + wasmBinaryFile + \"'\";\n          }\n\n          return response['arrayBuffer']();\n        }).catch(function () {\n          return getBinary();\n        });\n      } // Otherwise, getBinary should be able to get it synchronously\n\n\n      return new Promise(function (resolve, reject) {\n        resolve(getBinary());\n      });\n    } // do-method functions\n\n\n    function doNativeWasm(global, env, providedBuffer) {\n      if ((typeof WebAssembly === \"undefined\" ? \"undefined\" : _typeof(WebAssembly)) !== 'object') {\n        _Module['printErr']('no native wasm support detected');\n\n        return false;\n      } // prepare memory import\n\n\n      if (!(_Module['wasmMemory'] instanceof WebAssembly.Memory)) {\n        _Module['printErr']('no native wasm Memory in use');\n\n        return false;\n      }\n\n      env['memory'] = _Module['wasmMemory']; // Load the wasm module and create an instance of using native support in the JS engine.\n\n      info['global'] = {\n        'NaN': NaN,\n        'Infinity': Infinity\n      };\n      info['global.Math'] = Math;\n      info['env'] = env; // handle a generated wasm instance, receiving its exports and\n      // performing other necessary setup\n\n      function receiveInstance(instance, module) {\n        exports = instance.exports;\n        if (exports.memory) mergeMemory(exports.memory);\n        _Module['asm'] = exports;\n        _Module[\"usingWasm\"] = true;\n        removeRunDependency('wasm-instantiate');\n      }\n\n      addRunDependency('wasm-instantiate'); // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback\n      // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel\n      // to any other async startup actions they are performing.\n\n      if (_Module['instantiateWasm']) {\n        try {\n          return _Module['instantiateWasm'](info, receiveInstance);\n        } catch (e) {\n          _Module['printErr']('Module.instantiateWasm callback failed with error: ' + e);\n\n          return false;\n        }\n      } // Async compilation can be confusing when an error on the page overwrites Module\n      // (for example, if the order of elements is wrong, and the one defining Module is\n      // later), so we save Module and check it later.\n\n\n      var trueModule = _Module;\n\n      function receiveInstantiatedSource(output) {\n        // 'output' is a WebAssemblyInstantiatedSource object which has both the module and instance.\n        // receiveInstance() will swap in the exports (to Module.asm) so they can be called\n        assert(_Module === trueModule, 'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?');\n        trueModule = null;\n        receiveInstance(output['instance'], output['module']);\n      }\n\n      function instantiateArrayBuffer(receiver) {\n        getBinaryPromise().then(function (binary) {\n          return WebAssembly.instantiate(binary, info);\n        }).then(receiver).catch(function (reason) {\n          _Module['printErr']('failed to asynchronously prepare wasm: ' + reason);\n\n          abort(reason);\n        });\n      } // Prefer streaming instantiation if available.\n\n\n      if (!_Module['wasmBinary'] && typeof WebAssembly.instantiateStreaming === 'function' && !isDataURI(wasmBinaryFile) && typeof fetch === 'function') {\n        WebAssembly.instantiateStreaming(fetch(wasmBinaryFile, {\n          credentials: 'same-origin'\n        }), info).then(receiveInstantiatedSource).catch(function (reason) {\n          // We expect the most common failure cause to be a bad MIME type for the binary,\n          // in which case falling back to ArrayBuffer instantiation should work.\n          _Module['printErr']('wasm streaming compile failed: ' + reason);\n\n          _Module['printErr']('falling back to ArrayBuffer instantiation');\n\n          instantiateArrayBuffer(receiveInstantiatedSource);\n        });\n      } else {\n        instantiateArrayBuffer(receiveInstantiatedSource);\n      }\n\n      return {}; // no exports yet; we'll fill them in later\n    } // We may have a preloaded value in Module.asm, save it\n\n\n    _Module['asmPreload'] = _Module['asm']; // Memory growth integration code\n\n    var asmjsReallocBuffer = _Module['reallocBuffer'];\n\n    var wasmReallocBuffer = function wasmReallocBuffer(size) {\n      var PAGE_MULTIPLE = _Module[\"usingWasm\"] ? WASM_PAGE_SIZE : ASMJS_PAGE_SIZE; // In wasm, heap size must be a multiple of 64KB. In asm.js, they need to be multiples of 16MB.\n\n      size = alignUp(size, PAGE_MULTIPLE); // round up to wasm page size\n\n      var old = _Module['buffer'];\n      var oldSize = old.byteLength;\n\n      if (_Module[\"usingWasm\"]) {\n        // native wasm support\n        try {\n          var result = _Module['wasmMemory'].grow((size - oldSize) / wasmPageSize); // .grow() takes a delta compared to the previous size\n\n\n          if (result !== (-1 | 0)) {\n            // success in native wasm memory growth, get the buffer from the memory\n            return _Module['buffer'] = _Module['wasmMemory'].buffer;\n          } else {\n            return null;\n          }\n        } catch (e) {\n          console.error('Module.reallocBuffer: Attempted to grow from ' + oldSize + ' bytes to ' + size + ' bytes, but got error: ' + e);\n          return null;\n        }\n      }\n    };\n\n    _Module['reallocBuffer'] = function (size) {\n      if (finalMethod === 'asmjs') {\n        return asmjsReallocBuffer(size);\n      } else {\n        return wasmReallocBuffer(size);\n      }\n    }; // we may try more than one; this is the final one, that worked and we are using\n\n\n    var finalMethod = ''; // Provide an \"asm.js function\" for the application, called to \"link\" the asm.js module. We instantiate\n    // the wasm module at that time, and it receives imports and provides exports and so forth, the app\n    // doesn't need to care that it is wasm or olyfilled wasm or asm.js.\n\n    _Module['asm'] = function (global, env, providedBuffer) {\n      env = fixImports(env); // import table\n\n      if (!env['table']) {\n        var TABLE_SIZE = _Module['wasmTableSize'];\n        if (TABLE_SIZE === undefined) TABLE_SIZE = 1024; // works in binaryen interpreter at least\n\n        var MAX_TABLE_SIZE = _Module['wasmMaxTableSize'];\n\n        if ((typeof WebAssembly === \"undefined\" ? \"undefined\" : _typeof(WebAssembly)) === 'object' && typeof WebAssembly.Table === 'function') {\n          if (MAX_TABLE_SIZE !== undefined) {\n            env['table'] = new WebAssembly.Table({\n              'initial': TABLE_SIZE,\n              'maximum': MAX_TABLE_SIZE,\n              'element': 'anyfunc'\n            });\n          } else {\n            env['table'] = new WebAssembly.Table({\n              'initial': TABLE_SIZE,\n              element: 'anyfunc'\n            });\n          }\n        } else {\n          env['table'] = new Array(TABLE_SIZE); // works in binaryen interpreter at least\n        }\n\n        _Module['wasmTable'] = env['table'];\n      }\n\n      if (!env['memoryBase']) {\n        env['memoryBase'] = _Module['STATIC_BASE']; // tell the memory segments where to place themselves\n      }\n\n      if (!env['tableBase']) {\n        env['tableBase'] = 0; // table starts at 0 by default, in dynamic linking this will change\n      } // try the methods. each should return the exports if it succeeded\n\n\n      var exports;\n      exports = doNativeWasm(global, env, providedBuffer);\n      if (!exports) abort('no binaryen method succeeded. consider enabling more options, like interpreting, if you want that: https://github.com/kripken/emscripten/wiki/WebAssembly#binaryen-methods');\n      return exports;\n    };\n\n    var methodHandler = _Module['asm']; // note our method handler, as we may modify Module['asm'] later\n  }\n\n  integrateWasmJS(); // === Body ===\n\n  var ASM_CONSTS = [];\n  STATIC_BASE = GLOBAL_BASE;\n  STATICTOP = STATIC_BASE + 9888;\n  /* global initializers */\n\n  __ATINIT__.push();\n\n  var STATIC_BUMP = 9888;\n  _Module[\"STATIC_BASE\"] = STATIC_BASE;\n  _Module[\"STATIC_BUMP\"] = STATIC_BUMP;\n  /* no memory initializer */\n\n  var tempDoublePtr = STATICTOP;\n  STATICTOP += 16;\n  assert(tempDoublePtr % 8 == 0);\n\n  function copyTempFloat(ptr) {\n    // functions, because inlining this code increases code size too much\n    HEAP8[tempDoublePtr] = HEAP8[ptr];\n    HEAP8[tempDoublePtr + 1] = HEAP8[ptr + 1];\n    HEAP8[tempDoublePtr + 2] = HEAP8[ptr + 2];\n    HEAP8[tempDoublePtr + 3] = HEAP8[ptr + 3];\n  }\n\n  function copyTempDouble(ptr) {\n    HEAP8[tempDoublePtr] = HEAP8[ptr];\n    HEAP8[tempDoublePtr + 1] = HEAP8[ptr + 1];\n    HEAP8[tempDoublePtr + 2] = HEAP8[ptr + 2];\n    HEAP8[tempDoublePtr + 3] = HEAP8[ptr + 3];\n    HEAP8[tempDoublePtr + 4] = HEAP8[ptr + 4];\n    HEAP8[tempDoublePtr + 5] = HEAP8[ptr + 5];\n    HEAP8[tempDoublePtr + 6] = HEAP8[ptr + 6];\n    HEAP8[tempDoublePtr + 7] = HEAP8[ptr + 7];\n  } // {{PRE_LIBRARY}}\n\n\n  function ___lock() {}\n\n  var SYSCALLS = {\n    varargs: 0,\n    get: function get(varargs) {\n      SYSCALLS.varargs += 4;\n      var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];\n      return ret;\n    },\n    getStr: function getStr() {\n      var ret = Pointer_stringify(SYSCALLS.get());\n      return ret;\n    },\n    get64: function get64() {\n      var low = SYSCALLS.get(),\n          high = SYSCALLS.get();\n      if (low >= 0) assert(high === 0);else assert(high === -1);\n      return low;\n    },\n    getZero: function getZero() {\n      assert(SYSCALLS.get() === 0);\n    }\n  };\n\n  function ___syscall140(which, varargs) {\n    SYSCALLS.varargs = varargs;\n\n    try {\n      // llseek\n      var stream = SYSCALLS.getStreamFromFD(),\n          offset_high = SYSCALLS.get(),\n          offset_low = SYSCALLS.get(),\n          result = SYSCALLS.get(),\n          whence = SYSCALLS.get(); // NOTE: offset_high is unused - Emscripten's off_t is 32-bit\n\n      var offset = offset_low;\n      FS.llseek(stream, offset, whence);\n      HEAP32[result >> 2] = stream.position;\n      if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state\n\n      return 0;\n    } catch (e) {\n      if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n      return -e.errno;\n    }\n  }\n\n  function flush_NO_FILESYSTEM() {\n    // flush anything remaining in the buffers during shutdown\n    var fflush = _Module[\"_fflush\"];\n    if (fflush) fflush(0);\n    var printChar = ___syscall146.printChar;\n    if (!printChar) return;\n    var buffers = ___syscall146.buffers;\n    if (buffers[1].length) printChar(1, 10);\n    if (buffers[2].length) printChar(2, 10);\n  }\n\n  function ___syscall146(which, varargs) {\n    SYSCALLS.varargs = varargs;\n\n    try {\n      // writev\n      // hack to support printf in NO_FILESYSTEM\n      var stream = SYSCALLS.get(),\n          iov = SYSCALLS.get(),\n          iovcnt = SYSCALLS.get();\n      var ret = 0;\n\n      if (!___syscall146.buffers) {\n        ___syscall146.buffers = [null, [], []]; // 1 => stdout, 2 => stderr\n\n        ___syscall146.printChar = function (stream, curr) {\n          var buffer = ___syscall146.buffers[stream];\n          assert(buffer);\n\n          if (curr === 0 || curr === 10) {\n            (stream === 1 ? _Module['print'] : _Module['printErr'])(UTF8ArrayToString(buffer, 0));\n            buffer.length = 0;\n          } else {\n            buffer.push(curr);\n          }\n        };\n      }\n\n      for (var i = 0; i < iovcnt; i++) {\n        var ptr = HEAP32[iov + i * 8 >> 2];\n        var len = HEAP32[iov + (i * 8 + 4) >> 2];\n\n        for (var j = 0; j < len; j++) {\n          ___syscall146.printChar(stream, HEAPU8[ptr + j]);\n        }\n\n        ret += len;\n      }\n\n      return ret;\n    } catch (e) {\n      if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n      return -e.errno;\n    }\n  }\n\n  function ___syscall54(which, varargs) {\n    SYSCALLS.varargs = varargs;\n\n    try {\n      // ioctl\n      return 0;\n    } catch (e) {\n      if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n      return -e.errno;\n    }\n  }\n\n  function ___syscall6(which, varargs) {\n    SYSCALLS.varargs = varargs;\n\n    try {\n      // close\n      var stream = SYSCALLS.getStreamFromFD();\n      FS.close(stream);\n      return 0;\n    } catch (e) {\n      if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n      return -e.errno;\n    }\n  }\n\n  function ___unlock() {}\n\n  function _emscripten_has_threading_support() {\n    return 0;\n  }\n\n  var cttz_i8 = allocate([8, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0], \"i8\", ALLOC_STATIC);\n\n  function _llvm_cttz_i32(x) {\n    x = x | 0;\n    var ret = 0;\n    ret = HEAP8[cttz_i8 + (x & 0xff) >> 0] | 0;\n    if ((ret | 0) < 8) return ret | 0;\n    ret = HEAP8[cttz_i8 + (x >> 8 & 0xff) >> 0] | 0;\n    if ((ret | 0) < 8) return ret + 8 | 0;\n    ret = HEAP8[cttz_i8 + (x >> 16 & 0xff) >> 0] | 0;\n    if ((ret | 0) < 8) return ret + 16 | 0;\n    return (HEAP8[cttz_i8 + (x >>> 24) >> 0] | 0) + 24 | 0;\n  }\n\n  function _llvm_cttz_i64(l, h) {\n    var ret = _llvm_cttz_i32(l);\n\n    if (ret == 32) ret += _llvm_cttz_i32(h);\n    return (setTempRet0(0), ret) | 0;\n  }\n\n  function _llvm_stackrestore(p) {\n    var self = _llvm_stacksave;\n    var ret = self.LLVM_SAVEDSTACKS[p];\n    self.LLVM_SAVEDSTACKS.splice(p, 1);\n\n    _stackRestore(ret);\n  }\n\n  function _llvm_stacksave() {\n    var self = _llvm_stacksave;\n\n    if (!self.LLVM_SAVEDSTACKS) {\n      self.LLVM_SAVEDSTACKS = [];\n    }\n\n    self.LLVM_SAVEDSTACKS.push(_stackSave());\n    return self.LLVM_SAVEDSTACKS.length - 1;\n  }\n\n  function _emscripten_memcpy_big(dest, src, num) {\n    HEAPU8.set(HEAPU8.subarray(src, src + num), dest);\n    return dest;\n  }\n\n  function _pthread_create() {\n    return 11;\n  }\n\n  function _pthread_join() {}\n\n  function _pthread_mutex_init() {}\n\n  function ___setErrNo(value) {\n    if (_Module['___errno_location']) HEAP32[_Module['___errno_location']() >> 2] = value;else _Module.printErr('failed to set errno from JS');\n    return value;\n  }\n\n  var ERRNO_CODES = {\n    EPERM: 1,\n    ENOENT: 2,\n    ESRCH: 3,\n    EINTR: 4,\n    EIO: 5,\n    ENXIO: 6,\n    E2BIG: 7,\n    ENOEXEC: 8,\n    EBADF: 9,\n    ECHILD: 10,\n    EAGAIN: 11,\n    EWOULDBLOCK: 11,\n    ENOMEM: 12,\n    EACCES: 13,\n    EFAULT: 14,\n    ENOTBLK: 15,\n    EBUSY: 16,\n    EEXIST: 17,\n    EXDEV: 18,\n    ENODEV: 19,\n    ENOTDIR: 20,\n    EISDIR: 21,\n    EINVAL: 22,\n    ENFILE: 23,\n    EMFILE: 24,\n    ENOTTY: 25,\n    ETXTBSY: 26,\n    EFBIG: 27,\n    ENOSPC: 28,\n    ESPIPE: 29,\n    EROFS: 30,\n    EMLINK: 31,\n    EPIPE: 32,\n    EDOM: 33,\n    ERANGE: 34,\n    ENOMSG: 42,\n    EIDRM: 43,\n    ECHRNG: 44,\n    EL2NSYNC: 45,\n    EL3HLT: 46,\n    EL3RST: 47,\n    ELNRNG: 48,\n    EUNATCH: 49,\n    ENOCSI: 50,\n    EL2HLT: 51,\n    EDEADLK: 35,\n    ENOLCK: 37,\n    EBADE: 52,\n    EBADR: 53,\n    EXFULL: 54,\n    ENOANO: 55,\n    EBADRQC: 56,\n    EBADSLT: 57,\n    EDEADLOCK: 35,\n    EBFONT: 59,\n    ENOSTR: 60,\n    ENODATA: 61,\n    ETIME: 62,\n    ENOSR: 63,\n    ENONET: 64,\n    ENOPKG: 65,\n    EREMOTE: 66,\n    ENOLINK: 67,\n    EADV: 68,\n    ESRMNT: 69,\n    ECOMM: 70,\n    EPROTO: 71,\n    EMULTIHOP: 72,\n    EDOTDOT: 73,\n    EBADMSG: 74,\n    ENOTUNIQ: 76,\n    EBADFD: 77,\n    EREMCHG: 78,\n    ELIBACC: 79,\n    ELIBBAD: 80,\n    ELIBSCN: 81,\n    ELIBMAX: 82,\n    ELIBEXEC: 83,\n    ENOSYS: 38,\n    ENOTEMPTY: 39,\n    ENAMETOOLONG: 36,\n    ELOOP: 40,\n    EOPNOTSUPP: 95,\n    EPFNOSUPPORT: 96,\n    ECONNRESET: 104,\n    ENOBUFS: 105,\n    EAFNOSUPPORT: 97,\n    EPROTOTYPE: 91,\n    ENOTSOCK: 88,\n    ENOPROTOOPT: 92,\n    ESHUTDOWN: 108,\n    ECONNREFUSED: 111,\n    EADDRINUSE: 98,\n    ECONNABORTED: 103,\n    ENETUNREACH: 101,\n    ENETDOWN: 100,\n    ETIMEDOUT: 110,\n    EHOSTDOWN: 112,\n    EHOSTUNREACH: 113,\n    EINPROGRESS: 115,\n    EALREADY: 114,\n    EDESTADDRREQ: 89,\n    EMSGSIZE: 90,\n    EPROTONOSUPPORT: 93,\n    ESOCKTNOSUPPORT: 94,\n    EADDRNOTAVAIL: 99,\n    ENETRESET: 102,\n    EISCONN: 106,\n    ENOTCONN: 107,\n    ETOOMANYREFS: 109,\n    EUSERS: 87,\n    EDQUOT: 122,\n    ESTALE: 116,\n    ENOTSUP: 95,\n    ENOMEDIUM: 123,\n    EILSEQ: 84,\n    EOVERFLOW: 75,\n    ECANCELED: 125,\n    ENOTRECOVERABLE: 131,\n    EOWNERDEAD: 130,\n    ESTRPIPE: 86\n  };\n\n  function _sysconf(name) {\n    // long sysconf(int name);\n    // http://pubs.opengroup.org/onlinepubs/009695399/functions/sysconf.html\n    switch (name) {\n      case 30:\n        return PAGE_SIZE;\n\n      case 85:\n        var maxHeapSize = 2 * 1024 * 1024 * 1024 - 65536;\n        maxHeapSize = HEAPU8.length;\n        return maxHeapSize / PAGE_SIZE;\n\n      case 132:\n      case 133:\n      case 12:\n      case 137:\n      case 138:\n      case 15:\n      case 235:\n      case 16:\n      case 17:\n      case 18:\n      case 19:\n      case 20:\n      case 149:\n      case 13:\n      case 10:\n      case 236:\n      case 153:\n      case 9:\n      case 21:\n      case 22:\n      case 159:\n      case 154:\n      case 14:\n      case 77:\n      case 78:\n      case 139:\n      case 80:\n      case 81:\n      case 82:\n      case 68:\n      case 67:\n      case 164:\n      case 11:\n      case 29:\n      case 47:\n      case 48:\n      case 95:\n      case 52:\n      case 51:\n      case 46:\n        return 200809;\n\n      case 79:\n        return 0;\n\n      case 27:\n      case 246:\n      case 127:\n      case 128:\n      case 23:\n      case 24:\n      case 160:\n      case 161:\n      case 181:\n      case 182:\n      case 242:\n      case 183:\n      case 184:\n      case 243:\n      case 244:\n      case 245:\n      case 165:\n      case 178:\n      case 179:\n      case 49:\n      case 50:\n      case 168:\n      case 169:\n      case 175:\n      case 170:\n      case 171:\n      case 172:\n      case 97:\n      case 76:\n      case 32:\n      case 173:\n      case 35:\n        return -1;\n\n      case 176:\n      case 177:\n      case 7:\n      case 155:\n      case 8:\n      case 157:\n      case 125:\n      case 126:\n      case 92:\n      case 93:\n      case 129:\n      case 130:\n      case 131:\n      case 94:\n      case 91:\n        return 1;\n\n      case 74:\n      case 60:\n      case 69:\n      case 70:\n      case 4:\n        return 1024;\n\n      case 31:\n      case 42:\n      case 72:\n        return 32;\n\n      case 87:\n      case 26:\n      case 33:\n        return 2147483647;\n\n      case 34:\n      case 1:\n        return 47839;\n\n      case 38:\n      case 36:\n        return 99;\n\n      case 43:\n      case 37:\n        return 2048;\n\n      case 0:\n        return 2097152;\n\n      case 3:\n        return 65536;\n\n      case 28:\n        return 32768;\n\n      case 44:\n        return 32767;\n\n      case 75:\n        return 16384;\n\n      case 39:\n        return 1000;\n\n      case 89:\n        return 700;\n\n      case 71:\n        return 256;\n\n      case 40:\n        return 255;\n\n      case 2:\n        return 100;\n\n      case 180:\n        return 64;\n\n      case 25:\n        return 20;\n\n      case 5:\n        return 16;\n\n      case 6:\n        return 6;\n\n      case 73:\n        return 4;\n\n      case 84:\n        {\n          if ((typeof navigator === \"undefined\" ? \"undefined\" : _typeof(navigator)) === 'object') return navigator['hardwareConcurrency'] || 1;\n          return 1;\n        }\n    }\n\n    ___setErrNo(ERRNO_CODES.EINVAL);\n\n    return -1;\n  }\n\n  DYNAMICTOP_PTR = staticAlloc(4);\n  STACK_BASE = STACKTOP = alignMemory(STATICTOP);\n  STACK_MAX = STACK_BASE + TOTAL_STACK;\n  DYNAMIC_BASE = alignMemory(STACK_MAX);\n  HEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;\n  staticSealed = true; // seal the static portion of memory\n\n  assert(DYNAMIC_BASE < TOTAL_MEMORY, \"TOTAL_MEMORY not big enough for stack\");\n  var ASSERTIONS = true;\n  /** @type {function(string, boolean=, number=)} */\n\n  function intArrayFromString(stringy, dontAddNull, length) {\n    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;\n    var u8array = new Array(len);\n    var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n    if (dontAddNull) u8array.length = numBytesWritten;\n    return u8array;\n  }\n\n  function intArrayToString(array) {\n    var ret = [];\n\n    for (var i = 0; i < array.length; i++) {\n      var chr = array[i];\n\n      if (chr > 0xFF) {\n        if (ASSERTIONS) {\n          assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');\n        }\n\n        chr &= 0xFF;\n      }\n\n      ret.push(String.fromCharCode(chr));\n    }\n\n    return ret.join('');\n  } // Copied from https://github.com/strophe/strophejs/blob/e06d027/src/polyfills.js#L149\n  // This code was written by Tyler Akins and has been placed in the\n  // public domain.  It would be nice if you left this header intact.\n  // Base64 code from Tyler Akins -- http://rumkin.com\n\n  /**\r\n   * Decodes a base64 string.\r\n   * @param {String} input The string to decode.\r\n   */\n\n\n  var decodeBase64 = typeof atob === 'function' ? atob : function (input) {\n    var keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n    var output = '';\n    var chr1, chr2, chr3;\n    var enc1, enc2, enc3, enc4;\n    var i = 0; // remove all characters that are not A-Z, a-z, 0-9, +, /, or =\n\n    input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, '');\n\n    do {\n      enc1 = keyStr.indexOf(input.charAt(i++));\n      enc2 = keyStr.indexOf(input.charAt(i++));\n      enc3 = keyStr.indexOf(input.charAt(i++));\n      enc4 = keyStr.indexOf(input.charAt(i++));\n      chr1 = enc1 << 2 | enc2 >> 4;\n      chr2 = (enc2 & 15) << 4 | enc3 >> 2;\n      chr3 = (enc3 & 3) << 6 | enc4;\n      output = output + String.fromCharCode(chr1);\n\n      if (enc3 !== 64) {\n        output = output + String.fromCharCode(chr2);\n      }\n\n      if (enc4 !== 64) {\n        output = output + String.fromCharCode(chr3);\n      }\n    } while (i < input.length);\n\n    return output;\n  }; // Converts a string of base64 into a byte array.\n  // Throws error on invalid input.\n\n  function intArrayFromBase64(s) {\n    if (typeof ENVIRONMENT_IS_NODE === 'boolean' && ENVIRONMENT_IS_NODE) {\n      var buf;\n\n      try {\n        buf = Buffer.from(s, 'base64');\n      } catch (_) {\n        buf = new Buffer(s, 'base64');\n      }\n\n      return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);\n    }\n\n    try {\n      var decoded = decodeBase64(s);\n      var bytes = new Uint8Array(decoded.length);\n\n      for (var i = 0; i < decoded.length; ++i) {\n        bytes[i] = decoded.charCodeAt(i);\n      }\n\n      return bytes;\n    } catch (_) {\n      throw new Error('Converting base64 string to bytes failed.');\n    }\n  } // If filename is a base64 data URI, parses and returns data (Buffer on node,\n  // Uint8Array otherwise). If filename is not a base64 data URI, returns undefined.\n\n\n  function tryParseAsDataURI(filename) {\n    if (!isDataURI(filename)) {\n      return;\n    }\n\n    return intArrayFromBase64(filename.slice(dataURIPrefix.length));\n  }\n\n  function nullFunc_ii(x) {\n    _Module[\"printErr\"](\"Invalid function pointer called with signature 'ii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n\n    _Module[\"printErr\"](\"Build with ASSERTIONS=2 for more info.\");\n\n    abort(x);\n  }\n\n  function nullFunc_iiii(x) {\n    _Module[\"printErr\"](\"Invalid function pointer called with signature 'iiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n\n    _Module[\"printErr\"](\"Build with ASSERTIONS=2 for more info.\");\n\n    abort(x);\n  }\n\n  _Module['wasmTableSize'] = 16;\n  _Module['wasmMaxTableSize'] = 16;\n\n  function invoke_ii(index, a1) {\n    try {\n      return _Module[\"dynCall_ii\"](index, a1);\n    } catch (e) {\n      if (typeof e !== 'number' && e !== 'longjmp') throw e;\n\n      _Module[\"setThrew\"](1, 0);\n    }\n  }\n\n  function invoke_iiii(index, a1, a2, a3) {\n    try {\n      return _Module[\"dynCall_iiii\"](index, a1, a2, a3);\n    } catch (e) {\n      if (typeof e !== 'number' && e !== 'longjmp') throw e;\n\n      _Module[\"setThrew\"](1, 0);\n    }\n  }\n\n  _Module.asmGlobalArg = {};\n  _Module.asmLibraryArg = {\n    \"abort\": abort,\n    \"assert\": assert,\n    \"enlargeMemory\": enlargeMemory,\n    \"getTotalMemory\": getTotalMemory,\n    \"abortOnCannotGrowMemory\": abortOnCannotGrowMemory,\n    \"abortStackOverflow\": abortStackOverflow,\n    \"nullFunc_ii\": nullFunc_ii,\n    \"nullFunc_iiii\": nullFunc_iiii,\n    \"invoke_ii\": invoke_ii,\n    \"invoke_iiii\": invoke_iiii,\n    \"___lock\": ___lock,\n    \"___setErrNo\": ___setErrNo,\n    \"___syscall140\": ___syscall140,\n    \"___syscall146\": ___syscall146,\n    \"___syscall54\": ___syscall54,\n    \"___syscall6\": ___syscall6,\n    \"___unlock\": ___unlock,\n    \"_emscripten_has_threading_support\": _emscripten_has_threading_support,\n    \"_emscripten_memcpy_big\": _emscripten_memcpy_big,\n    \"_llvm_cttz_i32\": _llvm_cttz_i32,\n    \"_llvm_cttz_i64\": _llvm_cttz_i64,\n    \"_llvm_stackrestore\": _llvm_stackrestore,\n    \"_llvm_stacksave\": _llvm_stacksave,\n    \"_pthread_create\": _pthread_create,\n    \"_pthread_join\": _pthread_join,\n    \"_pthread_mutex_init\": _pthread_mutex_init,\n    \"_sysconf\": _sysconf,\n    \"flush_NO_FILESYSTEM\": flush_NO_FILESYSTEM,\n    \"DYNAMICTOP_PTR\": DYNAMICTOP_PTR,\n    \"tempDoublePtr\": tempDoublePtr,\n    \"ABORT\": ABORT,\n    \"STACKTOP\": STACKTOP,\n    \"STACK_MAX\": STACK_MAX,\n    \"cttz_i8\": cttz_i8\n  }; // EMSCRIPTEN_START_ASM\n\n  var asm = _Module[\"asm\"] // EMSCRIPTEN_END_ASM\n  (_Module.asmGlobalArg, _Module.asmLibraryArg, buffer);\n\n  var real____errno_location = asm[\"___errno_location\"];\n\n  asm[\"___errno_location\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return real____errno_location.apply(null, arguments);\n  };\n\n  var real__ccurl_pow = asm[\"_ccurl_pow\"];\n\n  asm[\"_ccurl_pow\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return real__ccurl_pow.apply(null, arguments);\n  };\n\n  var real__fflush = asm[\"_fflush\"];\n\n  asm[\"_fflush\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return real__fflush.apply(null, arguments);\n  };\n\n  var real__free = asm[\"_free\"];\n\n  asm[\"_free\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return real__free.apply(null, arguments);\n  };\n\n  var real__llvm_bswap_i32 = asm[\"_llvm_bswap_i32\"];\n\n  asm[\"_llvm_bswap_i32\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return real__llvm_bswap_i32.apply(null, arguments);\n  };\n\n  var real__malloc = asm[\"_malloc\"];\n\n  asm[\"_malloc\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return real__malloc.apply(null, arguments);\n  };\n\n  var real__pthread_mutex_lock = asm[\"_pthread_mutex_lock\"];\n\n  asm[\"_pthread_mutex_lock\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return real__pthread_mutex_lock.apply(null, arguments);\n  };\n\n  var real__pthread_mutex_unlock = asm[\"_pthread_mutex_unlock\"];\n\n  asm[\"_pthread_mutex_unlock\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return real__pthread_mutex_unlock.apply(null, arguments);\n  };\n\n  var real__sbrk = asm[\"_sbrk\"];\n\n  asm[\"_sbrk\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return real__sbrk.apply(null, arguments);\n  };\n\n  var real_establishStackSpace = asm[\"establishStackSpace\"];\n\n  asm[\"establishStackSpace\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return real_establishStackSpace.apply(null, arguments);\n  };\n\n  var real_getTempRet0 = asm[\"getTempRet0\"];\n\n  asm[\"getTempRet0\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return real_getTempRet0.apply(null, arguments);\n  };\n\n  var real_setTempRet0 = asm[\"setTempRet0\"];\n\n  asm[\"setTempRet0\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return real_setTempRet0.apply(null, arguments);\n  };\n\n  var real_setThrew = asm[\"setThrew\"];\n\n  asm[\"setThrew\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return real_setThrew.apply(null, arguments);\n  };\n\n  var real_stackAlloc = asm[\"stackAlloc\"];\n\n  asm[\"stackAlloc\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return real_stackAlloc.apply(null, arguments);\n  };\n\n  var real_stackRestore = asm[\"stackRestore\"];\n\n  asm[\"stackRestore\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return real_stackRestore.apply(null, arguments);\n  };\n\n  var real_stackSave = asm[\"stackSave\"];\n\n  asm[\"stackSave\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return real_stackSave.apply(null, arguments);\n  };\n\n  _Module[\"asm\"] = asm;\n\n  var ___errno_location = _Module[\"___errno_location\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return _Module[\"asm\"][\"___errno_location\"].apply(null, arguments);\n  };\n\n  var _ccurl_pow = _Module[\"_ccurl_pow\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return _Module[\"asm\"][\"_ccurl_pow\"].apply(null, arguments);\n  };\n\n  var _fflush = _Module[\"_fflush\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return _Module[\"asm\"][\"_fflush\"].apply(null, arguments);\n  };\n\n  var _free = _Module[\"_free\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return _Module[\"asm\"][\"_free\"].apply(null, arguments);\n  };\n\n  var _llvm_bswap_i32 = _Module[\"_llvm_bswap_i32\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return _Module[\"asm\"][\"_llvm_bswap_i32\"].apply(null, arguments);\n  };\n\n  var _malloc = _Module[\"_malloc\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return _Module[\"asm\"][\"_malloc\"].apply(null, arguments);\n  };\n\n  var _memcpy = _Module[\"_memcpy\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return _Module[\"asm\"][\"_memcpy\"].apply(null, arguments);\n  };\n\n  var _memset = _Module[\"_memset\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return _Module[\"asm\"][\"_memset\"].apply(null, arguments);\n  };\n\n  var _pthread_mutex_lock = _Module[\"_pthread_mutex_lock\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return _Module[\"asm\"][\"_pthread_mutex_lock\"].apply(null, arguments);\n  };\n\n  var _pthread_mutex_unlock = _Module[\"_pthread_mutex_unlock\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return _Module[\"asm\"][\"_pthread_mutex_unlock\"].apply(null, arguments);\n  };\n\n  var _sbrk = _Module[\"_sbrk\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return _Module[\"asm\"][\"_sbrk\"].apply(null, arguments);\n  };\n\n  var establishStackSpace = _Module[\"establishStackSpace\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return _Module[\"asm\"][\"establishStackSpace\"].apply(null, arguments);\n  };\n\n  var getTempRet0 = _Module[\"getTempRet0\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return _Module[\"asm\"][\"getTempRet0\"].apply(null, arguments);\n  };\n\n  var runPostSets = _Module[\"runPostSets\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return _Module[\"asm\"][\"runPostSets\"].apply(null, arguments);\n  };\n\n  var setTempRet0 = _Module[\"setTempRet0\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return _Module[\"asm\"][\"setTempRet0\"].apply(null, arguments);\n  };\n\n  var setThrew = _Module[\"setThrew\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return _Module[\"asm\"][\"setThrew\"].apply(null, arguments);\n  };\n\n  var stackAlloc = _Module[\"stackAlloc\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return _Module[\"asm\"][\"stackAlloc\"].apply(null, arguments);\n  };\n\n  var _stackRestore = _Module[\"stackRestore\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return _Module[\"asm\"][\"stackRestore\"].apply(null, arguments);\n  };\n\n  var _stackSave = _Module[\"stackSave\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return _Module[\"asm\"][\"stackSave\"].apply(null, arguments);\n  };\n\n  var dynCall_ii = _Module[\"dynCall_ii\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return _Module[\"asm\"][\"dynCall_ii\"].apply(null, arguments);\n  };\n\n  var dynCall_iiii = _Module[\"dynCall_iiii\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return _Module[\"asm\"][\"dynCall_iiii\"].apply(null, arguments);\n  };\n\n  ; // === Auto-generated postamble setup entry stuff ===\n\n  _Module['asm'] = asm;\n  if (!_Module[\"intArrayFromString\"]) _Module[\"intArrayFromString\"] = function () {\n    abort(\"'intArrayFromString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"intArrayToString\"]) _Module[\"intArrayToString\"] = function () {\n    abort(\"'intArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  _Module[\"ccall\"] = ccall;\n  _Module[\"cwrap\"] = cwrap;\n  if (!_Module[\"setValue\"]) _Module[\"setValue\"] = function () {\n    abort(\"'setValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"getValue\"]) _Module[\"getValue\"] = function () {\n    abort(\"'getValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"allocate\"]) _Module[\"allocate\"] = function () {\n    abort(\"'allocate' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"getMemory\"]) _Module[\"getMemory\"] = function () {\n    abort(\"'getMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n  };\n  if (!_Module[\"Pointer_stringify\"]) _Module[\"Pointer_stringify\"] = function () {\n    abort(\"'Pointer_stringify' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"AsciiToString\"]) _Module[\"AsciiToString\"] = function () {\n    abort(\"'AsciiToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"stringToAscii\"]) _Module[\"stringToAscii\"] = function () {\n    abort(\"'stringToAscii' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"UTF8ArrayToString\"]) _Module[\"UTF8ArrayToString\"] = function () {\n    abort(\"'UTF8ArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"UTF8ToString\"]) _Module[\"UTF8ToString\"] = function () {\n    abort(\"'UTF8ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"stringToUTF8Array\"]) _Module[\"stringToUTF8Array\"] = function () {\n    abort(\"'stringToUTF8Array' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"stringToUTF8\"]) _Module[\"stringToUTF8\"] = function () {\n    abort(\"'stringToUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"lengthBytesUTF8\"]) _Module[\"lengthBytesUTF8\"] = function () {\n    abort(\"'lengthBytesUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"UTF16ToString\"]) _Module[\"UTF16ToString\"] = function () {\n    abort(\"'UTF16ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"stringToUTF16\"]) _Module[\"stringToUTF16\"] = function () {\n    abort(\"'stringToUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"lengthBytesUTF16\"]) _Module[\"lengthBytesUTF16\"] = function () {\n    abort(\"'lengthBytesUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"UTF32ToString\"]) _Module[\"UTF32ToString\"] = function () {\n    abort(\"'UTF32ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"stringToUTF32\"]) _Module[\"stringToUTF32\"] = function () {\n    abort(\"'stringToUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"lengthBytesUTF32\"]) _Module[\"lengthBytesUTF32\"] = function () {\n    abort(\"'lengthBytesUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"allocateUTF8\"]) _Module[\"allocateUTF8\"] = function () {\n    abort(\"'allocateUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"stackTrace\"]) _Module[\"stackTrace\"] = function () {\n    abort(\"'stackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"addOnPreRun\"]) _Module[\"addOnPreRun\"] = function () {\n    abort(\"'addOnPreRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"addOnInit\"]) _Module[\"addOnInit\"] = function () {\n    abort(\"'addOnInit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"addOnPreMain\"]) _Module[\"addOnPreMain\"] = function () {\n    abort(\"'addOnPreMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"addOnExit\"]) _Module[\"addOnExit\"] = function () {\n    abort(\"'addOnExit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"addOnPostRun\"]) _Module[\"addOnPostRun\"] = function () {\n    abort(\"'addOnPostRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"writeStringToMemory\"]) _Module[\"writeStringToMemory\"] = function () {\n    abort(\"'writeStringToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"writeArrayToMemory\"]) _Module[\"writeArrayToMemory\"] = function () {\n    abort(\"'writeArrayToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"writeAsciiToMemory\"]) _Module[\"writeAsciiToMemory\"] = function () {\n    abort(\"'writeAsciiToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"addRunDependency\"]) _Module[\"addRunDependency\"] = function () {\n    abort(\"'addRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n  };\n  if (!_Module[\"removeRunDependency\"]) _Module[\"removeRunDependency\"] = function () {\n    abort(\"'removeRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n  };\n  if (!_Module[\"FS\"]) _Module[\"FS\"] = function () {\n    abort(\"'FS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"FS_createFolder\"]) _Module[\"FS_createFolder\"] = function () {\n    abort(\"'FS_createFolder' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n  };\n  if (!_Module[\"FS_createPath\"]) _Module[\"FS_createPath\"] = function () {\n    abort(\"'FS_createPath' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n  };\n  if (!_Module[\"FS_createDataFile\"]) _Module[\"FS_createDataFile\"] = function () {\n    abort(\"'FS_createDataFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n  };\n  if (!_Module[\"FS_createPreloadedFile\"]) _Module[\"FS_createPreloadedFile\"] = function () {\n    abort(\"'FS_createPreloadedFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n  };\n  if (!_Module[\"FS_createLazyFile\"]) _Module[\"FS_createLazyFile\"] = function () {\n    abort(\"'FS_createLazyFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n  };\n  if (!_Module[\"FS_createLink\"]) _Module[\"FS_createLink\"] = function () {\n    abort(\"'FS_createLink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n  };\n  if (!_Module[\"FS_createDevice\"]) _Module[\"FS_createDevice\"] = function () {\n    abort(\"'FS_createDevice' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n  };\n  if (!_Module[\"FS_unlink\"]) _Module[\"FS_unlink\"] = function () {\n    abort(\"'FS_unlink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n  };\n  if (!_Module[\"GL\"]) _Module[\"GL\"] = function () {\n    abort(\"'GL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"staticAlloc\"]) _Module[\"staticAlloc\"] = function () {\n    abort(\"'staticAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"dynamicAlloc\"]) _Module[\"dynamicAlloc\"] = function () {\n    abort(\"'dynamicAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"warnOnce\"]) _Module[\"warnOnce\"] = function () {\n    abort(\"'warnOnce' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"loadDynamicLibrary\"]) _Module[\"loadDynamicLibrary\"] = function () {\n    abort(\"'loadDynamicLibrary' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"loadWebAssemblyModule\"]) _Module[\"loadWebAssemblyModule\"] = function () {\n    abort(\"'loadWebAssemblyModule' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"getLEB\"]) _Module[\"getLEB\"] = function () {\n    abort(\"'getLEB' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"getFunctionTables\"]) _Module[\"getFunctionTables\"] = function () {\n    abort(\"'getFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"alignFunctionTables\"]) _Module[\"alignFunctionTables\"] = function () {\n    abort(\"'alignFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"registerFunctions\"]) _Module[\"registerFunctions\"] = function () {\n    abort(\"'registerFunctions' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"addFunction\"]) _Module[\"addFunction\"] = function () {\n    abort(\"'addFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"removeFunction\"]) _Module[\"removeFunction\"] = function () {\n    abort(\"'removeFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"getFuncWrapper\"]) _Module[\"getFuncWrapper\"] = function () {\n    abort(\"'getFuncWrapper' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"prettyPrint\"]) _Module[\"prettyPrint\"] = function () {\n    abort(\"'prettyPrint' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"makeBigInt\"]) _Module[\"makeBigInt\"] = function () {\n    abort(\"'makeBigInt' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"dynCall\"]) _Module[\"dynCall\"] = function () {\n    abort(\"'dynCall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"getCompilerSetting\"]) _Module[\"getCompilerSetting\"] = function () {\n    abort(\"'getCompilerSetting' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"intArrayFromBase64\"]) _Module[\"intArrayFromBase64\"] = function () {\n    abort(\"'intArrayFromBase64' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"tryParseAsDataURI\"]) _Module[\"tryParseAsDataURI\"] = function () {\n    abort(\"'tryParseAsDataURI' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"ALLOC_NORMAL\"]) Object.defineProperty(_Module, \"ALLOC_NORMAL\", {\n    get: function get() {\n      abort(\"'ALLOC_NORMAL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    }\n  });\n  if (!_Module[\"ALLOC_STACK\"]) Object.defineProperty(_Module, \"ALLOC_STACK\", {\n    get: function get() {\n      abort(\"'ALLOC_STACK' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    }\n  });\n  if (!_Module[\"ALLOC_STATIC\"]) Object.defineProperty(_Module, \"ALLOC_STATIC\", {\n    get: function get() {\n      abort(\"'ALLOC_STATIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    }\n  });\n  if (!_Module[\"ALLOC_DYNAMIC\"]) Object.defineProperty(_Module, \"ALLOC_DYNAMIC\", {\n    get: function get() {\n      abort(\"'ALLOC_DYNAMIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    }\n  });\n  if (!_Module[\"ALLOC_NONE\"]) Object.defineProperty(_Module, \"ALLOC_NONE\", {\n    get: function get() {\n      abort(\"'ALLOC_NONE' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    }\n  }); // Modularize mode returns a function, which can be called to\n  // create instances. The instances provide a then() method,\n  // must like a Promise, that receives a callback. The callback\n  // is called when the module is ready to run, with the module\n  // as a parameter. (Like a Promise, it also returns the module\n  // so you can use the output of .then(..)).\n\n  _Module['then'] = function (func) {\n    // We may already be ready to run code at this time. if\n    // so, just queue a call to the callback.\n    if (_Module['calledRun']) {\n      func(_Module);\n    } else {\n      // we are not ready to call then() yet. we must call it\n      // at the same time we would call onRuntimeInitialized.\n      var old = _Module['onRuntimeInitialized'];\n\n      _Module['onRuntimeInitialized'] = function () {\n        if (old) old();\n        func(_Module);\n      };\n    }\n\n    return _Module;\n  };\n  /**\r\n   * @constructor\r\n   * @extends {Error}\r\n   * @this {ExitStatus}\r\n   */\n\n\n  function ExitStatus(status) {\n    this.name = \"ExitStatus\";\n    this.message = \"Program terminated with exit(\" + status + \")\";\n    this.status = status;\n  }\n\n  ;\n  ExitStatus.prototype = new Error();\n  ExitStatus.prototype.constructor = ExitStatus;\n  var initialStackTop;\n  var calledMain = false;\n\n  dependenciesFulfilled = function runCaller() {\n    // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)\n    if (!_Module['calledRun']) run();\n    if (!_Module['calledRun']) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled\n  };\n  /** @type {function(Array=)} */\n\n\n  function run(args) {\n    args = args || _Module['arguments'];\n\n    if (runDependencies > 0) {\n      return;\n    }\n\n    writeStackCookie();\n    preRun();\n    if (runDependencies > 0) return; // a preRun added a dependency, run will be called later\n\n    if (_Module['calledRun']) return; // run may have just been called through dependencies being fulfilled just in this very frame\n\n    function doRun() {\n      if (_Module['calledRun']) return; // run may have just been called while the async setStatus time below was happening\n\n      _Module['calledRun'] = true;\n      if (ABORT) return;\n      ensureInitRuntime();\n      preMain();\n      if (_Module['onRuntimeInitialized']) _Module['onRuntimeInitialized']();\n      assert(!_Module['_main'], 'compiled without a main, but one is present. if you added it from JS, use Module[\"onRuntimeInitialized\"]');\n      postRun();\n    }\n\n    if (_Module['setStatus']) {\n      _Module['setStatus']('Running...');\n\n      setTimeout(function () {\n        setTimeout(function () {\n          _Module['setStatus']('');\n        }, 1);\n        doRun();\n      }, 1);\n    } else {\n      doRun();\n    }\n\n    checkStackCookie();\n  }\n\n  _Module['run'] = run;\n\n  function checkUnflushedContent() {\n    // Compiler settings do not allow exiting the runtime, so flushing\n    // the streams is not possible. but in ASSERTIONS mode we check\n    // if there was something to flush, and if so tell the user they\n    // should request that the runtime be exitable.\n    // Normally we would not even include flush() at all, but in ASSERTIONS\n    // builds we do so just for this check, and here we see if there is any\n    // content to flush, that is, we check if there would have been\n    // something a non-ASSERTIONS build would have not seen.\n    // How we flush the streams depends on whether we are in NO_FILESYSTEM\n    // mode (which has its own special function for this; otherwise, all\n    // the code is inside libc)\n    var print = _Module['print'];\n    var printErr = _Module['printErr'];\n    var has = false;\n\n    _Module['print'] = _Module['printErr'] = function (x) {\n      has = true;\n    };\n\n    try {\n      // it doesn't matter if it fails\n      var flush = flush_NO_FILESYSTEM;\n      if (flush) flush(0);\n    } catch (e) {}\n\n    _Module['print'] = print;\n    _Module['printErr'] = printErr;\n\n    if (has) {\n      warnOnce('stdio streams had content in them that was not flushed. you should set NO_EXIT_RUNTIME to 0 (see the FAQ), or make sure to emit a newline when you printf etc.');\n    }\n  }\n\n  function exit(status, implicit) {\n    checkUnflushedContent(); // if this is just main exit-ing implicitly, and the status is 0, then we\n    // don't need to do anything here and can just leave. if the status is\n    // non-zero, though, then we need to report it.\n    // (we may have warned about this earlier, if a situation justifies doing so)\n\n    if (implicit && _Module['noExitRuntime'] && status === 0) {\n      return;\n    }\n\n    if (_Module['noExitRuntime']) {\n      // if exit() was called, we may warn the user if the runtime isn't actually being shut down\n      if (!implicit) {\n        _Module.printErr('exit(' + status + ') called, but NO_EXIT_RUNTIME is set, so halting execution but not exiting the runtime or preventing further async execution (build with NO_EXIT_RUNTIME=0, if you want a true shutdown)');\n      }\n    } else {\n      ABORT = true;\n      EXITSTATUS = status;\n      STACKTOP = initialStackTop;\n      exitRuntime();\n      if (_Module['onExit']) _Module['onExit'](status);\n    }\n\n    if (ENVIRONMENT_IS_NODE) {\n      process['exit'](status);\n    }\n\n    _Module['quit'](status, new ExitStatus(status));\n  }\n\n  _Module['exit'] = exit;\n  var abortDecorators = [];\n\n  function abort(what) {\n    if (_Module['onAbort']) {\n      _Module['onAbort'](what);\n    }\n\n    if (what !== undefined) {\n      _Module.print(what);\n\n      _Module.printErr(what);\n\n      what = JSON.stringify(what);\n    } else {\n      what = '';\n    }\n\n    ABORT = true;\n    EXITSTATUS = 1;\n    var extra = '';\n    var output = 'abort(' + what + ') at ' + stackTrace() + extra;\n\n    if (abortDecorators) {\n      abortDecorators.forEach(function (decorator) {\n        output = decorator(output, what);\n      });\n    }\n\n    throw output;\n  }\n\n  _Module['abort'] = abort; // {{PRE_RUN_ADDITIONS}}\n\n  if (_Module['preInit']) {\n    if (typeof _Module['preInit'] == 'function') _Module['preInit'] = [_Module['preInit']];\n\n    while (_Module['preInit'].length > 0) {\n      _Module['preInit'].pop()();\n    }\n  }\n\n  _Module[\"noExitRuntime\"] = true;\n  run(); // {{POST_RUN_ADDITIONS}}\n  // {{MODULE_ADDITIONS}}\n\n  return _Module;\n};\n\nif (( false ? undefined : _typeof(exports)) === 'object' && ( false ? undefined : _typeof(module)) === 'object') module.exports = Module;else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n  return Module;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../iota-pico-lib-nodejs/node_modules/webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-wasm/wasm/iota-pico-pow-wasm.js?");

/***/ }),

/***/ "./dist/index.js":
/*!***********************!*\
  !*** ./dist/index.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function __export(m) {\n  for (var p in m) {\n    if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n  }\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Combined index of all the modules.\r\n */\n\n__export(__webpack_require__(/*! @iota-pico/core */ \"../iota-pico-core/dist/index.js\"));\n\n__export(__webpack_require__(/*! @iota-pico/data */ \"../iota-pico-data/dist/index.js\"));\n\n__export(__webpack_require__(/*! @iota-pico/api */ \"../iota-pico-api/dist/index.js\"));\n\n__export(__webpack_require__(/*! @iota-pico/crypto */ \"../iota-pico-crypto/dist/index.js\"));\n\n__export(__webpack_require__(/*! @iota-pico/business */ \"../iota-pico-business/dist/index.js\"));\n\n__export(__webpack_require__(/*! @iota-pico/pal-nodejs */ \"../iota-pico-pal-nodejs/dist/index.js\"));\n\n__export(__webpack_require__(/*! @iota-pico/pow-box */ \"../iota-pico-pow-box/dist/index.js\"));\n\n__export(__webpack_require__(/*! @iota-pico/pow-js */ \"../iota-pico-pow-js/dist/index.js\"));\n\n__export(__webpack_require__(/*! @iota-pico/pow-nodejs */ \"../iota-pico-pow-nodejs/dist/index.js\"));\n\n__export(__webpack_require__(/*! @iota-pico/pow-wasm */ \"../iota-pico-pow-wasm/dist/index.js\"));\n\n//# sourceURL=webpack://%5Bobject_Object%5D/./dist/index.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\r\n\tif (!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif (!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/(webpack)/buildin/module.js?");

/***/ }),

/***/ "./pkg/bootstrap.js":
/*!**************************!*\
  !*** ./pkg/bootstrap.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports.default = __webpack_require__(/*! ../dist/index */ \"./dist/index.js\");\n\n//# sourceURL=webpack://%5Bobject_Object%5D/./pkg/bootstrap.js?");

/***/ }),

/***/ "big-integer":
/*!*********************************************************************************************************!*\
  !*** external {"amd":"big-integer","commonjs":"big-integer","commonjs2":"big-integer","root":"bigInt"} ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"big-integer\");\n\n//# sourceURL=webpack://%5Bobject_Object%5D/external_%7B%22amd%22:%22big-integer%22,%22commonjs%22:%22big-integer%22,%22commonjs2%22:%22big-integer%22,%22root%22:%22bigInt%22%7D?");

/***/ }),

/***/ "ffi":
/*!**********************!*\
  !*** external "ffi" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"ffi\");\n\n//# sourceURL=webpack://%5Bobject_Object%5D/external_%22ffi%22?");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"fs\");\n\n//# sourceURL=webpack://%5Bobject_Object%5D/external_%22fs%22?");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"http\");\n\n//# sourceURL=webpack://%5Bobject_Object%5D/external_%22http%22?");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"https\");\n\n//# sourceURL=webpack://%5Bobject_Object%5D/external_%22https%22?");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"os\");\n\n//# sourceURL=webpack://%5Bobject_Object%5D/external_%22os%22?");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"path\");\n\n//# sourceURL=webpack://%5Bobject_Object%5D/external_%22path%22?");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"util\");\n\n//# sourceURL=webpack://%5Bobject_Object%5D/external_%22util%22?");

/***/ })

/******/ })["default"];